<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="本文基于spark源码2.11 1. 概要spark中网络通信无处不在，例如  driver和master的通信，比如driver会想master发送RegisterApplication消息 master和worker的通信，比如worker会向master上报worker上运行Executor信息 executor和driver的的通信，executor运行在worker上，spark的tas">
<meta property="og:type" content="article">
<meta property="og:title" content="Spark RPC的实现">
<meta property="og:url" content="http://yoursite.com/2017/05/01/Spark-RPC的实现/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="本文基于spark源码2.11 1. 概要spark中网络通信无处不在，例如  driver和master的通信，比如driver会想master发送RegisterApplication消息 master和worker的通信，比如worker会向master上报worker上运行Executor信息 executor和driver的的通信，executor运行在worker上，spark的tas">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="http://yoursite.com/image/spark/spark-rpc.png">
<meta property="og:updated_time" content="2018-01-28T02:31:02.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Spark RPC的实现">
<meta name="twitter:description" content="本文基于spark源码2.11 1. 概要spark中网络通信无处不在，例如  driver和master的通信，比如driver会想master发送RegisterApplication消息 master和worker的通信，比如worker会向master上报worker上运行Executor信息 executor和driver的的通信，executor运行在worker上，spark的tas">
<meta name="twitter:image" content="http://yoursite.com/image/spark/spark-rpc.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/05/01/Spark-RPC的实现/"/>





  <title>Spark RPC的实现 | Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/01/Spark-RPC的实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Li Weisheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">Spark RPC的实现</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-01T10:28:40+08:00">
                2017-05-01
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><em>本文基于spark源码2.11</em></p>
<h1 id="1-概要"><a href="#1-概要" class="headerlink" title="1. 概要"></a>1. 概要</h1><p>spark中网络通信无处不在，例如</p>
<ul>
<li>driver和master的通信，比如driver会想master发送RegisterApplication消息</li>
<li>master和worker的通信，比如worker会向master上报worker上运行Executor信息</li>
<li>executor和driver的的通信，executor运行在worker上，spark的tasks被分发到运行在各个executor中，executor需要通过向driver发送任务运行结果。</li>
<li>worker和worker的通信，task运行期间需要从其他地方fetch数据，这些数据是由运行在其他worker上的executor上的task产生，因此需要到worker上fetch数据</li>
</ul>
<p>总结起来通信主要存在两个方面：</p>
<ol>
<li>汇集信息，例如task变化信息，executor状态变化信息。</li>
<li>传输数据，spark shuffle（也就是reduce从上游map的输出中汇集输入数据）阶段存在大量的数据传输。</li>
</ol>
<p>在spark中这两种采用了不同的实现方式，对于 1 spark基于netty实现了简单的rpc服务框架，对于 2 同样基于netty实现了数据传输服务。</p>
<h2 id="2-基于netty的rpc实现"><a href="#2-基于netty的rpc实现" class="headerlink" title="2. 基于netty的rpc实现"></a>2. 基于netty的rpc实现</h2><p>rpc两端称为endpoint，提供服务的一端需要实现RpcEndpoint接口，该接口主要下面两个方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">def receive: PartialFunction[Any, Unit] = &#123;</span><br><span class="line">   case _ =&gt; throw new SparkException(self + &quot; does not implement &apos;receive&apos;&quot;)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> def receiveAndReply(context: RpcCallContext): PartialFunction[Any, Unit] = &#123;</span><br><span class="line">   case _ =&gt; context.sendFailure(new SparkException(self + &quot; won&apos;t reply anything&quot;))</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>实现这两个方法，完成对消息的处理，这辆个方法不同之处在于receiveAndReply可以通过context向服务请求这回复。实现这个接口之后，实例化，然后注册实例。请求服务的一方需要注册的只是EndpointRef，通过EndpointRef发起服务请求。</p>
<p>spark中需要提供rpc服务的地方主要有：</p>
<ol>
<li>MapoutTracker，MapoutTracker有两个实现类：MapoutTrackerMaster和MapoutTrackerWorker。前者运行在Driver端，后者运行在每一个executor上，两者通信用来保存ShuffleMapTask的map输出数据信息。MapoutTrackerMaster持有MapoutTrackerMasterEndpoint接收信息，MapoutTrackerWorker持有EndpointRef回报map out信息</li>
<li>BlockManager，BlockManager负责spark运行期间的数据信息的收集以及存与取，BlockManager运行在Driver和每一个executor上，BlockManager持有BlockManagerMaster，在Driver上BlockManagerMaster持有BlockManagerMasterEndpoint，executor上持有EndpointRef，executor调用blockmanager汇报信息，实际上是通过endpointref汇集到driver上。</li>
<li>StandaloneAppClient，ScheduleBackend持有它（standalone模式下，实例话为CoarseGrainedSchedulerBackend），在standalone部署模式下，driver通过它来与master通信</li>
<li>DriverEndpoint，ScheduleBackend（standalone模式下，实例话为CoarseGrainedSchedulerBackend）用来与executor通信，收集executor信息，收集task变化信息</li>
<li>Worker,Master，维持心跳，运行executor，运行task</li>
<li>CoarseGrainedExecutorBackend，每一个executor对应一个，和driver通信运行或取消任务等</li>
</ol>
<h3 id="2-1-注册服务"><a href="#2-1-注册服务" class="headerlink" title="2.1 注册服务"></a>2.1 注册服务</h3><p>下面是SparkEnv在初始化过程中注册MapMapOutputTrackerMasterEndpoint的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">def registerOrLookupEndpoint(</span><br><span class="line">        name: String, endpointCreator: =&gt; RpcEndpoint):</span><br><span class="line">      RpcEndpointRef = &#123;</span><br><span class="line">      if (isDriver) &#123;</span><br><span class="line">        logInfo(&quot;Registering &quot; + name)</span><br><span class="line">        rpcEnv.setupEndpoint(name, endpointCreator)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        RpcUtils.makeDriverRef(name, conf, rpcEnv)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line">mapOutputTracker.trackerEndpoint = </span><br><span class="line">      registerOrLookupEndpoint(</span><br><span class="line">             MapOutputTracker.ENDPOINT_NAME,</span><br><span class="line">             new MapOutputTrackerMasterEndpoint(</span><br><span class="line">                     rpcEnv, </span><br><span class="line">                     mapOutputTracker.asInstanceOf[MapOutputTrackerMaster], conf))</span><br></pre></td></tr></table></figure></p>
<p>调用<code>registerOrLookupEndpoint</code>完成注册，并且返回一个endpointref，通过endpointref发送请求。registerOrLookupEndpoint接收一个参数name，用来标识一个rpc服务。</p>
<p>registerOrLookupEndpoint在driver端和worker上有不同的处理方式，在driver端创建出endpoint的实例，并注册该实例提供服务，在非driver端则创建一个endpointref返回供rpc请求端发送请求时使用。下面是RpcEndpointRef类的核心属性和方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private[spark] abstract class RpcEndpointRef(conf: SparkConf)</span><br><span class="line">  def address: RpcAddress</span><br><span class="line">  def name: String</span><br><span class="line">  def send(message: Any): Unit</span><br><span class="line">  def ask[T: ClassTag](message: Any, timeout: RpcTimeout): Future[T]</span><br><span class="line">  def askSync[T: ClassTag](message: Any, timeout: RpcTimeout): T</span><br></pre></td></tr></table></figure></p>
<ul>
<li>name返回的就是在注册rpc服务时的提供的名字。</li>
<li>address 是服务提供方的host,port。</li>
<li>send，ask方法用来发送请求，区别是send没有不需要response,ask则需要。</li>
</ul>
<p>只看在driver上是如何注册服务的，调用rpcEnv.setupEndpoint注册服务，这里的rpcEnv实际上是实例NettyRpcEnv。</p>
<p>下面的图是NettyRpcEnv一张结构图：</p>
<p><img src="/image/spark/spark-rpc.png" alt="spark-rpc.png"></p>
<h4 id="2-1-1-服务端"><a href="#2-1-1-服务端" class="headerlink" title="2.1.1 服务端"></a>2.1.1 服务端</h4><p>创建SparkEnv时，调用<code>val rpcEnv = RpcEnv.create(...)</code>,这个方法调用NettyRpcEnvFactory#create创建NettyRpcEnv的实例。create方法判断如果实在driver端，则创建TransportServer，调用链路是：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">NettyRpcEnvFactory#create#创建nettyrpcenv -&gt; NettyRpcEnv#startServer -&gt; </span><br><span class="line">TransportContext#createServer()#创建TransportServer监听端口提供服务</span><br></pre></td></tr></table></figure>
<p><strong>NettyRpcEnv</strong><br>SparkEnv持有rpcEnv是NettyRpcEnv的实例，下面的NettyRpcEnv的核心的属性方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private val dispatcher: Dispatcher = new Dispatcher(this)</span><br><span class="line"></span><br><span class="line">private val streamManager = new NettyStreamManager(this)</span><br><span class="line"></span><br><span class="line">private val transportContext = new TransportContext(transportConf,</span><br><span class="line">    new NettyRpcHandler(dispatcher, this, streamManager))</span><br><span class="line"></span><br><span class="line">private val outboxes = new ConcurrentHashMap[RpcAddress, Outbox]()</span><br></pre></td></tr></table></figure></p>
<ol>
<li>dispatcher,  endpoint服务注册到dispatcher上，请求服务时指定name请求服务，dispatcher根据name将消息转发到对应的endpoint。</li>
<li>transportContext，用来创建TransportServer监听端口接收消息。</li>
<li>outboxes，每一个endpointref都包装了RpcAddress表示endpoint地址，上图中通过send/ask请求某个endpoint的服务时，消息都会先发送到Outbox中，outboxes缓存了一个endpoint到其outbox的映射，方便查找，下面代码是Outbox类的一些成员。<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private[netty] class Outbox(nettyEnv: NettyRpcEnv, val address: RpcAddress) &#123;</span><br><span class="line"> // 使用队列保存要发送出去的消息</span><br><span class="line">  private val messages = new java.util.LinkedList[OutboxMessage]</span><br><span class="line">// 本次发送者client，TransportClient下一节介绍</span><br><span class="line">  private var client: TransportClient = null</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong> Dispatcher</strong><br>endpointref注册在dispatcher上， TransportServer端最后的NettyRpcHandler接收到处理完消息后通过dispathcer转发到具体的endpoint上。下面是Dispatcher类：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">private[netty] class Dispatcher(nettyEnv: NettyRpcEnv) extends Logging &#123;</span><br><span class="line"></span><br><span class="line">  private class EndpointData(</span><br><span class="line">      val name: String,</span><br><span class="line">      val endpoint: RpcEndpoint,</span><br><span class="line">      val ref: NettyRpcEndpointRef) &#123;</span><br><span class="line">    val inbox = new Inbox(ref, endpoint)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  private val endpoints: ConcurrentMap[String, EndpointData] =</span><br><span class="line">    new ConcurrentHashMap[String, EndpointData]</span><br><span class="line">  private val endpointRefs: ConcurrentMap[RpcEndpoint, RpcEndpointRef] =</span><br><span class="line">    new ConcurrentHashMap[RpcEndpoint, RpcEndpointRef]</span><br><span class="line"></span><br><span class="line">  // Track the receivers whose inboxes may contain messages.</span><br><span class="line">  private val receivers = new LinkedBlockingQueue[EndpointData]</span><br></pre></td></tr></table></figure>
<ol>
<li>endpoints是name（注册时提供的服务名称）到endpointdata的映<br>射。</li>
<li>Inbox, 前面的图中TransportServer端接收到的消息，dispatcher根据name从endpoints中检索到之后放到对应的inbox中</li>
<li>receivers，dispatcher接收到数据，dispatch到各自的inbox中之后，并不会马上调用endpoint处理，而是在另外一个线程MessageLoop中专门处理，receivers保存了收到消息的endpoint所属的endpointdata，MessageLoop即根据receivers中的成员知道要调用哪些endpoint的处理逻辑。</li>
</ol>
<p><strong> TransportServer</strong><br>TranportContext#createServer创建了一个基于Netty的server监听端口提供服务. 下面是创建TransportServer的过程：</p>
<ol>
<li>transportContext的创建，这在NettyRpcEnv创建过程中创建，创建方式：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">private val transportContext = new TransportContext(transportConf,</span><br><span class="line">  new NettyRpcHandler(dispatcher, this, streamManager))</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>并使用了NettyRpcHandler的实例作参数，NettyRpcHandler是服务端管道最后一个handler，也就是在其handle方法中调用dispatcher完成消息转发</p>
<ol>
<li>调用 <code>transportContext#createServer(bindAddress, port, bootstraps)</code> ，bindAddress和port即rpc监听的地址和端口，这两个是由配置文件中<code>spark.driver.bindAddress</code>和<code>spark.driver.port</code>指定</li>
<li>2中createServer最终调用TransportServer.init()初始化一个TransportServer，下面是init方法<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">private void init(String hostToBind, int portToBind) &#123;</span><br><span class="line"></span><br><span class="line">    IOMode ioMode = IOMode.valueOf(conf.ioMode());</span><br><span class="line">    EventLoopGroup bossGroup =</span><br><span class="line">      NettyUtils.createEventLoop(ioMode, conf.serverThreads(), conf.getModuleName() + &quot;-server&quot;);</span><br><span class="line">    EventLoopGroup workerGroup = bossGroup;</span><br><span class="line"></span><br><span class="line">    bootstrap = new ServerBootstrap()</span><br><span class="line">      .group(bossGroup, workerGroup)</span><br><span class="line">      .channel(NettyUtils.getServerChannelClass(ioMode))</span><br><span class="line">      .option(ChannelOption.ALLOCATOR, allocator)</span><br><span class="line">      .childOption(ChannelOption.ALLOCATOR, allocator);</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">...</span><br><span class="line">    bootstrap.childHandler(new ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">      @Override</span><br><span class="line">      protected void initChannel(SocketChannel ch) throws Exception &#123;</span><br><span class="line">        RpcHandler rpcHandler = appRpcHandler;</span><br><span class="line">        for (TransportServerBootstrap bootstrap : bootstraps) &#123;</span><br><span class="line">          rpcHandler = bootstrap.doBootstrap(ch, rpcHandler);</span><br><span class="line">        &#125;</span><br><span class="line">        context.initializePipeline(ch, rpcHandler);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    InetSocketAddress address = hostToBind == null ?</span><br><span class="line">        new InetSocketAddress(portToBind): new InetSocketAddress(hostToBind, portToBind);</span><br><span class="line">    channelFuture = bootstrap.bind(address);</span><br><span class="line">    channelFuture.syncUninterruptibly();</span><br><span class="line"></span><br><span class="line">    port = ((InetSocketAddress) channelFuture.channel().localAddress()).getPort();</span><br><span class="line">    logger.debug(&quot;Shuffle server started on port: &#123;&#125;&quot;, port);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>这是netty创建服务端的用法，每一个client的链接被看作一个channel，channel上可以注册多个handler，消息从channel流进流出，被一个个注册在channel上的handler处理，到达用户层面或者被发送至网络。bootstrap.childHandler方法，就是用来初始化一个新的client连接生成的channel。</p>
<p> <code>context.initializePipeline(ch, rpcHandler);</code>（此处的rpcHandler就是NettyRpcHandler）对channel进行初始化，也就是注册handler，下面是initializePipeline的代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public TransportChannelHandler initializePipeline(</span><br><span class="line">      SocketChannel channel,</span><br><span class="line">      RpcHandler channelRpcHandler) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      TransportChannelHandler channelHandler = createChannelHandler(channel, channelRpcHandler);</span><br><span class="line">      channel.pipeline()</span><br><span class="line">        .addLast(&quot;encoder&quot;, ENCODER)</span><br><span class="line">        .addLast(TransportFrameDecoder.HANDLER_NAME, NettyUtils.createFrameDecoder())</span><br><span class="line">        .addLast(&quot;decoder&quot;, DECODER)</span><br><span class="line">        .addLast(&quot;idleStateHandler&quot;, new IdleStateHandler(0, 0, conf.connectionTimeoutMs() / 1000))</span><br><span class="line">        // NOTE: Chunks are currently guaranteed to be returned in the order of request, but this</span><br><span class="line">        // would require more logic to guarantee if this were not part of the same event loop.</span><br><span class="line">        .addLast(&quot;handler&quot;, channelHandler);</span><br><span class="line">      return channelHandler;</span><br><span class="line">    &#125; catch (RuntimeException e) &#123;</span><br><span class="line">      logger.error(&quot;Error while initializing Netty pipeline&quot;, e);</span><br><span class="line">      throw e;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>注册ENCODER，DECODER，channelHandler（包含前图中TransportRequestHandler和TransportReponseHandler分别用来处理请求消息和回复消息）</p>
<p><strong>  消息接收流程</strong><br>以<code>OneWayMessage</code>为例，这种消息不需要response。服务端接收到消息，经过如下处理步骤：</p>
<ol>
<li>由Decoder(MessageDecoder的实例)做decode处理，生成OneWayMessage</li>
<li>交给TransportRequestHandler处理，这个handler直接交给rpcHandler#receive（NettyRpcHandler）处理</li>
<li>NettyRpcHandler#receive调用    <code>dispatcher.postOneWayMessage(messageToDispatch)</code>，消息转到Dispatcher。</li>
<li>Dispathcer#postOneWayMessage, 最终调用Dispatcher#postMessage,代码如下：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">private def postMessage(</span><br><span class="line">      endpointName: String,</span><br><span class="line">      message: InboxMessage,</span><br><span class="line">      callbackIfStopped: (Exception) =&gt; Unit): Unit = &#123;</span><br><span class="line">    val error = synchronized &#123;</span><br><span class="line">      // 根据请求的endpoint name找到endpoint</span><br><span class="line">      val data = endpoints.get(endpointName)</span><br><span class="line">      if (stopped) &#123;</span><br><span class="line">        Some(new RpcEnvStoppedException())</span><br><span class="line">      &#125; else if (data == null) &#123;</span><br><span class="line">        Some(new SparkException(s&quot;Could not find $endpointName.&quot;))</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">       // 向对应的endpoint的inbox中放入消息</span><br><span class="line">        data.inbox.post(message)</span><br><span class="line">      // 有消息待处理的endpoint</span><br><span class="line">        receivers.offer(data)</span><br><span class="line">        None</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    // We don&apos;t need to call `onStop` in the `synchronized` block</span><br><span class="line">    error.foreach(callbackIfStopped)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上述代码只是向inbox中放入消息，然后在receiver中放入接收到消息待处理的endpoint，并没有处理消息，也就是调用endpoint的receive/receiveAndReply方法。在哪里处理的？Dispatcher是通过另启动的线程池来移步处理消息的，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private val threadpool: ThreadPoolExecutor = &#123;</span><br><span class="line">    val numThreads = nettyEnv.conf.getInt(&quot;spark.rpc.netty.dispatcher.numThreads&quot;,</span><br><span class="line">      math.max(2, Runtime.getRuntime.availableProcessors()))</span><br><span class="line">    val pool = ThreadUtils.newDaemonFixedThreadPool(numThreads, &quot;dispatcher-event-loop&quot;)</span><br><span class="line">    for (i &lt;- 0 until numThreads) &#123;</span><br><span class="line">      pool.execute(new MessageLoop)</span><br><span class="line">    &#125;</span><br><span class="line">    pool</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /** Message loop used for dispatching messages. */</span><br><span class="line">  private class MessageLoop extends Runnable &#123;</span><br><span class="line">    override def run(): Unit = &#123;</span><br><span class="line">      try &#123;</span><br><span class="line">        while (true) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">            val data = receivers.take()</span><br><span class="line">            if (data == PoisonPill) &#123;</span><br><span class="line">              // Put PoisonPill back so that other MessageLoops can see it.</span><br><span class="line">              receivers.offer(PoisonPill)</span><br><span class="line">              return</span><br><span class="line">            &#125;</span><br><span class="line">            data.inbox.process(Dispatcher.this)</span><br><span class="line">          &#125; catch &#123;</span><br><span class="line">            case NonFatal(e) =&gt; logError(e.getMessage, e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; catch &#123;</span><br><span class="line">        case ie: InterruptedException =&gt; // exit</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>MessageLoop从receiver中取下一个endpointdata，调用其所拥有的inbox#process处理，在process方法里调用endpoint的receive(OnewayMessage这种不需要回复的request调用)或者receiveAndReply(RpcMessage这种需要回复的消息调用)来根据消息作出不同处理。</p>
<h4 id="2-1-2-客户端"><a href="#2-1-2-客户端" class="headerlink" title="2.1.2 客户端"></a>2.1.2 客户端</h4><p>客户端通过RpcEndpointRef#send或者ask向这个rpcendpointref代表的远程服务发送请求，RpcEndpointRef是一个抽象类，使用NettyRpcEndpointRef实例化，以NettyRpcEndpointRef#send为例（send发送的消息不需要回复）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">override def send(message: Any): Unit = &#123;</span><br><span class="line">    require(message != null, &quot;Message is null&quot;)</span><br><span class="line">    nettyEnv.send(new RequestMessage(nettyEnv.address, this, message))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>将消息包装成RequestMessage，调用netty#send进入NettyRpcEnv#send如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">private[netty] def send(message: RequestMessage): Unit = &#123;</span><br><span class="line">    val remoteAddr = message.receiver.address</span><br><span class="line">     </span><br><span class="line">    // 请求的远程地址就是本地地址，直接使用dispatcher递交到本地endpointref的outbox处理</span><br><span class="line">    if (remoteAddr == address) &#123;</span><br><span class="line">      // Message to a local RPC endpoint.</span><br><span class="line">      try &#123;</span><br><span class="line">        dispatcher.postOneWayMessage(message)</span><br><span class="line">      &#125; catch &#123;</span><br><span class="line">        case e: RpcEnvStoppedException =&gt; logWarning(e.getMessage)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // Message to a remote RPC endpoint.</span><br><span class="line">      postToOutbox(message.receiver, OneWayOutboxMessage(message.serialize(this)))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>调用<code>postToOutBox(receiver: NettyRpcEndpointRef, message: OutboxMessage）</code>,对于使用send发送到远端的消息则创建OneWayOutboxMessage。关于postToOutBox的message参数，其类型OutboxMessage是一个抽象类，结构如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">private[netty] sealed trait OutboxMessage &#123;</span><br><span class="line"></span><br><span class="line">  def sendWith(client: TransportClient): Unit</span><br><span class="line"></span><br><span class="line">  def onFailure(e: Throwable): Unit</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>最后的发送是调用sendWith发送，他有两个实现类：</p>
<ul>
<li>OneWayOutboxMessage， RpcEndpointRef#send发送的是此类消息，不用回复。</li>
<li>RpcOutboxMessage， RpcEndpointRef#ask，askSync发送的是此类消息，需要等待回复。</li>
</ul>
<p>postToOutbox会根据接收地址在outboxes中检索出对应的outbox，调用outbox#send将消息完成发送。</p>
<p><strong>TransportClient</strong><br>OutboxMessage#sendWith(client:TransportClient)发送消息是通过TransportClient发送的，TransportClient是通过TransportClientFactory创建的，注册的handler与server一样。但是对于发送出去的消息只经过MessageEncoder#encode处理过一次。</p>
<p><strong>RpcEndpointRef send 和ask的区别</strong><br>send和ask的区别前文多次提到，send发送完直接返回不需要回复，和ask是需要对端回复的，下面是NettyRpcEndpointRef的send和ask方法的签名：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">override def ask[T: ClassTag](message: Any, timeout: RpcTimeout): Future[T] = &#123;</span><br><span class="line">   nettyEnv.ask(new RequestMessage(nettyEnv.address, this, message), timeout)</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> override def send(message: Any): Unit = &#123;</span><br><span class="line">   require(message != null, &quot;Message is null&quot;)</span><br><span class="line">   nettyEnv.send(new RequestMessage(nettyEnv.address, this, message))</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>ask返回了Future用来异步的获取返回值，进入NettyRpcEnv#ask返回就会知道ask的message参数会被封装成RpcOutboxMessage，下面是RpcOutboxMessage#sendWith的实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">override def sendWith(client: TransportClient): Unit = &#123;</span><br><span class="line">   this.client = client</span><br><span class="line">   this.requestId = client.sendRpc(content, this)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>调用<code>TransportClient#sendRpc(ByteBuffer message, RpcResponseCallback callback)</code>,接收一个callback作为本次rpc请求有返回结果是毁掉，返回的是一个标识一次rpc的独一无二的requestid。 下面是<code>TransportClient#sendRpc(ByteBuffer message, RpcResponseCallback callback)</code>的部分代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">public long sendRpc(ByteBuffer message, RpcResponseCallback callback) &#123;</span><br><span class="line">    long startTime = System.currentTimeMillis();</span><br><span class="line">    if (logger.isTraceEnabled()) &#123;</span><br><span class="line">      logger.trace(&quot;Sending RPC to &#123;&#125;&quot;, getRemoteAddress(channel));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    long requestId = Math.abs(UUID.randomUUID().getLeastSignificantBits());</span><br><span class="line">    handler.addRpcRequest(requestId, callback);</span><br><span class="line"></span><br><span class="line">    channel.writeAndFlush(new RpcRequest(requestId, new NioManagedBuffer(message)))</span><br><span class="line">        .addListener(future -&gt; &#123;</span><br><span class="line">         ...</span><br><span class="line">         ... </span><br><span class="line">         ...</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">    return requestId;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中为本次rpc请求生成了唯一的requestId，然后调用writeAndFlush发送消息。还调用handler.addRpcRequest,这个handler是TransportResponseHandler的实例，TransportResponseHandler#addRpcRequest()如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">public void addRpcRequest(long requestId, RpcResponseCallback callback) &#123;</span><br><span class="line">    updateTimeOfLastRequest();</span><br><span class="line">    // 将生成的requestId ，callback映射保存下来</span><br><span class="line">    outstandingRpcs.put(requestId, callback);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>(requestId,callBack)映射被保存下来，显然是等待对端回复requestId之后，调用callBack用，前面图中回复经过Decode之后，流进TransportResponseHandler，在TransportResponseHandler#handle中处理decode之后的数据，handle中处理RpcResponse如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">public void handle(ResponseMessage message) throws Exception &#123;</span><br><span class="line">    if (message instanceof ChunkFetchSuccess) &#123;</span><br><span class="line">       ...</span><br><span class="line">       ...</span><br><span class="line">    &#125; else if (message instanceof ChunkFetchFailure) &#123;</span><br><span class="line">       ... </span><br><span class="line">       ...</span><br><span class="line">    &#125; else if (message instanceof RpcResponse) &#123;</span><br><span class="line">      RpcResponse resp = (RpcResponse) message;</span><br><span class="line">      RpcResponseCallback listener = outstandingRpcs.get(resp.requestId);</span><br><span class="line">      if (listener == null) &#123;</span><br><span class="line">        logger.warn(&quot;Ignoring response for RPC &#123;&#125; from &#123;&#125; (&#123;&#125; bytes) since it is not outstanding&quot;,</span><br><span class="line">          resp.requestId, getRemoteAddress(channel), resp.body().size());</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        outstandingRpcs.remove(resp.requestId);</span><br><span class="line">        try &#123;</span><br><span class="line">          listener.onSuccess(resp.body().nioByteBuffer());</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">          resp.body().release();</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else if (message instanceof RpcFailure) &#123;</span><br><span class="line">      ... </span><br><span class="line">      ...</span><br><span class="line">    &#125; else if (message instanceof StreamResponse) &#123;</span><br><span class="line">       ...</span><br><span class="line">       ...</span><br><span class="line">    &#125; else if (message instanceof StreamFailure) &#123;</span><br><span class="line">       ...</span><br><span class="line">       ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>处理RpcResponse的分支中，根据requestId取出callback，然后调用onSuccess，填充Future的结果，关于这个callback是何处生成然后被传递的，最初RpcEndpointRef#ask方法调用的NettyRpcEnv#ask方法。</p>
<p><strong> Scala的Future 和Promise</strong><br>上面介绍ask方法时，结果是异步返回的，ask只是返回了一个Future，这是使用scala异步编程的一种方式，下面是介绍Future和Promise的用法的文章</p>
<ol>
<li><a href="http://udn.yyuap.com/doc/guides-to-scala-book/chp9-promises-and-futures-in-practice.html" target="_blank" rel="noopener">Scala Future 和 Promise</a></li>
</ol>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/05/06/Spark-Shuffle-Write-和Read/" rel="prev" title="Spark Shuffle Write 和Read">
                Spark Shuffle Write 和Read <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Li Weisheng</p>
              <p class="site-description motion-element" itemprop="description">不积跬步，无以至千里</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#1-概要"><span class="nav-number">1.</span> <span class="nav-text">1. 概要</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#2-基于netty的rpc实现"><span class="nav-number">1.1.</span> <span class="nav-text">2. 基于netty的rpc实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#2-1-注册服务"><span class="nav-number">1.1.1.</span> <span class="nav-text">2.1 注册服务</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-1-服务端"><span class="nav-number">1.1.1.1.</span> <span class="nav-text">2.1.1 服务端</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#2-1-2-客户端"><span class="nav-number">1.1.1.2.</span> <span class="nav-text">2.1.2 客户端</span></a></li></ol></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Li Weisheng</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
