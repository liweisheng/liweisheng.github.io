<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="不积跬步，无以至千里">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="不积跬步，无以至千里">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="不积跬步，无以至千里">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/2/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/12/Spark内存管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Li Weisheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/12/Spark内存管理/" itemprop="url">Spark内存管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-12T21:02:54+08:00">
                2017-11-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-存储总体结构"><a href="#1-存储总体结构" class="headerlink" title="1. 存储总体结构"></a>1. 存储总体结构</h1><p>Spark存储结构分为两层：内存存储和磁盘存储，其中内存主要用作缓存以及任务计算时期数据存储，磁盘用在内存存储不足时使用。Executor和Driver都是委托BlockManager来管理存储以及Executor和Driver的通信（主要是数据传输和数据块信息的回报），BlockManager体系结结构如下图：<br><img src="/image/spark/spark-memory-arch.png" alt="存储体系结构"></p>
<ol>
<li>其中DiskStore实现数据块到磁盘的存取。</li>
<li>MemoryStore负责数据块在内存中存储</li>
</ol>
<p>由于分配给Executor和Driver内存资源有限，需要小心的分配避免OOM的出现，同时也需要合理分分配避免内存资源的浪费，因此MemoryStore使用MemoryManager来管理内存，MemoryAllocator来分配内存。</p>
<p>对内存的管理包含了对内存使用的监控和真正的内存分配。反应到上图中MemoryManager仅仅完成内存使用情况的监控，内存的分配则是通过MemoryAllocator实现的，本文主要介绍一下MemoryManager的使用</p>
<h1 id="2-MemoryManager"><a href="#2-MemoryManager" class="headerlink" title="2. MemoryManager"></a>2. MemoryManager</h1><p>Spakr中内存包括堆上内存（On-heap）和堆外内存(Off-heap), MemoryManager管理着这两种内存的使用情况（总大小，使用多少，剩余多少之类的）。所以真正分配内存之前，还是需要通过memoryManager提供的接口判断是否有足够的剩余内存以供使用，然后才去通过memoryAllocator去执行分配操作。</p>
<p>目前MemoryManager有两种实现方式：StaticMemoryManager，UnifiedMemoryManager。UnifiedMemoryManager是1.6后增加的，默认会使用这种方式。</p>
<blockquote>
<p>用过配置spark.memory.useLegacyMode=true 使用StaticMemoryManager</p>
</blockquote>
<p>不管哪种方式，堆上内存和堆外内存都被划分为execution memory和storage memory</p>
<ol>
<li>execution memory主要用于计算，例如shuffle过程中从上游分区fetch过来的数据就是临时存储在execution memory中，以方便快速的做reduce操作等。</li>
<li>storage memory用户缓存数据，例如RDD # cache的调用就是将rdd的数据缓存在内存中重复使用</li>
</ol>
<p>storage memory还分出一块叫着unroll memory的块，原因是spark中数据可以是序列化的数据，当需要将序列化的数据存到内存中时，通过iterator一条条取出反序列化后的数据过程就是unroll， 由于不知道会有多少数据，所以这个过程是内存使用是逐渐增长的，这部分动态变化的内存就是unroll memory</p>
<h2 id="2-1-StaticMemoryManager"><a href="#2-1-StaticMemoryManager" class="headerlink" title="2.1 StaticMemoryManager"></a>2.1 StaticMemoryManager</h2><p>内存 结构如下：</p>
<p><img src="/image/spark/spark-memory-static.png" alt="StaticMemoryManager内存划分"></p>
<ol>
<li>execution mem占用比例由<code>spark.shuffle.memoryFraction</code>控制默认20%</li>
<li>execution mem中safty mem是可用于计算的内存，由<code>spark.shuffle.safetyFraction</code>设置，默认80%。留一个安全内存区的原因可能是内存使用大小的计算不是一个精确值，留有余地可以避免一个可能很大的对象放进去之后导致内存不够。所有如果execution memory绝对值很大的话，理论上safty mem的比例可以设置到高一点。</li>
<li>storage mem通过<code>spark.storage.memoryFraction</code>设置比例，默认是60</li>
<li>storage mem同样有一个安全使用比例，通过<code>spark.storage.safetyFraction</code>设置，默认是90。当storage mem的绝对大小很大时，也可以适当提高这个安全比例</li>
<li>storage mem中有一部分留作unroll内存，通过<code>spark.storage.unrollFraction</code>设置比例。</li>
</ol>
<p>使用StaticMemoryManager时不能使用堆外内存。</p>
<h2 id="2-2-UnifiedMemoryManager"><a href="#2-2-UnifiedMemoryManager" class="headerlink" title="2.2 UnifiedMemoryManager"></a>2.2 UnifiedMemoryManager</h2><p>这是spark 1.6之后新引入的内存管理方式，也是当前默认的方式。在StaticmemoryManager中，storage memory和execution memory有很明确的界限，互相之间不能借用，在execution memory不够时，如果 storage memory存在空闲内存也不能临时借用，UnifiedMemoryManager为解决这种问题而出现。此外，UnifiedMemoryManager引入了对堆外内存的管理。</p>
<p>UnifiedMemoryManager的内存结构如下（下图只是on-heap内存划分，off-heap有些不一样）</p>
<p><img src="/image/spark/spark-memory-unified.png" alt="UnifiedMemoryManager内存结构"></p>
<ol>
<li>reserved mem是预留内存，用作spark execution &amp; storage以外的java对象的分配，默认大小是300M，不可改变. 同时要求整个堆区内存大小大于 1.5 * 300M.</li>
<li>除去reserved mem以外都是用于spark 的storage&amp;execution内存（下文称usable mem）， 但是实际实现中storage &amp; execution 内存被设置成usable mem的60%（由<code>spark.memory.fraction</code>设置），留有余地可能原因应该和StaticMemoryManager中的saftyFraction一样。</li>
<li>然后就是storage &amp; execution memory被平分给storage 和execution(可以通过<code>spark.memory.storageFraction</code>去调节)。</li>
</ol>
<p>UnifiedMemoryManager在管理内存使用中，execution和storage在不够的情况下可以向对对方借用内存，因此它们所占的比例是动态变化的。</p>
<p><strong>off-heap 内存</strong><br>堆外内存大小通过<code>spark.memory.offHeap.size</code>设置（默认是0），由于是对外内存，因此不需要预留内存给普通的对象分配，所以整个堆外内存用于storage &amp; execution, 比例同样通过<code>spark.memory.storageFraction</code>去调节, 和堆上内存一样，堆外storage和execution是可以相互借用的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/12/Spark-Sql-之-cacheTable/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Li Weisheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/12/Spark-Sql-之-cacheTable/" itemprop="url">Spark Sql 之 cacheTable</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-12T20:58:24+08:00">
                2017-11-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>spark sql中使用DataFrame/DataSet来抽象表示结构化数据（关系数据库中的table），DataSet上支持和RDD类似的操作，和RDD上的操作生成新的RDD一样，DataSet上的操作生成新的DataSet来表示新的数据抽象。最终DataSet上的这些操作经过：<br>logical plan -&gt; analyzed logical plan -&gt; optimized logical pan -&gt; physical plan -&gt; rdd dag的转化提交rdd 运行。这里plan（执行计划）就是DataSet上的转换操作，一个DataSet也就是对应一个logical plan生成的数据。</p>
<p>cacheTable也就是缓存DataSet抽象表示的数据，也就是DataSet的plan生成的数据。</p>
<h1 id="2-cacheTable"><a href="#2-cacheTable" class="headerlink" title="2. cacheTable"></a>2. cacheTable</h1><p>从上面的介绍可以看出DataSet只是数据的抽象，它描述了从数据源头开始经过怎样的执行计划（plan）才能得到当前的DataSet表示的真实数据，也就是必须等到执行计划提交spark job运行结束后才能得到数据。spark实现cacheTable时，并没有立即提交table（DataSet）对应的plan去运行，然后得到运行结果数据去缓存，而是采用一种lazy模式：最终在DataSet上调用一些触发任务提交的方法时（类似RDD的action操作），发现plan对应的抽象语法树中发现子树是表缓存plan，如果这个时候数据已经缓存了，直接使用缓存的数据，没有则触发缓存表的plan去执行，然后采用按列缓存的方式缓存数据。</p>
<p>看看代码实现：<br>调用SQLContext # cacheTable(tableName : String)最终会走到下面的调用：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// query 即缓存的Dataset</span></span><br><span class="line"><span class="comment">// storageLevel 可以使用memory和disk缓存</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cacheQuery</span></span>(</span><br><span class="line">      query: <span class="type">Dataset</span>[_],</span><br><span class="line">      tableName: <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">None</span>,</span><br><span class="line">      storageLevel: <span class="type">StorageLevel</span> = <span class="type">MEMORY_AND_DISK</span>): <span class="type">Unit</span> = writeLock &#123;</span><br><span class="line">    <span class="comment">// 拿到dataset的plan</span></span><br><span class="line">    <span class="keyword">val</span> planToCache = query.logicalPlan</span><br><span class="line">    <span class="keyword">if</span> (lookupCachedData(planToCache).nonEmpty) &#123;</span><br><span class="line">      logWarning(<span class="string">"Asked to cache already cached data."</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> sparkSession = query.sparkSession</span><br><span class="line">      <span class="comment">// 缓存是建立一个plan到InMemoryRelation的映射</span></span><br><span class="line">      cachedData.add(<span class="type">CachedData</span>(</span><br><span class="line">        planToCache,</span><br><span class="line">        <span class="type">InMemoryRelation</span>(</span><br><span class="line">          sparkSession.sessionState.conf.useCompression,</span><br><span class="line">          sparkSession.sessionState.conf.columnBatchSize,</span><br><span class="line">          storageLevel,</span><br><span class="line">          sparkSession.sessionState.executePlan(planToCache).executedPlan,</span><br><span class="line">          tableName)))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面InMemoryRelation是执行计划中一个节点，当出现<code>select * from table_a</code>语句（或者任何逻辑执行计划中有table_a出现），假设table_a被缓存了，那么这条语句生成的逻辑执行计划中，table_a对应的Relation节点会被执行计划优化器（optimizer）替换成InMemoryRelation。</p>
<p>InMemoryRelation构造参数：</p>
<ul>
<li>columnBatchSize，后面会提到，table缓存是按列缓存的，然后数据又被按行分为一个个batch，这个参数用来控制一个batch里行数，通过配置项<code>spark.sql.inMemoryColumnarStorage.batchSize</code>设置，默认是10000行。</li>
</ul>
<p>下面是InMemoryRelation中和缓存相关的代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">buildBuffers</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">  <span class="comment">// output输出的是Seq[Attribute]，也就是表的schema，包含所有列名，列类型等信息</span></span><br><span class="line">  <span class="comment">// child也就是缓存的dataset对应的plan</span></span><br><span class="line">  <span class="keyword">val</span> output = child.output</span><br><span class="line">  <span class="comment">// 调用逻辑执行计划的execute返回的是RDD[InternalRow],返回RDD是整个执行计划分析的最后一步了，接下来就rdd的提交运行。那么这个rdd也就是dataset表示的数据的rdd形式的抽象。</span></span><br><span class="line"> <span class="comment">// 这里在rdd上调用mapPartitionsInternal，实现的是将遍历每一行数据，然后按列缓存。</span></span><br><span class="line"> <span class="comment">// 这个地方返回新的RDD的数据类型CachedBatch，CachedBatch是一个batch内若干行上的按列缓存。</span></span><br><span class="line">  <span class="keyword">val</span> cached = child.execute().mapPartitionsInternal &#123; rowIterator =&gt;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">Iterator</span>[<span class="type">CachedBatch</span>] &#123;</span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">next</span></span>(): <span class="type">CachedBatch</span> = &#123;</span><br><span class="line">        <span class="comment">// 按照每一列的类型生成ColumnBuilder，内部使用数组来保存列数据</span></span><br><span class="line">        <span class="keyword">val</span> columnBuilders = output.map &#123; attribute =&gt;</span><br><span class="line">          <span class="type">ColumnBuilder</span>(attribute.dataType, batchSize, attribute.name, useCompression)</span><br><span class="line">        &#125;.toArray</span><br><span class="line"></span><br><span class="line">        <span class="keyword">var</span> rowCount = <span class="number">0</span></span><br><span class="line">        <span class="keyword">var</span> totalSize = <span class="number">0</span>L</span><br><span class="line">       <span class="comment">// 遍历每一行数据，控制当前batch行数 rowCount不超过batchSize，且同时batch中数据大小不超过MAX_BATCH_SIZE_IN_BYTE（4MB）</span></span><br><span class="line">        <span class="keyword">while</span> (rowIterator.hasNext &amp;&amp; rowCount &lt; batchSize</span><br><span class="line">          &amp;&amp; totalSize &lt; <span class="type">ColumnBuilder</span>.<span class="type">MAX_BATCH_SIZE_IN_BYTE</span>) &#123;</span><br><span class="line">          <span class="keyword">val</span> row = rowIterator.next()</span><br><span class="line"></span><br><span class="line">          assert(</span><br><span class="line">            row.numFields == columnBuilders.length,</span><br><span class="line">            <span class="string">s"Row column number mismatch, expected <span class="subst">$&#123;output.size&#125;</span> columns, "</span> +</span><br><span class="line">              <span class="string">s"but got <span class="subst">$&#123;row.numFields&#125;</span>."</span> +</span><br><span class="line">              <span class="string">s"\nRow content: <span class="subst">$row</span>"</span>)</span><br><span class="line"></span><br><span class="line">          <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">          totalSize = <span class="number">0</span></span><br><span class="line">          <span class="keyword">while</span> (i &lt; row.numFields) &#123;</span><br><span class="line">            columnBuilders(i).appendFrom(row, i)</span><br><span class="line">            totalSize += columnBuilders(i).columnStats.sizeInBytes</span><br><span class="line">            i += <span class="number">1</span></span><br><span class="line">          &#125;</span><br><span class="line">          rowCount += <span class="number">1</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        batchStats.add(totalSize)</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> stats = <span class="type">InternalRow</span>.fromSeq(columnBuilders.map(_.columnStats.collectedStatistics)</span><br><span class="line">          .flatMap(_.values))</span><br><span class="line">        <span class="type">CachedBatch</span>(rowCount, columnBuilders.map &#123; builder =&gt;</span><br><span class="line">          <span class="type">JavaUtils</span>.bufferToArray(builder.build())</span><br><span class="line">        &#125;, stats)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">def</span> <span class="title">hasNext</span></span>: <span class="type">Boolean</span> = rowIterator.hasNext</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 调用persist缓存RDD，所以cacheTable最终还是调用rdd的缓存接口完成缓存的</span></span><br><span class="line">  &#125;.persist(storageLevel)</span><br><span class="line"></span><br><span class="line">  cached.setName(</span><br><span class="line">    tableName.map(n =&gt; <span class="string">s"In-memory table <span class="subst">$n</span>"</span>)</span><br><span class="line">      .getOrElse(<span class="type">StringUtils</span>.abbreviate(child.toString, <span class="number">1024</span>)))</span><br><span class="line"></span><br><span class="line">  _cachedColumnBuffers = cached</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码可以看出cacheTable实际上还是通过cache rdd实现的。上面InMemoryRelation只是逻辑执行计划中一个节点，逻辑执行计划需要转换成物理执行计划，再转换成RDD dag才能执行，加上spark中RDD的计算是lazy模式的，所以上面的缓存rdd并没有提交运行，所以数据还没有缓存下来。</p>
<p>真正缓存还得看InMemoryRelation所在的执行计划真正提交后，这个缓存rdd被计算，数据才会被缓存在内存中。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/11/JUC之AbstractQueuedSynchronizer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Li Weisheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/11/JUC之AbstractQueuedSynchronizer/" itemprop="url">JUC之AbstractQueuedSynchronizer</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-11T21:06:14+08:00">
                2017-11-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>AbstractQueuedSynchronizer(AQS)基于FIFO等待队列以及CAS操作实现了基础了同步框架，JUC中包括ReentrantLock，ReentrantReadWriteLock，CountDownLatch，Condition都是基于AbstractQueuedSynchronizer提供的基础同步操作来实现的。</p>
<h1 id="2-AbstractQueuedSynchronizer实现原理"><a href="#2-AbstractQueuedSynchronizer实现原理" class="headerlink" title="2. AbstractQueuedSynchronizer实现原理"></a>2. AbstractQueuedSynchronizer实现原理</h1><h2 id="2-1-CLH队列"><a href="#2-1-CLH队列" class="headerlink" title="2. 1 CLH队列"></a>2. 1 CLH队列</h2><p>CLH（代表Craig, Landin, Hagersten三人）队列是一个FIFO的队列，这个队列用来对资源竞争者（不同的线程就是一个竞争者）进行排队。</p>
<h3 id="2-1-1-队列节点Node"><a href="#2-1-1-队列节点Node" class="headerlink" title="2.1.1 队列节点Node"></a>2.1.1 队列节点Node</h3><p>AQS实现中队列中一个节点即一个竞争者，用类Node，Node类有如下主要成员：</p>
<table>
<thead>
<tr>
<th>成员</th>
<th>含义</th>
<th>取值</th>
</tr>
</thead>
<tbody>
<tr>
<td>int waitStatus</td>
<td>当前节点状态</td>
<td>SIGNAL=-1 表示当前节点释放资源后需要唤醒他的后继阻塞中的节点，CANCELLED=1当前节点已经取消对资源的竞争，PROPAGATE=-3 用于竞争共享资源竞争，表示当前节点获取资源后，应该唤醒其他排队阻塞中获取该共享资源的竞争者，CONDITION=-2专门用于Condition的实现</td>
</tr>
<tr>
<td>Node prev,next</td>
<td>当前节点的前驱和后继节点</td>
<td>–</td>
</tr>
<tr>
<td>Thread thread</td>
<td>当前排队的线程，也就是竞争资源的线程</td>
<td>–</td>
</tr>
<tr>
<td>Node nextWaiter</td>
<td></td>
<td>当前节点是waitStatus是CONDITION是连接到下一个等待在同一个condition上的node，也可以是NODE的静态成员SHARED表示当前节点竞争共享资源，null表示竞争排他性资源</td>
</tr>
</tbody>
</table>
<p><strong>1. 节点种类</strong><br>根据上表中nextWaiter可以看出，实际上node的种类有三种：</p>
<ol>
<li>exclusive node（表示当前节点申请排他新资源）</li>
<li>shared node（表示当前节点申请的是共享资源）</li>
<li>condition， 当前节点等待条件变量</li>
</ol>
<p>不同的node种类获取资源（对应入队操作）和释放资源（对应出队操作）都有所不同</p>
<h3 id="2-2-2-入队操作"><a href="#2-2-2-入队操作" class="headerlink" title="2.2.2 入队操作"></a>2.2.2 入队操作</h3><p>也就是去竞争资源。<br>这里只介绍一下exclusive和shared node的入队操作</p>
<h4 id="2-2-2-1-exclusive-node入队操作"><a href="#2-2-2-1-exclusive-node入队操作" class="headerlink" title="2.2.2.1 exclusive node入队操作"></a>2.2.2.1 exclusive node入队操作</h4><p>使用AQS竞争排他性资源时，需要调用如下两个接口之一：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*acquire获取资源失败（也就是队列中有更早进入排队的node），</span></span><br><span class="line"><span class="comment">那么当前竞争者加入队列尾部并且阻塞等待，且等待期间不会里线程中断操作*/</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">和acquire不同的是竞争者等待期间是可以被中断</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            doAcquireInterruptibly(arg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>两者都调用了tryAcquire(), 这个方法需要使用AQS是用户继承并实现它，并且这个调用不应该阻塞，之所以提供tryAcquire操作是因为当前竞争者可能已经获取了资源，那么在tryAcquire可以做一下判断，避免已经获取了资源后还去盲目的进去CLH队列排队。<br>典型的就是重进入锁ReentrantLock的实现，获取锁的线程可以再次获取锁，那么就可以在tryAcquire中做一下判断。</p>
<p>关于参数arg，可以理解成获取资源数量吧，实际上这个跟AQS的一个重要的成员state有关，当用户使用AQS时，需要设置state这个整数值，关于这个state，应该可以当成是对资源状态的描述吧。比如ReenctrantLock中可以根据state是否等于0判断是否加锁了，以及state的值大小判断重进入锁重进入了几次。</p>
<p><strong>2. acquireQueued()</strong><br>关于addWaiter()其实就是不停的使用CAS操作将当前节点加入CLH队列尾部。<br>下面是acquireQueued的代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 线程中断标记</span></span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">// 当前节点的前驱</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">// 如果前驱节点已经是队列头，那就以为者看起来没有竞争了，然后就调用tryAcquire尝试获取资源。</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 否则开始排队，阻塞。</span></span><br><span class="line">                <span class="comment">// shouldParkAfterFailedAcquire会将前驱节点的waitStatus标记成SIGNAL表示告诉前驱节点：你释放资源后需要唤醒我，我可能阻塞了</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="comment">// 如果排队过程中被中断，记下来，不甩异常</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>以上可以看出acquireQueued其实就是在不停的做如下尝试：</p>
<ol>
<li>判断当前节点是不是最前面了，是则尝试获取资源，获取成功就返回，获取失败或者不是最前面节点则阻塞等待，然后</li>
<li>无限等待然后被唤醒，继续1.</li>
</ol>
<p><strong>2. doAcquireInterruptibly()</strong><br>和acquireQueued的过程是一样的，就是等待的过程中被中断了立即甩异常</p>
<h4 id="2-2-2-2-shared-node入队操作"><a href="#2-2-2-2-shared-node入队操作" class="headerlink" title="2.2.2.2 shared node入队操作"></a>2.2.2.2 shared node入队操作</h4><p>和exelusive模式一样都有可中断和不可中断两个，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">long</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">long</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>tryAcquireShared()需要使用AQS使用者继承实现，不过和tryAcquire不一样的是它返回一个整数，小于0表示尝试失败了。</p>
<p><strong>1. acquireShared</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                       <span class="comment">// 和exclusive模式下acquireQueued整体流程是一样的，</span></span><br><span class="line">                       <span class="comment">// 不同的是在这里，成功获取到竞争资源后，调用的这个方法。</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>关于上面setHeadAndPropagate做了什么，先通过下图描述一下为什么会有这个方法的调用吧.</p>
<p>假设现在排队队列如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">-----     ------    -----     -----</span><br><span class="line">| E1 |  -&gt;| S1 | -&gt; | S2 | -&gt;| S3 |</span><br><span class="line">-----     ------    -----     ----</span><br></pre></td></tr></table></figure></p>
<p>节点E1是头节点，exclusively持有资源， S1,  S2, S3都是在申请共享访问资源，然后因为E1已经持有了，所以都阻塞了。</p>
<p>然后E1释放资源了，所以他会唤醒阻塞中的S1，S1拿到了资源，但是由于S1是共享模式去拿资源，S2，S3也都是去申请共享资源，所以S1应该去同样唤醒S2，S3一起去分享资源。 这也就是<code>setHeadAndPropagate</code>干的事情–唤醒S2, S2醒了唤醒S3。</p>
<h3 id="2-2-3-出队操作"><a href="#2-2-3-出队操作" class="headerlink" title="2.2.3 出队操作"></a>2.2.3 出队操作</h3><p>也就是释放资源.</p>
<h4 id="2-2-3-1-exclusive-node释放资源"><a href="#2-2-3-1-exclusive-node释放资源" class="headerlink" title="2.2.3.1 exclusive node释放资源"></a>2.2.3.1 exclusive node释放资源</h4><p>释放资源通过如下方法实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>tryRelease和tryAcquire一样，是需要继承并实现的，返回true表示资源完全被释放(也就是需要唤醒后面等待的node)，tryRelease同样需要结合资源状态state去判断，且应该是一个非阻塞的调用。</p>
<p>下面unparkSuccessor唤醒后继等待者的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">       </span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">// 后继节点==null并不能代表没有后继节点，原因跟入队addWaiter的实现有关.</span></span><br><span class="line">        <span class="comment">// 入队newNode时先用CAS将tail设置成newNode，然后再将之前的tail.next设置成newNode，</span></span><br><span class="line">        <span class="comment">// 所以这中间的时间间隔中有tail但是之前的tail还没有完成和newNode连接，也就是之前的tail的后继是null</span></span><br><span class="line">        <span class="comment">// 而s.waitStatus &gt;0 则这个值为CACELLED，应该再找它后面的节点</span></span><br><span class="line">        <span class="comment">// 所以最好的方式就是从tail往前遍历找到最前面的没有CANCELLED的节点，然后唤醒它。</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">// 唤醒这个后继节点的线程。</span></span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-2-3-2-shared-node释放资源"><a href="#2-2-3-2-shared-node释放资源" class="headerlink" title="2.2.3.2 shared node释放资源"></a>2.2.3.2 shared node释放资源</h4><p>调用如下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>tryReleaseShared需要使用AQS的继承并实现它，返回true表示成功释放，意味着需要唤醒后续等待者。</p>
<p>关于doReleaseShared就是唤醒后继节点，没什么好讲述的～～～</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/11/07/Logback-SiftingAppender/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Li Weisheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/11/07/Logback-SiftingAppender/" itemprop="url">Logback - SiftingAppender</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-11-07T21:08:26+08:00">
                2017-11-07
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-作用"><a href="#1-作用" class="headerlink" title="1. 作用"></a>1. 作用</h2><p>Logback将写日志事件的任务委托给appender组件完成，SiftingAppender顾名思义就是筛选日志事件，具体点就是：</p>
<blockquote>
<p>对于Logback委托给它的日志事件，SiftingAppender会对日志事件做一些区分，然后不同的事件SiftingAppender会委托不同的appender去完成真正的写操作。</p>
</blockquote>
<p>设想一下这样一个场景：<br>有一个Task类完成成一些特定的任务，每一个Task实例都有一个编号，运行时期会不停的输出任务状态的日志，下面这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyTask</span></span>&#123;</span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Logger LOG = LoggerFactory.getLogger(MyTask.class);</span><br><span class="line">   <span class="keyword">private</span> String taskId;</span><br><span class="line">   ...</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">       LOG.info(<span class="string">"preProcess taskId=&#123;&#125;"</span>, taskId);</span><br><span class="line">       preProcess();</span><br><span class="line">       LOG.info(<span class="string">"process taskId=&#123;&#125;"</span>, taskId);</span><br><span class="line">       process();</span><br><span class="line">       LOG.info(<span class="string">"postProcess taskId=&#123;&#125;"</span>, taskId);</span><br><span class="line">       postProcess();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在我们需要查看任务日志时，如果使用<code>RollingFileAppender</code>， 不同taskid的任务日志都会输出到同一个文件中，那就需要打开日志文件，根据taskid查找。有时需要web application提供根据taskId查询任务日志的功能在这种情况下比较难以实现。</p>
<p>显然如果一个taskId生成一个日志文件就好了，等到task结束时关闭这个日志文件就行了，那以后根据taskId查询task日志时直接到指定路径下寻找文件就taskId的文件就行了。</p>
<p>SiftingAppender就能够实现这样的功能，他能根据一定的规则鉴别日志事件，然后委托给不同的appender完成真正的日志输出任务。</p>
<h2 id="2-使用SiftingAppender"><a href="#2-使用SiftingAppender" class="headerlink" title="2. 使用SiftingAppender"></a>2. 使用SiftingAppender</h2><p>logback中配置如下：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span> <span class="attr">debug</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"SIFT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.sift.SiftingAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--discriminator鉴别器，根据taskId这个key对应的value鉴别日志事件，然后委托给具体appender写日志--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">discriminator</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>taskId<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">defaultValue</span>&gt;</span>default<span class="tag">&lt;/<span class="name">defaultValue</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sift</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--具体的写日志appender，每一个taskId创建一个文件--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"File-$&#123;taskId&#125;"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.core.FileAppender"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">file</span>&gt;</span>/Users/eric/logbacktest/$&#123;taskId&#125;<span class="tag">&lt;/<span class="name">file</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">append</span>&gt;</span>true<span class="tag">&lt;/<span class="name">append</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">encoder</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">pattern</span>&gt;</span>[%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125;] %-5level %logger&#123;35&#125; - %msg%n<span class="tag">&lt;/<span class="name">pattern</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">encoder</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sift</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">logger</span> <span class="attr">name</span>=<span class="string">"test.logback"</span> <span class="attr">level</span>=<span class="string">"INFO"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">appender-ref</span> <span class="attr">ref</span>=<span class="string">"SIFT"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">logger</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>代码中使用日志：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> test.logback;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.slf4j.Logger;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.LoggerFactory;</span><br><span class="line"><span class="keyword">import</span> org.slf4j.MDC;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Logger LOG = LoggerFactory.getLogger(MyTask.class);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String taskId;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(String taskId)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.taskId = taskId;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">/* 上面logback.xml中discriminator根据taskId这个key的value来决定，taskId的value通过这种方式设置，</span></span><br><span class="line"><span class="comment">             这里设置的key-value对是保存在一个ThreadLocal&lt;Map&gt;中的，所以不会对其他线程中的taskId这个key产生影响</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">            MDC.put(<span class="string">"taskId"</span>, taskId);</span><br><span class="line">            <span class="keyword">for</span>(;;)&#123;</span><br><span class="line">                <span class="comment">// 写日志，使用SiftingAppender，由于当前调用线程taskId的value是对应this.taskId(假设是task-0), 所以会输出到File-task-0这个文件中</span></span><br><span class="line">                LOG.info(<span class="string">"taskId=&#123;&#125;, threadNo=&#123;&#125;"</span>, taskId, Thread.currentThread());</span><br><span class="line">                Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">        &#125; <span class="keyword">finally</span>&#123;</span><br><span class="line">            MDC.remove(taskId);</span><br><span class="line">       &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------下面是测试类</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SiftingAppenderTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService taskExecutors = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="comment">// 运行10个task，启动了10个线程</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++ i)&#123;</span><br><span class="line">            taskExecutors.submit(<span class="keyword">new</span> MyTask(<span class="string">"task-"</span> + i));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        taskExecutors.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行后产生了10个日志文件如下：<br><img src="/image/log/logback-sift.png" alt="日志文件.png"></p>
<h3 id="2-1-关于discriminator"><a href="#2-1-关于discriminator" class="headerlink" title="2.1 关于discriminator"></a>2.1 关于discriminator</h3><p>前面配置SiftingAppender使用如下方式配置discriminator：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"SIFT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.sift.SiftingAppender"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--discriminator鉴别器，根据taskId这个key对应的value鉴别日志事件，然后委托给具体appender写日志--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">discriminator</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>taskId<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">defaultValue</span>&gt;</span>default<span class="tag">&lt;/<span class="name">defaultValue</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sift</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">sift</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>实际上它是等同于下面这种方式的默认写法：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">appender</span> <span class="attr">name</span>=<span class="string">"SIFT"</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.sift.SiftingAppender"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">class</span>=<span class="string">"ch.qos.logback.classic.sift.MDCBasedDiscriminator"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">key</span>&gt;</span>taskId<span class="tag">&lt;/<span class="name">key</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">defaultValue</span>&gt;</span>default<span class="tag">&lt;/<span class="name">defaultValue</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sift</span>&gt;</span></span><br><span class="line">            ...</span><br><span class="line">        <span class="tag">&lt;/<span class="name">sift</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">appender</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>discriminator不指定具体class时，默认使用<code>MDCBasedDiscriminator</code>,这就是我们能在前面的java代码中使用<code>MDC.put(&quot;taskId&quot;, taskId);</code>来指定taskId值的原因，因为<code>MDCBasedDiscriminator</code>会使用<key></key>中配置的key去到MDC中取当前线程的value，然后选择(没有就创建)appender写日志。</p>
<p><strong>Discriminator接口</strong><br>discriminator都是从该接口实现的，接口方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Discriminator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">LifeCycle</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 这里范型E一般是日志事件，在logback-classic 中应该是ILoggingEvent，</span></span><br><span class="line">    <span class="comment">// 在logback-access 中是AccessLogEvent</span></span><br><span class="line">    <span class="function">String <span class="title">getDiscriminatingValue</span><span class="params">(E var1)</span></span>;</span><br><span class="line">    <span class="function">String <span class="title">getKey</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是MDCBasedDiscriminator的实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MDCBasedDiscriminator</span> <span class="keyword">extends</span> <span class="title">AbstractDiscriminator</span>&lt;<span class="title">ILoggingEvent</span>&gt; </span>&#123;</span><br><span class="line">   <span class="comment">// 之前的java实例代码中通过&lt;key&gt;taskId&lt;/key&gt;设置这里的key是“taskId”</span></span><br><span class="line">    <span class="keyword">private</span> String key;</span><br><span class="line">    <span class="keyword">private</span> String defaultValue;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MDCBasedDiscriminator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// event即日志事件，这个方法的返回值决定了此日志event后面会有那一个appender处理</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDiscriminatingValue</span><span class="params">(ILoggingEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 前面说过MDC.put会保存到一个ThreadLocal&lt;Map&gt;中去，这里拿到这个map</span></span><br><span class="line">        Map mdcMap = event.getMDCPropertyMap();</span><br><span class="line">        <span class="keyword">if</span>(mdcMap == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.defaultValue;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 这里拿到当前线程通过MDC.put设置的key的value值</span></span><br><span class="line">            String mdcValue = (String)mdcMap.get(<span class="keyword">this</span>.key);</span><br><span class="line">            <span class="keyword">return</span> mdcValue == <span class="keyword">null</span>?<span class="keyword">this</span>.defaultValue:mdcValue;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> errors = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(OptionHelper.isEmpty(<span class="keyword">this</span>.key)) &#123;</span><br><span class="line">            ++errors;</span><br><span class="line">            <span class="keyword">this</span>.addError(<span class="string">"The \"Key\" property must be set"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(OptionHelper.isEmpty(<span class="keyword">this</span>.defaultValue)) &#123;</span><br><span class="line">            ++errors;</span><br><span class="line">            <span class="keyword">this</span>.addError(<span class="string">"The \"DefaultValue\" property must be set"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(errors == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.started = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setKey</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDefaultValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.defaultValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDefaultValue</span><span class="params">(String defaultValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.defaultValue = defaultValue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>本文参考</strong></p>
<ol>
<li><a href="https://logback.qos.ch/manual/appenders.html" target="_blank" rel="noopener">Logback Appenders</a></li>
<li><a href="https://logback.qos.ch/manual/mdc.html" target="_blank" rel="noopener">Logback MDC</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/26/Spark-Streaming-4-反压/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Li Weisheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/26/Spark-Streaming-4-反压/" itemprop="url">Spark Streaming(4) - 反压</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-26T21:12:12+08:00">
                2017-10-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>Spark Streaming在处理不断流入的数据时通过每间隔一段时间(batch interval)将这段时间内的流入的数据积累为一个batch，然后以这个batch内的数据作为job DAG的输入rdd提交新的job运行。当一个batch的的处理时间大于batch interval时，意味着数据处理速度跟不上数据接收速度，此时在数据接收端（即Receiver一般数据接收端都运行在executor上）就会积累数据，而数据是通过BlockManager管理的，如果数据存储采取MEMORY_ONLY模式就会导致OOM，采取MEMORY_AND_DISK多余的数据保存到磁盘上反而会增加数据读取时间。</p>
<p>说到这里，反压实际就是一种根据当前系统的处理能力来动态调节接收数据速率的功能。</p>
<h2 id="2-反压"><a href="#2-反压" class="headerlink" title="2. 反压"></a>2. 反压</h2><p>前言中提到数据接收端Receiver，可以参考文章<a href="http://www.jianshu.com/p/323e8f7d84d10" target="_blank" rel="noopener">Spark stream receiver</a>,简单说就是stream job运行期间会有一个或者多个Receiver运行在Executor上专门接收数据，并以batch interval为时间间隔将流式数据分割为一个个batch,然后以一个batch的数据启动job。但是stream job中Receiver并不是必然存在的，例外的情况是当数据源是kafka时，spark内置了一种叫<code>DirectKafkaInputDStream</code>的输入源（可以通过<code>KafkaUtils.createDirectStream(...)</code>创建），这种类型的InputDStream(输入源会实现这个类)没有Receiver。对于那些带Receiver的InputDStream实现类，当从InputDStream创建RDD时，源头RDD中的数据就是Receiver接收的数据，而从<code>DirectKafkaInputDStream</code>创建RDD时，数据实际上还没有从kafka读取过来，这个时候的RDD只包含了kafka的topic以及offset信息，等到rdd对应的task运行时才从kafka中获取数据。</p>
<p>由于存在有Receiver和没有两种情况，实际上反压的实现也不一样。有Receiver时控制Receiver接收数据的速率就可以了，没有Receiver的<code>DirectKafkaInputDStream</code>时的实现会在后文单独提一下。<br><strong>附</strong><br>关于spark stream的原理可以参考：</p>
<ol>
<li><a href="http://www.jianshu.com/p/b3b7cc54b352" target="_blank" rel="noopener">Spark Streaming(1) - 基本原理</a></li>
<li><a href="http://www.jianshu.com/p/8a28a711400a" target="_blank" rel="noopener">Spark Streaming(2) - JobScheduler、JobGenerator</a></li>
<li><a href="http://www.jianshu.com/p/323e8f7d84d1" target="_blank" rel="noopener">Spark Streaming(3) - Receiver和ReceiverTacker</a><h3 id="2-1-开启反压"><a href="#2-1-开启反压" class="headerlink" title="2.1 开启反压"></a>2.1 开启反压</h3>指定配置<code>spark.streaming.backpressure.enabled</code>为true即可开启反压。<h3 id="2-2-有Receiver时反压原理"><a href="#2-2-有Receiver时反压原理" class="headerlink" title="2.2 有Receiver时反压原理"></a>2.2 有Receiver时反压原理</h3>反压的原理是根据之前系统的处理能力来调节未来系统接收数据速率，它的过程是下面这样的：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">stream (stream id标志)里所有job完成后</span><br><span class="line">-&gt; 反馈运行信息(包括，开始结束时间、处理本次处理记录数等信息) 给JobScheduler</span><br><span class="line">   -&gt; JobScheduler将信息交给RateController(通过一个job成功事件，下文会说到) ，RateController根据反馈信息计算接下来应该控制住Receiver接收多少条数据 </span><br><span class="line">      -&gt; RateController委托JobScheduler的receiverTracker将的计算结果通知给所有在Executor上运行的Receiver </span><br><span class="line">          -&gt; Receiever控制接收数据速率</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>上面过程中JobScheduler处在核心的位置，由它来负责协调，接下来分别讲述RateController，以及Recceiver是如何控制速率的。</p>
<h4 id="2-2-1-RateController"><a href="#2-2-1-RateController" class="headerlink" title="2.2.1 RateController"></a>2.2.1 RateController</h4><p>RateController实现了<code>StreamingListener</code>, 它作为JobScheduler的lister，监听这个stream job的提交，开始运行，以及完成。其实它只关心<code>StreamingListenerBatchCompleted</code>事件的发生(该事件表示任务成功执行)，这个事件包含了如下信息：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">BatchInfo</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    batchTime: <span class="type">Time</span>,   </span></span></span><br><span class="line"><span class="class"><span class="params">    streamIdToInputInfo: <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">StreamInputInfo</span>],</span></span></span><br><span class="line"><span class="class"><span class="params">    submissionTime: <span class="type">Long</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    processingStartTime: <span class="type">Option</span>[<span class="type">Long</span>],</span></span></span><br><span class="line"><span class="class"><span class="params">    processingEndTime: <span class="type">Option</span>[<span class="type">Long</span>],</span></span></span><br><span class="line"><span class="class"><span class="params">    outputOperationInfos: <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">OutputOperationInfo</span>]</span></span></span><br><span class="line"><span class="class"><span class="params">  </span>)</span></span><br></pre></td></tr></table></figure></p>
<ol>
<li>RateController从何而来？<br>RateContoller 是InputDStream的成员，并在子类<code>ReceiverInputDStream</code>中初始化了具体的实例，如下：<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ReceiverInputDStream</span> </span>&#123;</span><br><span class="line"><span class="keyword">override</span> <span class="keyword">protected</span>[streaming] <span class="keyword">val</span> rateController: <span class="type">Option</span>[<span class="type">RateController</span>] = &#123;</span><br><span class="line">    <span class="comment">// 开启反压的情况下创建了了ReceiverRateController</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="type">RateController</span>.isBackPressureEnabled(ssc.conf)) &#123;</span><br><span class="line">      <span class="type">Some</span>(<span class="keyword">new</span> <span class="type">ReceiverRateController</span>(id, <span class="type">RateEstimator</span>.create(ssc.conf, ssc.graph.batchDuration)))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">None</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>本节中接下来关注<code>ReceiverRateController</code>的实现。</p>
<ol>
<li>RateController工作原理<br>上面说到RateController实现了<code>StreamingListener</code>，并且只关注<code>StreamingListenerBatchCompleted</code>，该事件发生时，会调用RateController # onBatchCompleted方法，方法体如下：<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onBatchCompleted</span></span>(batchCompleted: <span class="type">StreamingListenerBatchCompleted</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> elements = batchCompleted.batchInfo.streamIdToInputInfo</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">      processingEnd &lt;- batchCompleted.batchInfo.processingEndTime</span><br><span class="line">      workDelay &lt;- batchCompleted.batchInfo.processingDelay</span><br><span class="line">      waitDelay &lt;- batchCompleted.batchInfo.schedulingDelay</span><br><span class="line">      elems &lt;- elements.get(streamUID).map(_.numRecords)</span><br><span class="line">    &#125; computeAndPublish(processingEnd, elems, workDelay, waitDelay)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">上面方法拿到stream job结束时间processingEnd， job真实运行时间workDelay， job从提交到结束时间waitDelay， 本次job处理记录数elems，</span><br><span class="line">然后调用computeAndPublish计算，computeAndPublish方法如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">computeAndPublish</span></span>(time: <span class="type">Long</span>, elems: <span class="type">Long</span>, workDelay: <span class="type">Long</span>, waitDelay: <span class="type">Long</span>): <span class="type">Unit</span> =</span><br><span class="line">    <span class="type">Future</span>[<span class="type">Unit</span>] &#123;</span><br><span class="line">     <span class="comment">// 使用rateEstimator来计算接下来的接收速率，</span></span><br><span class="line">      <span class="keyword">val</span> newRate = rateEstimator.compute(time, elems, workDelay, waitDelay)</span><br><span class="line">      newRate.foreach &#123; s =&gt;</span><br><span class="line">        rateLimit.set(s.toLong)</span><br><span class="line">        <span class="comment">// publish是一个抽象方法，也就是将计算出来的速率通知出处</span></span><br><span class="line">        publish(getLatestRate())</span><br><span class="line">      &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>下面是<code>ReceiverRateController</code>的publish的实现:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">publish</span></span>(rate: <span class="type">Long</span>): <span class="type">Unit</span> =</span><br><span class="line">     <span class="comment">// 通过JobScheduler的receiverTracker将计算出来的速率通知给所有的Receiver</span></span><br><span class="line">      ssc.scheduler.receiverTracker.sendRateUpdate(id, rate)</span><br></pre></td></tr></table></figure></p>
<p><strong>附：ReceiverTracker</strong><br>这里顺带提一下ReceiverTracker中涉及的反压过程的成员或方法吧:<br>(这里涉及到spark rpc，可以参考<a href="http://www.jianshu.com/p/7da49e332e70" target="_blank" rel="noopener">spark rpc</a>)<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ReceiverTracker</span></span>&#123;</span><br><span class="line">   <span class="comment">// 这个rpc一端是运行在JobScheduler上的，负责接收Receiver传过来的消息，</span></span><br><span class="line">  <span class="comment">// 它是类ReceiverTrackerEndpoint(ReceiverTracker的内部类)的实例</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">var</span> endpoint: <span class="type">RpcEndpointRef</span> = <span class="literal">null</span></span><br><span class="line">   <span class="comment">// stream id到Receiver的信息，其中就包含了receiver的rpc通信信息</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">val</span> receiverTrackingInfos = <span class="keyword">new</span> <span class="type">HashMap</span>[<span class="type">Int</span>, <span class="type">ReceiverTrackingInfo</span>]</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 上面ReceiverRateController # push就是调用这个方法去通知receiver新的速率的</span></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">sendRateUpdate</span></span>(streamUID: <span class="type">Int</span>, newRate: <span class="type">Long</span>): <span class="type">Unit</span> = synchronized &#123;</span><br><span class="line">    <span class="keyword">if</span> (isTrackerStarted) &#123;</span><br><span class="line">      <span class="comment">// 这个enpoint是运行在JobScheduler上的，也就是给自己发了一个UpdateReceiverRateLimit更新速率的事件</span></span><br><span class="line">      endpoint.send(<span class="type">UpdateReceiverRateLimit</span>(streamUID, newRate))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">下面是<span class="type">ReceiverTrackerEndpoint</span>接收到<span class="type">UpdateReceiverRateLimit</span>消息时的处理：</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>&#123;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">case</span> <span class="type">UpdateReceiverRateLimit</span>(streamUID, newRate) =&gt;</span><br><span class="line">        <span class="comment">//  拿到receiver的rpc信息eP， 然后发送UpdateRateLimit(newRate)更新速率</span></span><br><span class="line">        <span class="keyword">for</span> (info &lt;- receiverTrackingInfos.get(streamUID); eP &lt;- info.endpoint) &#123;</span><br><span class="line">          eP.send(<span class="type">UpdateRateLimit</span>(newRate))</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>RateController更新速率以及通知新接收速率过程就是这样，接下来是Receiver如何去根据新的速率newRate控制接收速率。</p>
<h4 id="2-2-2-Receiver控制速率"><a href="#2-2-2-Receiver控制速率" class="headerlink" title="2.2.2 Receiver控制速率"></a>2.2.2 Receiver控制速率</h4><p>Receiver上运行了很多组件：</p>
<ul>
<li>Receiver负责接收数据</li>
<li>接收的数据上报给ReceiverSupervisorImpl</li>
<li>如果接受的数据是一条条上报（调用方法ReceiverSupervisorImpl # putSingle）， 则ReceiverSupervisorImpl 使用BlockGenerator用来将一条条的记录汇聚成block(如果Receiver一次接收并上报一批数据就不会使用BlockGenerator)</li>
</ul>
<p>上面BlockGenerator将一条条数据汇聚成block， Receiver上控制接受速率就是通过BlockGenerator处理速度来实现的，BlockGenerator阻塞了也就相当于间接阻塞了Receiver接受速率。</p>
<p>但是上面说只有一条条接受的数据会走BlockGenerator，如果Receiver不使用<br><code>ReceiverSupervisorImpl # putSingle</code>而是使用其他方法一次上报一批数据，其实反压是不起作用的。</p>
<ol>
<li><p>ReceiverSupervisorImpl接收UpdateRateLimit消息<br> 下面是ReceiverSupervisorImpl接受消息的rpc端处理代码:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> endpoint = env.rpcEnv.setupEndpoint(</span><br><span class="line">   <span class="string">"Receiver-"</span> + streamId + <span class="string">"-"</span> + <span class="type">System</span>.currentTimeMillis(), <span class="keyword">new</span> <span class="type">ThreadSafeRpcEndpoint</span> &#123;</span><br><span class="line">     <span class="keyword">override</span> <span class="keyword">val</span> rpcEnv: <span class="type">RpcEnv</span> = env.rpcEnv</span><br><span class="line"></span><br><span class="line">     <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Unit</span>] = &#123;</span><br><span class="line">       <span class="keyword">case</span> <span class="type">StopReceiver</span> =&gt;</span><br><span class="line">         logInfo(<span class="string">"Received stop signal"</span>)</span><br><span class="line">         <span class="type">ReceiverSupervisorImpl</span>.<span class="keyword">this</span>.stop(<span class="string">"Stopped by driver"</span>, <span class="type">None</span>)</span><br><span class="line">       <span class="keyword">case</span> <span class="type">CleanupOldBlocks</span>(threshTime) =&gt;</span><br><span class="line">         logDebug(<span class="string">"Received delete old batch signal"</span>)</span><br><span class="line">         cleanupOldBlocks(threshTime)</span><br><span class="line">       <span class="keyword">case</span> <span class="type">UpdateRateLimit</span>(eps) =&gt;</span><br><span class="line">         logInfo(<span class="string">s"Received a new rate limit: <span class="subst">$eps</span>."</span>)</span><br><span class="line">        <span class="comment">// 通知所有的BlockGenerator去更新速率</span></span><br><span class="line">         registeredBlockGenerators.asScala.foreach &#123; bg =&gt;</span><br><span class="line">           bg.updateRate(eps)</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;)</span><br></pre></td></tr></table></figure>
</li>
<li><p>BlockGenerator控制速率<br>BlockGenerator采用令牌桶算法实现速率控制,原理简介如下:</p>
<blockquote>
<p>假设想把接收速率控制在m条记录每秒， 那么生产者只需要以恒定的速度每秒向桶中放m个令牌，数据接收者接收数据之前需要从桶中拿走一个令牌才能接收一条数据，显然数据接收速率不会超过m</p>
</blockquote>
<p>来看看BlockGenerator是怎么实现的，BlockGenerator实现了RateLimiter抽象类，下面是RateLimiter的部分实现:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 最大接收速率,接收数据速率由maxRateLimit和动态更新的反压速率共同控制</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> maxRateLimit = conf.getLong(<span class="string">"spark.streaming.receiver.maxRate"</span>, <span class="type">Long</span>.<span class="type">MaxValue</span>)</span><br><span class="line">  <span class="comment">// rateLimiter负责产生令牌</span></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> rateLimiter = <span class="type">GuavaRateLimiter</span>.create(getInitialRateLimit().toDouble)</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// BlockGenerator在存储数据之前会调用这个方法，相当于取令牌。</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">waitToPush</span></span>() &#123;</span><br><span class="line">    rateLimiter.acquire()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 更新速率，也就是令牌产生的速率</span></span><br><span class="line">  <span class="keyword">private</span>[receiver] <span class="function"><span class="keyword">def</span> <span class="title">updateRate</span></span>(newRate: <span class="type">Long</span>): <span class="type">Unit</span> =</span><br><span class="line">    <span class="keyword">if</span> (newRate &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (maxRateLimit &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        rateLimiter.setRate(newRate.min(maxRateLimit))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        rateLimiter.setRate(newRate)</span><br><span class="line">      &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>BlockGenerator的父类RateLimiter实现了令牌桶速率控制算法，接下来就是BlockGenerator在接收Receiver传递过来的数据时调用<code>waitToPush</code>去获取令牌了，没有令牌是，BlockGenerator阻塞，那么Receiver也会阻塞下去。</p>
<h3 id="2-3-DirectKafkaInputDStream时的反压实现"><a href="#2-3-DirectKafkaInputDStream时的反压实现" class="headerlink" title="2.3 DirectKafkaInputDStream时的反压实现"></a>2.3 DirectKafkaInputDStream时的反压实现</h3><p>DirectKafkaInputDStream是没有Receiver的。</p>
<ul>
<li><p>有Receiver的stream job， 数据从由Receiver接收，然后组装成block然后汇报到JobScheduler，stream job提交运行前从JobScheduler拿一个block运行。</p>
</li>
<li><p>但是对于DirectKafkaInputDStream而言，不存在独立运行的Receiver接收数据，而是在从DirectKafkaInputDStream创建出<code>KafkaRDD</code>然后提交stream job运行时，在<code>KafkaRDD</code>的compute方法中才开始从kafka读取数据。此时由于接收数据是在job开始运行后在task中进行的，因此反压实现也是通过控制本次task从kafka中读取多少数据来实现的。</p>
</li>
</ul>
<p><strong>1. 计算接收速率</strong><br>不贴代码了，<code>DirectKafkaInputDStream</code>使用IDRateEstimator去评估每秒接收的数据量R，同时由于<code>DirectKafkaInputDStream</code>可以同时从一个topic的n个分区接收数据，这个R是整个全部分区的数据接收速度，在<code>DirectKafkaInputDStream</code>中还有一个重要的参数<code>spark.streaming.kafka.maxRatePerPartition</code>（每秒）控制每个分区的最大接收速度(假设是maxR)。</p>
<p>评估出R之后，就是计算n个分区每个分区的速度了，这个不是简单的R/n分的，<br>而是根据之前每一个分区消费到的offset（假设是prefOffset）和现在每个分区的最新offset（假设是curOffset）的差值/ 总差值的比例计算出来的，</p>
<p>假设全部n个分区从上一batch消费之后到现在的整个未消费记录数是totalLag，<br>分区n1未消费数是lagN1， 那么本次batch从分区n1应该消费的记录数就是:</p>
<blockquote>
<p>（min( (lagN1 / totalLag) <em> R, maxR）） </em> batchDuration（换算成秒）</p>
</blockquote>
<p><strong>2. 控制速率</strong><br>「1」中计算出每个分区最大消费记录数m，接下来从<code>DirectKafkaInputDStream</code>生成<code>KafkaRDD</code>（KafkaRDD的分区个数也就是topic的分区个数）， 然后提交job运行后<code>KafkaRDD</code>的compute方法开始从kafka消费m条记录。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/25/Spring事件机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Li Weisheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/25/Spring事件机制/" itemprop="url">Spring事件机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-25T21:15:13+08:00">
                2017-10-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-使用Spring-事件"><a href="#1-使用Spring-事件" class="headerlink" title="1. 使用Spring 事件"></a>1. 使用Spring 事件</h2><p>首先spring事件分为事件发布者(EventPublisher)、事件监听者(EventListener),还包括一个事件广播者(这个是spring实现相关，这一节不讨论)。使用spring事件机制，需要自定义事件发布者和监听者。<br>以一个简单的例子开始，事件发布者发送一个string类型的消息，接受者将接收到的消息打印出来。</p>
<ol>
<li><p>事件发布者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SaySomethingPublisher</span> <span class="keyword">implements</span> <span class="title">ApplicationEventPublisherAware</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> ApplicationEventPublisher applicationEventPublisher;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setApplicationEventPublisher</span><span class="params">(ApplicationEventPublisher applicationEventPublisher)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.applicationEventPublisher = applicationEventPublisher;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saySomething</span><span class="params">(String msg)</span></span>&#123;</span><br><span class="line">        applicationEventPublisher.publishEvent(msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">需要实现ApplicationEventPublisherAware这个Aware接口，广播事件需要利用applicationEventPublisher</span><br></pre></td></tr></table></figure>
<p>关于ApplicationEventPublisherAware如下：</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ApplicationEventPublisher</span> </span>&#123;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(ApplicationEvent event)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">publishEvent</span><span class="params">(Object event)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">用户发布的事件类型可以是：</span><br><span class="line"><span class="number">1</span>. 用户可以继承ApplicationEvent从而自定义Event类型</span><br><span class="line"><span class="number">2</span>. 也可以使用任意Object类型，但是如果event真实类型不是ApplicationEvent的话，那么event会被封装成PayloadApplicationEvent</span><br></pre></td></tr></table></figure>
</li>
<li><p>事件监听者</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">//事件监听者需要实现ApplicationListener接口</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ListenerA</span> <span class="keyword">implements</span> <span class="title">ApplicationListener</span>&lt;<span class="title">PayloadApplicationEvent</span>&lt;<span class="title">String</span>&gt;&gt; </span>&#123;</span><br><span class="line">    <span class="comment">// 由于监听的是String类型的事件会被封装成PayloadApplicationEvent，所以此处类型是PayloadApplicationEvent</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onApplicationEvent</span><span class="params">(PayloadApplicationEvent event)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// getSource返回真实的事件</span></span><br><span class="line">        Object msg = event.getSource();</span><br><span class="line">        System.out.println(<span class="string">"ListenerA receive:"</span> + msg);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p><strong>关于发布出去的事件，那些监听者会监听到？</strong></p>
<ol>
<li>发布的事件类型是ApplicationEvent的实现类A<br> 那么所有监听者的<code>onApplicationEvent</code>的参数类型是A或者A的子类都会收到事件。</li>
<li>发布的事件类型是不是ApplicationEvent类型，类型是B<br>这种情况下，最终事件会被包装成<code>PayloadApplicationEvent&lt;B&gt;</code>, 那么所有监听者方法<code>onApplicationEvent</code>的参数是<code>PayloadApplicationEvent&lt;B&gt;</code>的监听者会收到， 假设有C是B的父类，且有一个监听者X监听<code>PayloadApplicationEvent&lt;C&gt;</code>,那X是收不到<code>PayloadApplicationEvent&lt;B&gt;</code>类型的事件的</li>
</ol>
<h2 id="2-Spring事件原理"><a href="#2-Spring事件原理" class="headerlink" title="2. Spring事件原理"></a>2. Spring事件原理</h2><p>Spring事件机制是观察者模式的一种实现，但是除了发布者和监听者者两个角色之外，还有一个EventMultiCaster的角色负责把事件转发给监听者，工作流程如下：</p>
<p><img src="/image/spring/spring-event.png" alt="Spring事件机制"></p>
<p>也就是说上面代码中发布者调用<code>applicationEventPublisher.publishEvent(msg);</code> 是会将事件发送给了EventMultiCaster， 而后由EventMultiCaster注册着所有的Listener，然后根据事件类型决定转发给那个Listener。</p>
<h3 id="2-1-EventMultiCaster"><a href="#2-1-EventMultiCaster" class="headerlink" title="2.1 EventMultiCaster"></a>2.1 EventMultiCaster</h3><p>ApplicationContext完成bean的装配和初始化后(非lazy-init的singleton bean会加载后就初始化)，会尝试创建一个eventMultiCaster，创建代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initApplicationEventMulticaster</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		ConfigurableListableBeanFactory beanFactory = getBeanFactory();</span><br><span class="line">        <span class="comment">//判断有没有一个name是“applicationEventMulticaster”且实现了“ ApplicationEventMulticaster”的bean，有的话那它就是eventMultiCaster</span></span><br><span class="line">		<span class="keyword">if</span> (beanFactory.containsLocalBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME)) &#123;</span><br><span class="line">			<span class="keyword">this</span>.applicationEventMulticaster =</span><br><span class="line">					beanFactory.getBean(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, ApplicationEventMulticaster.class);</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">"Using ApplicationEventMulticaster ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 没有这样一个bean，那就会创建一个默认的</span></span><br><span class="line">			<span class="keyword">this</span>.applicationEventMulticaster = <span class="keyword">new</span> SimpleApplicationEventMulticaster(beanFactory);</span><br><span class="line">			beanFactory.registerSingleton(APPLICATION_EVENT_MULTICASTER_BEAN_NAME, <span class="keyword">this</span>.applicationEventMulticaster);</span><br><span class="line">			<span class="keyword">if</span> (logger.isDebugEnabled()) &#123;</span><br><span class="line">				logger.debug(<span class="string">"Unable to locate ApplicationEventMulticaster with name '"</span> +</span><br><span class="line">						APPLICATION_EVENT_MULTICASTER_BEAN_NAME +</span><br><span class="line">						<span class="string">"': using default ["</span> + <span class="keyword">this</span>.applicationEventMulticaster + <span class="string">"]"</span>);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>默认SimpleApplicationEventMulticaster<br>直接看一下SimpleApplicationEventMulticaster用来广播event的代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multicastEvent</span><span class="params">(<span class="keyword">final</span> ApplicationEvent event, ResolvableType eventType)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// 这个是用来根据event的类型找到合适的listener的</span></span><br><span class="line">		ResolvableType type = (eventType != <span class="keyword">null</span> ? eventType : resolveDefaultEventType(event));</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;</span><br><span class="line">                        </span><br><span class="line">			Executor executor = getTaskExecutor();</span><br><span class="line">            <span class="comment">// executor不是空的时候会在executor中激活listener</span></span><br><span class="line">			<span class="keyword">if</span> (executor != <span class="keyword">null</span>) &#123;</span><br><span class="line">				executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">					<span class="meta">@Override</span></span><br><span class="line">					<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">						invokeListener(listener, event);</span><br><span class="line">					&#125;</span><br><span class="line">				&#125;);</span><br><span class="line">			&#125;</span><br><span class="line">            <span class="comment">// 否则就直接在当前调用线程中激活listener </span></span><br><span class="line">			<span class="keyword">else</span> &#123;</span><br><span class="line">				invokeListener(listener, event);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 在创建SimpleApplicationEventMulticaster时，executor是null，所以默认情况下所有的listener 的<code>onApplicationEvent</code>是直接在当前线程(事件发布者所在线程)中调用，所以<br>如果onApplicationEvent有阻塞操作也会导致事件发布者被阻塞，后续的其他listener也会被阻塞无法调用。</p>
</li>
<li>自定义multicaster<br>「2.1」中介绍spring会加载一个叫<code>applicationEventMulticaster</code>且实现了<code>ApplicationEventMulticaster</code>接口的multicaster，自定义multicaster需要实现了该接口然后将bean的名字设为<code>applicationEventMulticaster</code>即可。<br>下面的例子为默认的<code>SimpleApplicationEventMulticaster</code>添加了executor，以使事件发布者和监听者不用在同一个线程中调用：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//使用线程池运行listener</span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"executorService"</span> <span class="attr">class</span>=<span class="string">"java.util.concurrent.Executors"</span> <span class="attr">factory-method</span>=<span class="string">"newCachedThreadPool"</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"applicationEventMulticaster"</span> <span class="attr">class</span>=<span class="string">"org.springframework.context.event.SimpleApplicationEventMulticaster"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"taskExecutor"</span> <span class="attr">ref</span>=<span class="string">"executorService"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
</ol>
<h2 id="3-附"><a href="#3-附" class="headerlink" title="3. 附"></a>3. 附</h2><ol>
<li>Spring启动完成之后(已经完成bean解析，non-lazy-init的singleton实例化和初始化，完成listener的注册)，默认会发布一个<code>ContextRefreshedEvent</code>事件，该事件包装的消息是一个ApplicationContext对象。</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/22/spring-mvc工作机制/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Li Weisheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/22/spring-mvc工作机制/" itemprop="url">spring mvc工作机制</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-22T21:17:10+08:00">
                2017-10-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-配置"><a href="#1-配置" class="headerlink" title="1. 配置"></a>1. 配置</h2><p>springMVC的核心是DispatcherServlet，它实现了HttpServlet类，在web.xml中引入配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context-param</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath*:springMVC.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">context-param</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line"></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>Servlet容器tomcat在初始化DispatcherServlet时，会创建一个新的applicationContext(默认是<code>XmlWebApplicationContext</code>)去加载参数 <code>contextConfigLocation</code>指定的spring xml配置文件。</p>
<p>在基于注解的springMVC配置中，需要在spring配置文件中引入如下配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"..."</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>注解<code>&lt;mvc:annotation-driven/&gt;</code>默认会在spring上下文中引入以下这些bean:</p>
<ul>
<li>RequestMappingHandlerMapping</li>
<li><p>RequestMappingHandlerAdapter<br> 两者配合处理基于注解的(<code>@Controller</code>，<code>@RequestMapping</code>等等)spring mvc使用</p>
<p> RequestMappingHandlerMapping会读取spring上下文中所有使用  <code>@Controller</code>或者<code>@RequestMapping</code>注解的bean并解析他的方法作为handler</p>
</li>
<li><p>BeanNameUrlHandlerMapping<br>处理Struct风格的url，即将url作为bean name获取到bean，这种时候一个url请求对应一个bean（即你的controller类），这个时候你的controller类可以实现<code>AbstractController</code>抽象类</p>
<p> BeanNameUrlHandlerMapping会读取spring上下文中所有名字以’/‘开始的bean作为handler</p>
</li>
<li>SimpleControllerHandlerAdapter<br> 配合<code>BeanNameUrlHandlerMapping</code>一起使用。</li>
</ul>
<h2 id="2-SpringMVC工作流程"><a href="#2-SpringMVC工作流程" class="headerlink" title="2. SpringMVC工作流程"></a>2. SpringMVC工作流程</h2><p>如下图：</p>
<p><img src="/image/spring/springMVC.png" alt="springMVC流程.png"></p>
<ol>
<li>DispatcherServlet作为前端控制器，请求会先经过它，进入到其<code>doDispatch</code>方法中，DispatcherServlet可以有多个HandlerMapping和HandlerAdapter，DispatcherServlet根据按序排列它们。</li>
<li>DispatcherServlet会遍历所有HandlerMapping，并但返回第一个能够处理当前request的HandlerMapping对像，并调用其getHandler方法返回HandlerExecutionChain</li>
<li>HandlerExecutionChain由一个handler和若干HandlerInterceptor组成，其中handler其实就是用户的业务逻辑实现，由创建这个HandlerExecutionChain的HandlerMapping设置，比如RequestMappingHandlerMapping的handler其实就是Contorller的某个映射当前request url的method的封装。</li>
<li>DispatcherServlet调用所有HandlerInterceptor的preHandle处理request</li>
<li><p>HandlerAdaptor是HandlerExecutionChain的handler的适配器，对于有多个HandlerAdaptor的情况，返回第一个能够适配handler的适配器。</p>
<p>不同的适配器完成的功能不一样，一般都是在激活handler进入用户业务逻辑前做一些预处理，然后进入用户业务逻辑，最终返回ModelAnView对象。<code>RequestMappingHandlerAdapter</code>这种比较复杂的会处理<code>@PathVariable</code>,<code>@ModelAttribute</code>这个注解完成参数handler的参数的设置，然后调用handler的方法进入用户业务逻辑，</p>
</li>
<li><p>接下来调用HandlerExecutionChain中所有interceptor的postHandle</p>
</li>
<li>将ModelAndView交给ViewResolver处理</li>
</ol>
<h2 id="3-HandlerMapping"><a href="#3-HandlerMapping" class="headerlink" title="3. HandlerMapping"></a>3. HandlerMapping</h2><p>接口HandlerMapping只有一个接口方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HandlerExecutionChain <span class="title">getHandler</span><span class="params">(HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure></p>
<p>getHandler里一般是判断能不能处理这个request，不能返回null，否则返回HandlerExecutionChain，类成员如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HandlerExecutionChain</span></span>&#123;</span><br><span class="line">    <span class="comment">// handler一般是用户业务逻辑的封装</span></span><br><span class="line">	<span class="keyword">private</span> <span class="keyword">final</span> Object handler;</span><br><span class="line">    <span class="comment">// 拦截器</span></span><br><span class="line">	<span class="keyword">private</span> HandlerInterceptor[] interceptors;</span><br><span class="line">     ...</span><br><span class="line">    <span class="comment">// 上面第2节中步骤 4，它依次调用interceptors中每一个interceptor的preHandle</span></span><br><span class="line">    <span class="comment">// 只要有一个interceptor的preHandle返回false就不再走下去，直接返回false，本次对request处理结束，不再继续第2节中其他后续流程</span></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">applyPreHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> </span></span><br><span class="line"><span class="function">    <span class="comment">// 上面第2节中步骤 6</span></span></span><br><span class="line"><span class="function">  	<span class="keyword">void</span> <span class="title">applyPostHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, ModelAndView mv)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------拦截器HandlerInterceptor----------</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 返回false就不会调用后续拦截器，意味着本次request处理结束</span></span><br><span class="line">	<span class="function"><span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="comment">// preHandler返回false，或者出现异常，或者正常返回时调用</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">			HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span></span></span><br><span class="line"><span class="function">			<span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure></p>
<p>###3.1 HandlerMapping的一些实现类<br><strong>1. RequestMappingHandlerMapping</strong><br>它是用来处理使用了<code>@Controller</code>或者<code>@RequestMapping</code>注解的用户controller层面的业务逻辑类的。<br>像下面这样：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/api/echo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoTime</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/currentDate"</span>, method = RequestMethod.GET, produces = <span class="string">"application/json"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">currentDate</span><span class="params">()</span></span>&#123;</span><br><span class="line">        Date d = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(<span class="string">"in currentDate"</span>);</span><br><span class="line">        <span class="keyword">return</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>RequestMappingHandlerMapping获取当前applicationContext中所有使用了<code>@Controller</code>或者<code>@RequestMapping</code>注解的bean，然后解析这些bean中使用了<code>@RequestMapping</code>注解的方法，将这些方法封装成<code>HandlerMethod</code>,然后建立url到这个<code>HandlerMethod</code>的映射。</p>
<ul>
<li>RequestMappingHandlerMapping # getHandler返回的就是包装了HandlerMethod对象HandlerExecutionChain<ul>
<li>RequestMappingHandlerMapping返回的HandlerExecutionChain中interceptor处理用户在spring的配置文件中显示指定以外，应该默认会包含当前上下文中所有实现了MappedInterceptor的bean</li>
</ul>
</li>
</ul>
<p><strong>2. BeanNameUrlHandlerMapping</strong><br>它将url映射到bean。和在RequestMappingHandlerMapping中，一个url映射到一个contorller的方法不同。<br>同时BeanNameUrlHandlerMapping要求bean name必须是以’/‘开始的。BeanNameUrlHandlerMapping默认会加载当前applicationContext中所有bean name以‘／’开始bean，然后以bean name作为url建立到bean的映射。 这种方式中一般要求用户的controller类实现<code>Controller</code>接口，或者<code>AbstractController</code>抽象类。如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// bean name要以‘/’开始，</span></span><br><span class="line"><span class="meta">@Controller</span>(<span class="string">"/test.do"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoController</span> <span class="keyword">extends</span> <span class="title">AbstractController</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> ModelAndView <span class="title">handleRequestInternal</span><span class="params">(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ModelAndView modelAndView = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        modelAndView.addObject(<span class="string">"date"</span>, <span class="string">"date"</span>);</span><br><span class="line">        <span class="keyword">return</span> modelAndView;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>BeanNameUrlHandlerMapping返回的HandlerExecutionChain的handler就是匹配url的bean的实例。</p>
<p><strong>3. SimpleUrlHandlerMapping</strong><br>这是一种很灵活的Handler Mapping，能够直接指定url到bean的映射, 可以在配置文件中指定：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"echoContorller"</span> <span class="attr">class</span>=<span class="string">"me.eric.springmvc.controller.EchoController"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.SimpleUrlHandlerMapping"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"urlMap"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                   <span class="comment">&lt;!--将url:/test.do映射到echoController处理--&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"/test.do"</span>&gt;</span>echoContorller<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>##4 HandlerAdaptor<br>接口HandlerAdaptor如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数handler即HandlerExecutionChain中的handler, supports判断当前adaptor是否适配handler</span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">supports</span><span class="params">(Object handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用handler处理请求</span></span><br><span class="line"><span class="function">ModelAndView <span class="title">handle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="keyword">throws</span> Exception</span>;</span><br></pre></td></tr></table></figure></p>
<p>###4.1 HandlerAdaptor实现类<br><strong>1. RequestMappingHandlerAdapter</strong><br>它能适配RequestMappingHandlerMapping返回的handler，即MethodHandler的实例(它封装了处理当前请求url的bean以及更加具体method的信息)</p>
<p>RequestMappingHandlerAdapter会处理<code>@PathVariable</code>,<code>@ModelAttribute</code>等注解。</p>
<p>它会先完成使用了<code>@ModelAttribute</code>注解的方法的调用。然后调用url映射的具体方法的调用(调用前完成方法参数的绑定)。</p>
<p><strong>2. SimpleControllerHandlerAdapter</strong><br>它能够适配<code>BeanNameUrlHandlerMapping</code>和<code>SimpleUrlHandlerMapping</code>返回的handler(也就是controller bean的实例)</p>
<p>##5. HandlerInterceptor<br>在HandlerAdaptor # handle前后调用，也就是在用户业务逻辑代码前后提供预处理和后处理的能力。</p>
<p>自定义interceptor需要实现接口HandlerInterceptor，然后在spring的xml文件中配置:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myInterceptor"</span> <span class="attr">class</span>=<span class="string">"me.eric.springmvc.interceptors.MyInterceptor"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">                // 拦截这个地址</span><br><span class="line">                <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/test.do"</span>/&gt;</span></span><br><span class="line">               //不拦截这个地址</span><br><span class="line">                <span class="tag">&lt;<span class="name">mvc:exclude-mapping</span> <span class="attr">path</span>=<span class="string">"/test2.do"</span></span></span><br><span class="line">                &lt;ref bean="myInterceptor"/&gt;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面这种写法，自定义拦截器myInterceptor会被包装成MappedInterceptor，看看MappedInterceptor的成员就明白了:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// url匹配这些模式的拦截</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] includePatterns;</span><br><span class="line"></span><br><span class="line"><span class="comment">// url匹配这些模式的不拦截</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> String[] excludePatterns;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 真正的拦截器</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HandlerInterceptor interceptor;</span><br></pre></td></tr></table></figure></p>
<p>所以如果你不使用<code>&lt;mvc:interceptors&gt;</code>的形式定义拦截器，也可以直接使用MappedInterceptor作为bean，如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.MappedInterceptor"</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"0"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                        <span class="tag">&lt;<span class="name">value</span>&gt;</span>/test.do<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">index</span>=<span class="string">"1"</span>&gt;</span></span><br><span class="line">                    <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"timerInterceptor"</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;/<span class="name">constructor-arg</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>上面不管哪种定义拦截器的方式，都会被<code>RequestMappingHandlerMapping</code>,<code>BeanNameUrlHandlerMapping</code>,<code>SimpleUrlHandlerMapping</code>加载。</p>
<p>要想单独只被某个HandlerMapping加载，应该做如下配置：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.handler.BeanNameUrlHandlerMapping"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"interceptors"</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">ref</span> <span class="attr">bean</span>=<span class="string">"myInterceptor"</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">这样myInterceptor这个拦截器只会被这个BeanNameUrlHandlerMapping使用到。</span><br></pre></td></tr></table></figure></p>
<p><strong>注：</strong>如果按上面配置，同时xml文件里又存在<code>&lt;mvc:annotation-driven/&gt;</code>,那么可能发现不生效，原因是因为<code>&lt;mvc:annotation-driven/&gt;</code>会默认加载一个<code>BeanNameUrlHandlerMapping</code>,而且它的优先级是2(越小越高)，而你在配置文件里的<code>BeanNameUrlHandlerMapping</code>默认优先级很低，前面说到DispatcherServlet会对HandlerMapping排序，所以它默认加载的总是会先使用。</p>
<h1 id="一些参考"><a href="#一些参考" class="headerlink" title="一些参考"></a>一些参考</h1><ol>
<li><a href="https://www.tianmaying.com/tutorial/spring-mvc-quickstart" target="_blank" rel="noopener">spring mvc快速入门教程</a></li>
<li><a href="http://blog.csdn.net/zjf280441589/article/details/51831530" target="_blank" rel="noopener">Spring MVC实践</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/21/spring-mvc中一些注解/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Li Weisheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/21/spring-mvc中一些注解/" itemprop="url">spring mvc中一些注解</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-21T21:20:01+08:00">
                2017-10-21
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>本文主要记录一下spring mvc中常用的注解的使用</p>
<h2 id="2-注解"><a href="#2-注解" class="headerlink" title="2. 注解"></a>2. 注解</h2><p><strong>1. @ModelAttribute</strong><br>这个注解可以用在方法或者参数上，注解本身可用的三个成员：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">- String value()</span><br><span class="line">- String name()</span><br><span class="line">   name和value互为别名，作用是一样的</span><br><span class="line">- boolean binding()</span><br><span class="line">默认true</span><br></pre></td></tr></table></figure></p>
<p>用在不同的地方代表的含义也有所不同：</p>
<ol>
<li><p>用在方法上<br>使用<code>@ModelAttribute</code>注解方法是，是将方法的返回值绑定到一个名字上，同时当访问某个URL并最终走到这个url映射的<code>Controller</code>的具体的一个的方法methodA时，这个Controller里所有使用了<code>@ModelAttribute</code>注解的方法都会先被执行一遍，然后执行的结果被绑定到一个name上，如下例:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/api/echo"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EchoTime</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/timestamp"</span>, method = RequestMethod.GET, produces = <span class="string">"application/json"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Long <span class="title">currentTimeStamp</span><span class="params">(@ModelAttribute(<span class="string">"name"</span>)</span> String name)</span>&#123;</span><br><span class="line">        System.out.println(name);</span><br><span class="line">        <span class="keyword">return</span> System.currentTimeMillis();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@ModelAttribute</span>(<span class="string">"name"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testModeAnAttribute</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"in testModeAnAttribute..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"eric"</span> + i ++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------连续两次访问输出结果如下---------</span><br><span class="line">in testModeAnAttribute...</span><br><span class="line">eric0</span><br><span class="line"></span><br><span class="line">in testModeAnAttribute...</span><br><span class="line">eric1</span><br></pre></td></tr></table></figure>
</li>
<li><p>用在参数上<br>上面例子也反应了用在参数上含义：<br><code>public Long currentTimeStamp(@ModelAttribute(&quot;name&quot;) String name)</code><br>将属性明为name的值绑定到参数上，这个name的值可以是上面例子中<code>@ModelAttribute</code>注解的方法的返回值，也可以是url中的请求参数.</p>
</li>
</ol>
<p><strong>2. @SessionAttributes</strong><br>注解在类上（controller类上），它可以指定一些names或者types，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SessionAttributes</span>(names = &#123;<span class="string">"lastAccessTime"</span>,<span class="string">"lastUpdateTime"</span>&#125;)</span><br></pre></td></tr></table></figure></p>
<p>表示将model中属性为’lastAccessTime’和‘ lastUpdateTime’的值绑定到session上。配合注解在参数上的<code>methodA(@ModelAttribute(&quot;lastAccessTime&quot;)  Date lastAccessTime</code>一起使用,可以将session中‘ lastAccessTime’的值绑定到参数上。</p>
<p>它的流程大概是:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">@ SessionAttributes实现时不是直接将name和value设置到HttpSession里的，而是保存在一个自己维护的store里，然后：</span><br><span class="line">1. 执行controller的method之前：</span><br><span class="line">    - 获得@ModelAttribute注解的参数名称(同时这些参数名称也在SessionAttributes的名称列表里)，从HttpSession中获取这个名称的值，将这些name-value对保存到自己的store里，</span><br><span class="line">    - 再写到一个新的Model里面</span><br><span class="line">2. 执行controller方法</span><br><span class="line">3. 执行controller方法之后获得新的Model，然后将Model中的name-value设置到HttpSession中</span><br><span class="line"></span><br><span class="line">综上这个过程，可以看出你在代码中调用HttpSession # removeAttribute是不会生效的，应为controller方法执行完后上面第3步还是设置HttpSession</span><br><span class="line"></span><br><span class="line">讲真我觉得SessionAttributes很少在开发中使用吧</span><br></pre></td></tr></table></figure></p>
<p>持续更新…</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/17/spring生命周期管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Li Weisheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/17/spring生命周期管理/" itemprop="url">spring生命周期管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-17T21:22:45+08:00">
                2017-10-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>本文主要记录一下Spring中bean的生命周期，即从bean实例化到最终销毁的过程中一些重要的节点，以及Spring提供的在bean这些节点过程中的一些操作。</p>
<h2 id="2-Bean生命周期"><a href="#2-Bean生命周期" class="headerlink" title="2. Bean生命周期"></a>2. Bean生命周期</h2><p>如下图所示:</p>
<p><img src="/image/spring/spring-lifecycle.png" alt="Spring生命周期.png"></p>
<h3 id="2-1-BeanFactoryPostProcessor"><a href="#2-1-BeanFactoryPostProcessor" class="headerlink" title="2.1  BeanFactoryPostProcessor"></a>2.1  BeanFactoryPostProcessor</h3><p>该接口有如下方法:<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>;</span><br></pre></td></tr></table></figure></p>
<p>   该接口的实现类最先被实例化，它是一个spring容器级别的后置处理器，尽管此时所有的bean都没有被实例化出来，但是bean的配置文件已经被分析完，所有的bean的定义信息(spring中使用类BeanDefinition表示)已经加载，可以通过<code>ConfigurableListableBeanFactory  # getBeanDefinition(String beanName)</code>获取，获取到BeanDefiniton意味着你可以修改bean的属性了。</p>
<p><strong>BeanFactoryPostProcessor 的一些实现类</strong></p>
<ol>
<li><p>PropertyPlaceholderConfigurer<br>这个很多人用过，从key=value形式的配置文件中加载配置信息，并通过${propertyName}的形式设置到bean属性上，如下面这种形式:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span></span></span><br><span class="line"><span class="tag">         <span class="attr">location</span>=<span class="string">"classpath:db.properties"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">file-encoding</span>=<span class="string">"utf8"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.driver&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.url&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.user&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.password&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>上面使用了简易的形式<context:property-placeholder ...="">, 这种情况下会创建<code>PropertyPlaceholderConfigurer</code>对应的bean。关于<context>命名空间，请看 <strong>附录1</strong></context></context:property-placeholder></p>
</li>
<li><p>PropertyOverrideConfigurer<br>这个和 <code>PropertyPlaceholderConfigurer</code>一样将bean的属性卸载properties文件中，用法如下:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">首先假设在db.properties中如下内容:</span><br><span class="line">dataSource.username=root</span><br><span class="line">dataSource.password=root</span><br><span class="line">同样是name=value的形式，但是name必须是<span class="tag">&lt;<span class="name">beanName</span>&gt;</span>.<span class="tag">&lt;<span class="name">beanPropertyName</span>&gt;</span>格式</span><br><span class="line"></span><br><span class="line">然后在applicationContext.xml中如下定义bean即可:</span><br><span class="line"> <span class="comment">&lt;!--这个命名空间会加载PropertyOverrideConfigurer--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-override</span> <span class="attr">location</span>=<span class="string">"db.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--bean id需要和db.properties中beanName一样--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">PropertyOverrideConfigurer这个后置处理器会根据db.properties中dataSource这个bean的名字找到属性，然后填充到dataSource这个bean中</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-2-BeanPostProcessor"><a href="#2-2-BeanPostProcessor" class="headerlink" title="2.2 BeanPostProcessor"></a>2.2 BeanPostProcessor</h3><p>BeanPostProcessor有两个接口方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br></pre></td></tr></table></figure></p>
<p>BeanPostProcessor在普通bean实例化之前就就创建了，但是他的两个接口方法在却在普通bean实例化(即创建bean类的对象)，通过setter完成了属性注入之后调用，这两个方法在bean初始化前后调用(bean初始化是指调用xml中bean定义中init-method指定的方法，或者bean实现了InitializingBean接口，调用接口方法)，详细的可见上图。</p>
<p><strong>BeanPostProcessor的一些实现类</strong></p>
<ol>
<li>AutowiredAnnotationBeanPostProcessor<br>用于使用<code>@Autowired</code>和<code>@Value</code>注解的解析</li>
<li>RequiredAnnotationBeanPostProcessor<br>用于使用<code>@Require</code>注解的解析</li>
<li><p>CommonAnnotationBeanPostProcessor<br>用于使用<code>@Resource</code>, <code>@PostConstruct</code>,<code>@PreDestroy</code>注解的解析。</p>
<blockquote>
<p>上面三类在在基于注解的方式装配bean时经常使用，当在xml文件里配置<code>&lt;context:annotation-config /&gt;</code>时，spring会创建上面三类PostProcessor，同样属于context空间，参考 <strong>附录1</strong></p>
</blockquote>
</li>
<li>ScheduledAnnotationBeanPostProcessor<br>用于使用了<code>@Scheduled</code>注解的方法的解析，在xml中添加<code>&lt;task:annotation-driven&gt;</code>时会创建这个PostProcessor, 如下例所示:<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">task:annotation-driven</span> <span class="attr">scheduler</span>=<span class="string">"taskScheduler"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">"taskScheduler"</span> <span class="attr">pool-size</span>=<span class="string">"42"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">task:scheduled-tasks</span> <span class="attr">scheduler</span>=<span class="string">"taskScheduler"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">task:scheduled</span> <span class="attr">ref</span>=<span class="string">"myTask"</span> <span class="attr">method</span>=<span class="string">"work"</span> <span class="attr">fixed-rate</span>=<span class="string">"1000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">task:scheduled-tasks</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myTask"</span> <span class="attr">class</span>=<span class="string">"com.foo.MyTask"</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line">这个例子来自于spring代码@EnableScheduling注释</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-3-ApplicationContextAware"><a href="#2-3-ApplicationContextAware" class="headerlink" title="2.3 ApplicationContextAware"></a>2.3 ApplicationContextAware</h3><p>它只有一个接口方法<code>setApplicationContext(ApplicationContext apc)</code>,  实现它的bean而言，apc即该bean运行时所处的applicationContext，上图没有画出它的调用时机，它在<code>BeanFactoryAware # setBeanFactory</code>之后调用。</p>
<h2 id="附录1-context命名空间"><a href="#附录1-context命名空间" class="headerlink" title="附录1 - context命名空间"></a>附录1 - context命名空间</h2><p>在<code>spring-context</code>的jar包中META-INF目录下有文件‘spring.handlers’中有这样一行<code>http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler</code>, context命名空间加载了类<code>ContextNamespaceHandler</code>，下面是这个类的init方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">"property-placeholder"</span>, <span class="keyword">new</span> PropertyPlaceholderBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">"property-override"</span>, <span class="keyword">new</span> PropertyOverrideBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">"annotation-config"</span>, <span class="keyword">new</span> AnnotationConfigBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">"component-scan"</span>, <span class="keyword">new</span> ComponentScanBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">"load-time-weaver"</span>, <span class="keyword">new</span> LoadTimeWeaverBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">"spring-configured"</span>, <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">"mbean-export"</span>, <span class="keyword">new</span> MBeanExportBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">"mbean-server"</span>, <span class="keyword">new</span> MBeanServerBeanDefinitionParser());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>包含了context这个命名空间下所有子元素对应的Parser, 这写parser负责解析xml元素，然后创建对应BeanDefinition</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/09/Spark-Streaming-3-Receiver和ReceiverTacker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Li Weisheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/09/Spark-Streaming-3-Receiver和ReceiverTacker/" itemprop="url">Spark Streaming(3) - Receiver和ReceiverTacker</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-09T23:15:07+08:00">
                2017-05-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>本文基于spark 2.11</em></p>
<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>在Spark Streaming(1)中介绍spark streaming工作流程中时，大致介绍了streaming job在运行时从stream中读取数据的流程：</p>
<ol>
<li>Receiver运行在executor上接收数据，将数据转交给ReceiverSupervisor，然后ReceiverSupervisor利用blockmanager存储好数据，并将数据块信息汇报给ReceiverTracker。</li>
<li>ReceiverTracker运行在Driver上，接收数据块信息保存，后续在JobGenerator生成新jobs时分配数据作为新jobs的数据源。</li>
</ol>
<p>本文将详细介绍上述流程。</p>
<h1 id="2-ReceiverTracker"><a href="#2-ReceiverTracker" class="headerlink" title="2 ReceiverTracker"></a>2 ReceiverTracker</h1><p>ReceiverTracker有以下核心成员：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private val receiverInputStreams = ssc.graph.getReceiverInputStreams()</span><br><span class="line">private val receiverInputStreamIds = receiverInputStreams.map &#123; _.id &#125;</span><br><span class="line">private val receivedBlockTracker = ...</span><br></pre></td></tr></table></figure></p>
<ol>
<li>receiverInputStreams,DStreamGraph保存的所有DStream Graph所有的实现了ReceiverInputDStream类DStream，意味着这些DStream持有receiver，能够发送在executor启动执行接收流数据的任务。</li>
<li>每一个receiver都有一个id，receiver汇报自己的数据时一并汇报自己的id，DStream DAG源头的ReceiverInputDStream使用receiverTracker获取属于数据时就根据自己的id知道应该取哪些数据。</li>
<li>receivedBlockTracker，后面会讲。</li>
</ol>
<h2 id="2-1-ReceiverTracker的启动"><a href="#2-1-ReceiverTracker的启动" class="headerlink" title="2.1 ReceiverTracker的启动"></a>2.1 ReceiverTracker的启动</h2><p>先在Driver端启动ReceiverTracker，是在JobScheduler启动时完成，有如下调用序列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StreamingContext#start</span><br><span class="line">   -&gt;JobScheduler#start</span><br><span class="line">      -&gt;ReceiverTracker#start</span><br></pre></td></tr></table></figure></p>
<p>下面则是ReceiverTracker的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def start(): Unit = synchronized &#123;</span><br><span class="line">    if (isTrackerStarted) &#123;</span><br><span class="line">      throw new SparkException(&quot;ReceiverTracker already started&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!receiverInputStreams.isEmpty) &#123;</span><br><span class="line">      endpoint = ssc.env.rpcEnv.setupEndpoint(</span><br><span class="line">        &quot;ReceiverTracker&quot;, new ReceiverTrackerEndpoint(ssc.env.rpcEnv))</span><br><span class="line">      if (!skipReceiverLaunch) launchReceivers()</span><br><span class="line">      logInfo(&quot;ReceiverTracker started&quot;)</span><br><span class="line">      trackerState = Started</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到start代码中在rpcEnv上注册了一个Rpc服务（关于spark 的Rcp原理可以参考<a href="http://www.jianshu.com/p/7da49e332e70" target="_blank" rel="noopener">spark网络通信-RPC的实现</a>）</p>
<p>可以看看它注册的receiverTrackerEndpoint的receive和receiveAdnreply方法看看它就收什么消息，提供什么服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">override def receive: PartialFunction[Any, Unit] = &#123;</span><br><span class="line">      // Local messages</span><br><span class="line">      case StartAllReceivers(receivers) =&gt;</span><br><span class="line">          ...</span><br><span class="line">          //这个消息是自己发给自己的，在executor上启动receiver</span><br><span class="line">          startReceiver(receiver, executors)</span><br><span class="line">        &#125;</span><br><span class="line">      case RestartReceiver(receiver) =&gt;</span><br><span class="line">        ...</span><br><span class="line">        startReceiver(receiver, scheduledLocations)</span><br><span class="line">      case c: CleanupOldBlocks =&gt;</span><br><span class="line">        // 处理过了batch数据可以清除了</span><br><span class="line">        ...</span><br><span class="line">      case ReportError(streamId, message, error) =&gt;</span><br><span class="line">        reportError(streamId, message, error)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override def receiveAndReply(context: RpcCallContext): PartialFunction[Any, Unit] = &#123;</span><br><span class="line">      // Remote messages</span><br><span class="line">      case RegisterReceiver(streamId, typ, host, executorId, receiverEndpoint) =&gt;</span><br><span class="line">         ...</span><br><span class="line">        // receiver在executor上启动之后会将自己注册到ReceiverTracker上，好让它感知到</span><br><span class="line">      case DeregisterReceiver(streamId, message, error) =&gt;</span><br><span class="line">        deregisterReceiver(streamId, message, error)</span><br><span class="line">        context.reply(true)</span><br><span class="line"></span><br><span class="line">      // Local messages</span><br><span class="line">     case AddBlock(receivedBlockInfo) =&gt;</span><br><span class="line">      // 接收receiver上报的数据信息</span><br><span class="line">     ...</span><br><span class="line">      case AllReceiverIds =&gt;</span><br><span class="line">        context.reply(receiverTrackingInfos.filter(_._2.state != ReceiverState.INACTIVE).keys.toSeq)</span><br><span class="line">      case GetAllReceiverInfo =&gt;</span><br><span class="line">        context.reply(receiverTrackingInfos.toMap)</span><br><span class="line">      case StopAllReceivers =&gt;</span><br><span class="line">        assert(isTrackerStopping || isTrackerStopped)</span><br><span class="line">        stopReceivers()</span><br><span class="line">        context.reply(true)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以它提供的服务包括注册启动receivers，注册和销毁数据等。</p>
<p>在回到start方法中调用<code>launchReceivers()</code>启动receiver。</p>
<h2 id="2-2-ReceiverTracker-处理receiver汇报的数据"><a href="#2-2-ReceiverTracker-处理receiver汇报的数据" class="headerlink" title="2.2 ReceiverTracker 处理receiver汇报的数据"></a>2.2 ReceiverTracker 处理receiver汇报的数据</h2><p>ReceiverTracker的rpc服务接收到AddBlock()消息表示接收到receiver汇报的数据信息。</p>
<p>先看看AddBlock消息的结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// AddBlock消息包含了ReceiverdBlockInfo,这里存储了receiver上报的数据具体信息</span><br><span class="line">private[streaming] case class AddBlock(receivedBlockInfo: ReceivedBlockInfo)</span><br><span class="line"></span><br><span class="line">// 上报了streamId，numRecords表示本次batch中记录数,</span><br><span class="line">// blockStoreResult  有两个实现类：</span><br><span class="line">//.       1. BlockManagerBasedStoreResult，receiver端使用blockmanager管理batch数据</span><br><span class="line">//        2. WriteAheadLogBasedStoreResult, receiver端使用了WAL保存了batch数据</span><br><span class="line">//.     关于这两种方式会在Receiver端时解释</span><br><span class="line">private[streaming] case class ReceivedBlockInfo(</span><br><span class="line">    streamId: Int,</span><br><span class="line">    numRecords: Option[Long],</span><br><span class="line">    metadataOption: Option[Any],</span><br><span class="line">    blockStoreResult: ReceivedBlockStoreResult</span><br><span class="line">  ) &#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>再回到到rpc服务接收到AddBlock的处理，进入如下调用序列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case AddBlock =&gt;. 接收到AddBlock消息</span><br><span class="line">    -&gt; ReceiverTracker#addBlock</span><br><span class="line">     -&gt; ReceivedBlockTracker#addBlock 使用receivedBlockTracker来管理上报的数据</span><br></pre></td></tr></table></figure></p>
<p><strong>ReceiveBlockTracker</strong><br>接收到的消息最终时通过ReceivedBlockTracker来管理的，下面两个成员涉及到ReceivedBlockTracker管理上报的数据信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private type ReceivedBlockQueue = mutable.Queue[ReceivedBlockInfo]</span><br><span class="line"></span><br><span class="line">  private val streamIdToUnallocatedBlockQueues = new mutable.HashMap[Int, ReceivedBlockQueue]</span><br><span class="line">  private val timeToAllocatedBlocks = new mutable.HashMap[Time, AllocatedBlocks]</span><br></pre></td></tr></table></figure></p>
<ol>
<li>ReceivedBlockQueue，定义这个类型，后边的所有数据信息是保存在队列里的</li>
<li>streamIdToUnallocatedBlockQueues，首先上报的数据是安streamId区分开来的，这个队列保存上报上来的，但是还还没有分配给某个job的的数据。</li>
<li>timeToAllocatedBlocks，JobGenerator生成job时请求receiverTracker分配数据给job，receiverTracker调用ReceiveBlockTracker分配数据，数据时间（job生成时间），streamId索引到，job对应的RDD DAG就能根据时间和streamId从这里去数据。</li>
</ol>
<p>到这里ReceiveBlockTracker的addBlock的工作就清楚了将上报的数据保存到streamIdToUnallocatedBlockQueues就行了。</p>
<h2 id="2-3-ReceiverTracker-为job分配数据"><a href="#2-3-ReceiverTracker-为job分配数据" class="headerlink" title="2.3 ReceiverTracker 为job分配数据"></a>2.3 ReceiverTracker 为job分配数据</h2><p><a href="http://www.jianshu.com/p/8a28a711400a" target="_blank" rel="noopener">Spark Streaming(2)</a>中第3节介绍JobGenerator生成job是方法generateJobs调用了<code>receiverTracker.allocateBlocksToBatch</code>为job分配输入数据，分配数据的工作同样委派给ReceiveBlockTracker，下面是其allocateBlocksToBatch方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def allocateBlocksToBatch(batchTime: Time): Unit = synchronized &#123;</span><br><span class="line">    if (lastAllocatedBatchTime == null || batchTime &gt; lastAllocatedBatchTime) &#123;</span><br><span class="line">     // 将streamIdToUnallocatedBlockQueues中的数据全部取出来按照streamId区分</span><br><span class="line">      val streamIdToBlocks = streamIds.map &#123; streamId =&gt;</span><br><span class="line">          (streamId, getReceivedBlockQueue(streamId).dequeueAll(x =&gt; true))</span><br><span class="line">      &#125;.toMap</span><br><span class="line">      val allocatedBlocks = AllocatedBlocks(streamIdToBlocks)</span><br><span class="line">      if (writeToLog(BatchAllocationEvent(batchTime, allocatedBlocks))) &#123;</span><br><span class="line">      // 保存到timeToAllocatedBlocks，job里处于输入源的DStream根据自己的时间的streamId取数据转换成BlockRDD。</span><br><span class="line">        timeToAllocatedBlocks.put(batchTime, allocatedBlocks)</span><br><span class="line">        lastAllocatedBatchTime = batchTime</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        logInfo(s&quot;Possibly processed batch $batchTime needs to be processed again in WAL recovery&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">   </span><br><span class="line">      logInfo(s&quot;Possibly processed batch $batchTime needs to be processed again in WAL recovery&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="3-Receiver和ReceiverSupervisor"><a href="#3-Receiver和ReceiverSupervisor" class="headerlink" title="3. Receiver和ReceiverSupervisor"></a>3. Receiver和ReceiverSupervisor</h1><p>2.1中提到ReceiverTracker的start方法调用launchReceivers启动receiver, 在receiver启动之前的调用是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReceiverTracker#start</span><br><span class="line">   -&gt;ReceiverTracker#launchReceivers</span><br><span class="line">         -&gt; ReceiverTrackerEndpoint#send(StartAllReceivers(receivers))</span><br><span class="line">                                               | 给rpc服务发送StartAllReceivers消息</span><br><span class="line">                                               v</span><br><span class="line">    rpc服务收到消息    ReceiverTrackerEndpoint#receive </span><br><span class="line">                      -&gt;ReceiverTracker#startReceiver  在executor上启动receiver</span><br></pre></td></tr></table></figure></p>
<p><strong>receiver的获取</strong><br>spark streaming(1) 的2.2节提到ReceiverInputDStream需要返回一个receiver。<br><strong>启动receiver</strong></p>
<ol>
<li>launchReceivers 从ReceiverTracker#receiverInputStreams成员中最终获取到所有receivers，</li>
<li>给自己持有的rpc发送StartAllReceivers消息</li>
<li>接收到消息的rpc服务调用ReceiverTracker#startReceiver</li>
</ol>
<p>核心在startReceiver，下面代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">private def startReceiver(</span><br><span class="line">       receiver: Receiver[_],</span><br><span class="line">       scheduledLocations: Seq[TaskLocation]): Unit = &#123;</span><br><span class="line">     def shouldStartReceiver: Boolean = &#123;</span><br><span class="line">       // It&apos;s okay to start when trackerState is Initialized or Started</span><br><span class="line">       !(isTrackerStopping || isTrackerStopped)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     val receiverId = receiver.streamId</span><br><span class="line">     if (!shouldStartReceiver) &#123;</span><br><span class="line">       onReceiverJobFinish(receiverId)</span><br><span class="line">       return</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     val checkpointDirOption = Option(ssc.checkpointDir)</span><br><span class="line">     val serializableHadoopConf =</span><br><span class="line">       new SerializableConfiguration(ssc.sparkContext.hadoopConfiguration)</span><br><span class="line"></span><br><span class="line">     // 这个函数会在receiver相关信息发送到executor上执行</span><br><span class="line">     val startReceiverFunc: Iterator[Receiver[_]] =&gt; Unit =</span><br><span class="line">       (iterator: Iterator[Receiver[_]]) =&gt; &#123;</span><br><span class="line">         if (!iterator.hasNext) &#123;</span><br><span class="line">           throw new SparkException(</span><br><span class="line">             &quot;Could not start receiver as object not found.&quot;)</span><br><span class="line">         &#125;</span><br><span class="line">         if (TaskContext.get().attemptNumber() == 0) &#123;</span><br><span class="line">           val receiver = iterator.next()</span><br><span class="line">           assert(iterator.hasNext == false)</span><br><span class="line">           // 启动receiverSupervisor</span><br><span class="line">           val supervisor = new ReceiverSupervisorImpl(</span><br><span class="line">             receiver, SparkEnv.get, serializableHadoopConf.value, checkpointDirOption)</span><br><span class="line">           supervisor.start()</span><br><span class="line">           supervisor.awaitTermination()</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">           // It&apos;s restarted by TaskScheduler, but we want to reschedule it again. So exit it.</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">     // 创建了RDD，RDD的数据就是receivers组成的，结合上面的函数startReceiverFunc运行在RDD的数据上，也就是接收receiver作为参数运行</span><br><span class="line">    </span><br><span class="line">     val receiverRDD: RDD[Receiver[_]] =</span><br><span class="line">       if (scheduledLocations.isEmpty) &#123;</span><br><span class="line">         ssc.sc.makeRDD(Seq(receiver), 1)</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         val preferredLocations = scheduledLocations.map(_.toString).distinct</span><br><span class="line">         ssc.sc.makeRDD(Seq(receiver -&gt; preferredLocations))</span><br><span class="line">       &#125;</span><br><span class="line">     receiverRDD.setName(s&quot;Receiver $receiverId&quot;)</span><br><span class="line">     ssc.sparkContext.setJobDescription(s&quot;Streaming job running receiver $receiverId&quot;)</span><br><span class="line">     ssc.sparkContext.setCallSite(Option(ssc.getStartSite()).getOrElse(Utils.getCallSite()))</span><br><span class="line"></span><br><span class="line">    // RDD生成job提交运行</span><br><span class="line">     val future = ssc.sparkContext.submitJob[Receiver[_], Unit, Unit](</span><br><span class="line">       receiverRDD, startReceiverFunc, Seq(0), (_, _) =&gt; Unit, ())</span><br><span class="line">     // We will keep restarting the receiver job until ReceiverTracker is stopped</span><br><span class="line">     future.onComplete &#123;</span><br><span class="line">       case Success(_) =&gt;</span><br><span class="line">         if (!shouldStartReceiver) &#123;</span><br><span class="line">           onReceiverJobFinish(receiverId)</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">           logInfo(s&quot;Restarting Receiver $receiverId&quot;)</span><br><span class="line">           self.send(RestartReceiver(receiver))</span><br><span class="line">         &#125;</span><br><span class="line">       case Failure(e) =&gt;</span><br><span class="line">         if (!shouldStartReceiver) &#123;</span><br><span class="line">           onReceiverJobFinish(receiverId)</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">           logError(&quot;Receiver has been stopped. Try to restart it.&quot;, e)</span><br><span class="line">           logInfo(s&quot;Restarting Receiver $receiverId&quot;)</span><br><span class="line">           self.send(RestartReceiver(receiver))</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;(ThreadUtils.sameThread)</span><br><span class="line">     logInfo(s&quot;Receiver $&#123;receiver.streamId&#125; started&quot;)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>根据spark job提交一文介绍，最终startReceiverFunc函数会被包装成ResultTask运行在executor上，而ResultTask会调用startReceiverFunc完成receiverSupervisor的创建。</p>
<h3 id="3-1-Receiver"><a href="#3-1-Receiver" class="headerlink" title="3.1 Receiver"></a>3.1 Receiver</h3><p>上 面代码Receiver的启动序列是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReceiverSupervisor#start</span><br><span class="line">   -&gt; ReceiverSupervisor#startReceiver</span><br><span class="line">      -&gt; Receiver#onStart</span><br></pre></td></tr></table></figure></p>
<p>Receiver主要有如下成员和方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@transient private var _supervisor: ReceiverSupervisor = null</span><br><span class="line">def storeXXX()</span><br><span class="line">def onStart()</span><br><span class="line">def streamId: Int = id</span><br></pre></td></tr></table></figure></p>
<ol>
<li>_supervisor,  Receiver需要将自己接受到的数据转给ReceiverSupervisor</li>
<li>storeXXX,是一系列的方法， 存储数据，内部就是调用ReceiverSupervisor的方法从而将数据转给他存储并汇报给ReceiverTracker。</li>
<li>onStart，receiver启动是调用，一般在这里从流中读数据</li>
<li>streamId， 每一个输入流唯一的id标识</li>
</ol>
<p>以SocketReceiver为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">private[streaming]</span><br><span class="line">class SocketReceiver[T: ClassTag](</span><br><span class="line">    host: String,</span><br><span class="line">    port: Int,</span><br><span class="line">    bytesToObjects: InputStream =&gt; Iterator[T],</span><br><span class="line">    storageLevel: StorageLevel</span><br><span class="line">  ) extends Receiver[T](storageLevel) with Logging &#123;</span><br><span class="line"></span><br><span class="line">  private var socket: Socket = _</span><br><span class="line"></span><br><span class="line">  def onStart() &#123;</span><br><span class="line"></span><br><span class="line">    logInfo(s&quot;Connecting to $host:$port&quot;)</span><br><span class="line">    try &#123;</span><br><span class="line">      socket = new Socket(host, port)</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">      case e: ConnectException =&gt;</span><br><span class="line">        restart(s&quot;Error connecting to $host:$port&quot;, e)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    logInfo(s&quot;Connected to $host:$port&quot;)</span><br><span class="line"></span><br><span class="line">    // Start the thread that receives data over a connection</span><br><span class="line">    new Thread(&quot;Socket Receiver&quot;) &#123;</span><br><span class="line">      setDaemon(true)</span><br><span class="line">      override def run() &#123; receive() &#125;</span><br><span class="line">    &#125;.start()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def onStop() &#123;</span><br><span class="line">    // in case restart thread close it twice</span><br><span class="line">    synchronized &#123;</span><br><span class="line">      if (socket != null) &#123;</span><br><span class="line">        socket.close()</span><br><span class="line">        socket = null</span><br><span class="line">        logInfo(s&quot;Closed socket to $host:$port&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /** Create a socket connection and receive data until receiver is stopped */</span><br><span class="line">  def receive() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      val iterator = bytesToObjects(socket.getInputStream())</span><br><span class="line">      while(!isStopped &amp;&amp; iterator.hasNext) &#123;</span><br><span class="line">        store(iterator.next())</span><br><span class="line">      &#125;</span><br><span class="line">      if (!isStopped()) &#123;</span><br><span class="line">        restart(&quot;Socket data stream had no more data&quot;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        logInfo(&quot;Stopped receiving&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">      case NonFatal(e) =&gt;</span><br><span class="line">        logWarning(&quot;Error receiving data&quot;, e)</span><br><span class="line">        restart(&quot;Error receiving data&quot;, e)</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      onStop()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>onStart方法启动了后台线程调用receive()接收数据</li>
<li>receive方法调用store方法存入一条数据记录。<br>下面是store方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def store(dataItem: T) &#123;</span><br><span class="line">  // 数据交给了ReceiverSupervisor</span><br><span class="line">   supervisor.pushSingle(dataItem)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3-2-ReceiverSupervisor"><a href="#3-2-ReceiverSupervisor" class="headerlink" title="3.2 ReceiverSupervisor"></a>3.2 ReceiverSupervisor</h3><p>ReceiverSupervisor只有一个实现类ReceiverSupervisorImpl，它运行在executor上，启动时会一同启动Receiver。并将接收到的数据存储起来，然后将数据信息汇报到ReceiverTracker，下面是其主要的方法和属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private val receivedBlockHandler: ReceivedBlockHandler</span><br><span class="line">private val trackerEndpoint </span><br><span class="line">private val endpoint </span><br><span class="line">private val registeredBlockGenerators = new ConcurrentLinkedQueue[BlockGenerator]()</span><br><span class="line">private val  defaultBlockGeneratorListener</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>receivedBlockHandler<br>主要有两种实现：</p>
<ul>
<li>WriteAheadLogBasedBlockHandler， 对于receiver转过来的数据，使用WAL的方式保存，当出错重启时可以从中恢复，确保可靠性。</li>
<li>BlockManagerBasedBlockHandler，使用blockmanager来管理数据。</li>
</ul>
<p>WAL的方式的好处是数据写在hdfs中，当driver application意外退出是，数据也不会丢失，使用blockmanager的话如果driver application失败了，或者executor所在node没了，都有可能导致数据丢失。<br>通过<code>spark.streaming.receiver.writeAheadLog.enable</code>设置使用WAL的方式，使用WAL方式时，数据同时也会使用blockmanager管理。</p>
</li>
<li><p>trackerEndpoint，是由ReceiverTracker 的rpc服务的引用，用来和ReceiverTracker通信（Spark Rpc原理参考<a href="http://www.jianshu.com/p/7da49e332e70" target="_blank" rel="noopener">spark rpc原理</a>）</p>
</li>
<li>endpoint，ReceiverSupervisor自身提供的一些rpc服务，接收的消息主要有：<ul>
<li>StopReceiver， 停止Receiver，ReceiverSupervisor</li>
<li>对receivedBlockHandler保存下来的数据做一些清除工作</li>
</ul>
</li>
<li><p>registeredBlockGenerators<br>有时候receiver每次只上报一条数据，显然为一条数据创建一个block id取管理是低效的，registeredBlockGenerators就是用来汇集那些一条条上报的数据，达到一定大小后交给ReceiverSupervisor去保存成一个block</p>
</li>
<li><p>defaultBlockGeneratorListener，这个listener下面讲BlockGenerator会讲到，BlockGenerator讲汇集好的block再转交给ReceiverSupervisor时就是用这个listener会调完成的。</p>
</li>
</ol>
<h4 id="3-2-1-BlockGenerator"><a href="#3-2-1-BlockGenerator" class="headerlink" title="3.2.1 BlockGenerator"></a>3.2.1 BlockGenerator</h4><p>上面4中，ReceiverSupervisor启动时会默认注册一个defaultBlockGenerator，其类就是BlockGenerator。<br>这个类有如下一些成员：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private[streaming] class BlockGenerator(</span><br><span class="line">      listener: BlockGeneratorListener,</span><br><span class="line">      receiverId: Int,</span><br><span class="line">      conf: SparkConf,</span><br><span class="line">      clock: Clock = new SystemClock()</span><br><span class="line">    ) extends RateLimiter(conf) with Logging &#123;</span><br><span class="line">...</span><br><span class="line">private val blockIntervalTimer =</span><br><span class="line">    new RecurringTimer(clock, blockIntervalMs, updateCurrentBuffer, &quot;BlockGenerator&quot;)</span><br><span class="line"> </span><br><span class="line">  private val blocksForPushing = new ArrayBlockingQueue[Block](blockQueueSize)</span><br><span class="line">  private val blockPushingThread = new Thread() &#123; override def run() &#123; keepPushingBlocks() &#125; &#125;</span><br><span class="line">  @volatile private var currentBuffer = new ArrayBuffer[Any]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ol>
<li>listener, 创建时由ReceiverSupervisor传递的，也就是上面5中的defaultBlockGeneratorListener </li>
<li>blockIntervalTimer,前面说blockGenerator用来将一条条转过来的数据汇集成一个个block，这个定时器每隔一段时间(blockIntervalMs)汇集一次数据</li>
<li>blocksForPushing，数据被汇集成block后，先暂存在这里，等待转交给ReceiverSupervisor保存并汇报</li>
<li>blockPushingThread，线程不停的讲blocksForPushing中的block转交给ReceiverSupervisor</li>
<li>currentBuffer,receiver发过来的一条条数据先暂时存在这里，等待blockIntervalTimer汇集一起成block。</li>
</ol>
<p>下图描述了数据从receiver到ReceiverTracker的流程</p>
<p><img src="image/spark-streaming/spark-streaming-procedure.png" alt=""></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Li Weisheng</p>
              <p class="site-description motion-element" itemprop="description">不积跬步，无以至千里</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">20</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Li Weisheng</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
