<!DOCTYPE html>



  


<html class="theme-next mist use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="不积跬步，无以至千里">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://yoursite.com/page/3/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="不积跬步，无以至千里">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Hexo">
<meta name="twitter:description" content="不积跬步，无以至千里">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Mist',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/page/3/"/>





  <title>Hexo</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/17/Spring生命周期管理/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Li Weisheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/17/Spring生命周期管理/" itemprop="url">Spring生命周期管理</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-17T21:22:45+08:00">
                2017-10-17
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>本文主要记录一下Spring中bean的生命周期，即从bean实例化到最终销毁的过程中一些重要的节点，以及Spring提供的在bean这些节点过程中的一些操作。</p>
<h2 id="2-Bean生命周期"><a href="#2-Bean生命周期" class="headerlink" title="2. Bean生命周期"></a>2. Bean生命周期</h2><p>如下图所示:</p>
<p><img src="/image/spring/spring-lifecycle.png" alt="Spring生命周期.png"></p>
<h3 id="2-1-BeanFactoryPostProcessor"><a href="#2-1-BeanFactoryPostProcessor" class="headerlink" title="2.1  BeanFactoryPostProcessor"></a>2.1  BeanFactoryPostProcessor</h3><p>该接口有如下方法:<br>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">postProcessBeanFactory</span><span class="params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="keyword">throws</span> BeansException</span>;</span><br></pre></td></tr></table></figure></p>
<p>   该接口的实现类最先被实例化，它是一个spring容器级别的后置处理器，尽管此时所有的bean都没有被实例化出来，但是bean的配置文件已经被分析完，所有的bean的定义信息(spring中使用类BeanDefinition表示)已经加载，可以通过<code>ConfigurableListableBeanFactory  # getBeanDefinition(String beanName)</code>获取，获取到BeanDefiniton意味着你可以修改bean的属性了。</p>
<p><strong>BeanFactoryPostProcessor 的一些实现类</strong></p>
<ol>
<li><p>PropertyPlaceholderConfigurer<br>这个很多人用过，从key=value形式的配置文件中加载配置信息，并通过${propertyName}的形式设置到bean属性上，如下面这种形式:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span></span></span><br><span class="line"><span class="tag">         <span class="attr">location</span>=<span class="string">"classpath:db.properties"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">file-encoding</span>=<span class="string">"utf8"</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.driver&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.url&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.user&#125;"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;db.password&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注：</strong>上面使用了简易的形式<context:property-placeholder ...="">, 这种情况下会创建<code>PropertyPlaceholderConfigurer</code>对应的bean。关于<context>命名空间，请看 <strong>附录1</strong></context></context:property-placeholder></p>
</li>
<li><p>PropertyOverrideConfigurer<br>这个和 <code>PropertyPlaceholderConfigurer</code>一样将bean的属性卸载properties文件中，用法如下:</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">首先假设在db.properties中如下内容:</span><br><span class="line">dataSource.username=root</span><br><span class="line">dataSource.password=root</span><br><span class="line">同样是name=value的形式，但是name必须是<span class="tag">&lt;<span class="name">beanName</span>&gt;</span>.<span class="tag">&lt;<span class="name">beanPropertyName</span>&gt;</span>格式</span><br><span class="line"></span><br><span class="line">然后在applicationContext.xml中如下定义bean即可:</span><br><span class="line"> <span class="comment">&lt;!--这个命名空间会加载PropertyOverrideConfigurer--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-override</span> <span class="attr">location</span>=<span class="string">"db.properties"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--bean id需要和db.properties中beanName一样--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span>   </span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">PropertyOverrideConfigurer这个后置处理器会根据db.properties中dataSource这个bean的名字找到属性，然后填充到dataSource这个bean中</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-2-BeanPostProcessor"><a href="#2-2-BeanPostProcessor" class="headerlink" title="2.2 BeanPostProcessor"></a>2.2 BeanPostProcessor</h3><p>BeanPostProcessor有两个接口方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Object <span class="title">postProcessBeforeInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br><span class="line"><span class="function">Object <span class="title">postProcessAfterInitialization</span><span class="params">(Object bean, String beanName)</span> <span class="keyword">throws</span> BeansException</span>;</span><br></pre></td></tr></table></figure></p>
<p>BeanPostProcessor在普通bean实例化之前就就创建了，但是他的两个接口方法在却在普通bean实例化(即创建bean类的对象)，通过setter完成了属性注入之后调用，这两个方法在bean初始化前后调用(bean初始化是指调用xml中bean定义中init-method指定的方法，或者bean实现了InitializingBean接口，调用接口方法)，详细的可见上图。</p>
<p><strong>BeanPostProcessor的一些实现类</strong></p>
<ol>
<li>AutowiredAnnotationBeanPostProcessor<br>用于使用<code>@Autowired</code>和<code>@Value</code>注解的解析</li>
<li>RequiredAnnotationBeanPostProcessor<br>用于使用<code>@Require</code>注解的解析</li>
<li><p>CommonAnnotationBeanPostProcessor<br>用于使用<code>@Resource</code>, <code>@PostConstruct</code>,<code>@PreDestroy</code>注解的解析。</p>
<blockquote>
<p>上面三类在在基于注解的方式装配bean时经常使用，当在xml文件里配置<code>&lt;context:annotation-config /&gt;</code>时，spring会创建上面三类PostProcessor，同样属于context空间，参考 <strong>附录1</strong></p>
</blockquote>
</li>
<li>ScheduledAnnotationBeanPostProcessor<br>用于使用了<code>@Scheduled</code>注解的方法的解析，在xml中添加<code>&lt;task:annotation-driven&gt;</code>时会创建这个PostProcessor, 如下例所示:<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">  <span class="tag">&lt;<span class="name">beans</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">task:annotation-driven</span> <span class="attr">scheduler</span>=<span class="string">"taskScheduler"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">task:scheduler</span> <span class="attr">id</span>=<span class="string">"taskScheduler"</span> <span class="attr">pool-size</span>=<span class="string">"42"</span>/&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">task:scheduled-tasks</span> <span class="attr">scheduler</span>=<span class="string">"taskScheduler"</span>&gt;</span></span><br><span class="line">          <span class="tag">&lt;<span class="name">task:scheduled</span> <span class="attr">ref</span>=<span class="string">"myTask"</span> <span class="attr">method</span>=<span class="string">"work"</span> <span class="attr">fixed-rate</span>=<span class="string">"1000"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">task:scheduled-tasks</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myTask"</span> <span class="attr">class</span>=<span class="string">"com.foo.MyTask"</span>/&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br><span class="line">这个例子来自于spring代码@EnableScheduling注释</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="2-3-ApplicationContextAware"><a href="#2-3-ApplicationContextAware" class="headerlink" title="2.3 ApplicationContextAware"></a>2.3 ApplicationContextAware</h3><p>它只有一个接口方法<code>setApplicationContext(ApplicationContext apc)</code>,  实现它的bean而言，apc即该bean运行时所处的applicationContext，上图没有画出它的调用时机，它在<code>BeanFactoryAware # setBeanFactory</code>之后调用。</p>
<h2 id="附录1-context命名空间"><a href="#附录1-context命名空间" class="headerlink" title="附录1 - context命名空间"></a>附录1 - context命名空间</h2><p>在<code>spring-context</code>的jar包中META-INF目录下有文件‘spring.handlers’中有这样一行<code>http\://www.springframework.org/schema/context=org.springframework.context.config.ContextNamespaceHandler</code>, context命名空间加载了类<code>ContextNamespaceHandler</code>，下面是这个类的init方法:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">	<span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">"property-placeholder"</span>, <span class="keyword">new</span> PropertyPlaceholderBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">"property-override"</span>, <span class="keyword">new</span> PropertyOverrideBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">"annotation-config"</span>, <span class="keyword">new</span> AnnotationConfigBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">"component-scan"</span>, <span class="keyword">new</span> ComponentScanBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">"load-time-weaver"</span>, <span class="keyword">new</span> LoadTimeWeaverBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">"spring-configured"</span>, <span class="keyword">new</span> SpringConfiguredBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">"mbean-export"</span>, <span class="keyword">new</span> MBeanExportBeanDefinitionParser());</span><br><span class="line">		registerBeanDefinitionParser(<span class="string">"mbean-server"</span>, <span class="keyword">new</span> MBeanServerBeanDefinitionParser());</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure></p>
<p>包含了context这个命名空间下所有子元素对应的Parser, 这写parser负责解析xml元素，然后创建对应BeanDefinition</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/10/08/HIVE-之UDF/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Li Weisheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/10/08/HIVE-之UDF/" itemprop="url">HIVE 之UDF</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-10-08T09:52:54+08:00">
                2017-10-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>因为最近工作中有需要自定义udf，所以本文记录下最近所了解到的udf的知识。主要讲述hive中如何自定义udf，至于udf一些原理性的东西，比如udf在mr过程中怎么起作用的，这个涉及到hive的细节，我也不清楚，所以本文不会涉及，知道多少写多少吧。</p>
<h1 id="2-UDF分类"><a href="#2-UDF分类" class="headerlink" title="2. UDF分类"></a>2. UDF分类</h1><p>hive中udf主要分为三类：</p>
<ol>
<li>标准UDF<br>这种类型的udf每次接受的输入是一行数据中的一个列或者多个列（下面我把这个一行的一列叫着一个单元吧，类似表格中的一个单元格），然后输出是一个单元。比如abs, array,asin这种都是标准udf。<br>自定义标准函数需要继承实现抽象类<code>org.apache.hadoop.hive.ql.udf.generic.GenericUDF</code></li>
<li>自定义聚合函数(UDAF)<br>比如max，min这种函数都是hive内置聚合函数。聚合函数和标准udf的区别是：聚合函数需要接收多行输入才能计算出结果，比如max就需要接收表中所有数据（或者group by中分组内所有数据）才能计算出最大值。<br>自定义聚合函数需要实现抽象类<code>org.apache.hadoop.hive.ql.udf.generic.AbstractGenericUDAFResolver</code></li>
<li>自定义表生成函数(UDTF)<br>  上面1，2中的udf都只输出一个标量的数据（一个单元）。表生成函数故名思义，其输出有点像子查询，可以一次输出多行多列。<br>自定义表生成函数需要实现抽象类<code>org.apache.hadoop.hive.ql.udf.generic.GenericUDTF</code>。</li>
</ol>
<p>#2. 自定义UDF<br>引入maven依赖<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.apache.hive&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;hive-exec&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;2.3.0&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-1-自定义标准UDF"><a href="#2-1-自定义标准UDF" class="headerlink" title="2.1 自定义标准UDF"></a>2.1 自定义标准UDF</h2><h3 id="2-1-1-实现抽象类GenericUDF"><a href="#2-1-1-实现抽象类GenericUDF" class="headerlink" title="2.1.1 实现抽象类GenericUDF"></a>2.1.1 实现抽象类GenericUDF</h3><p>该类的全路径为:<code>org.apache.hadoop.hive.ql.udf.generic.GenericUDF</code><br><strong>1.  抽象类GenericUDF解释</strong><br>GenericUDF类如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericUDF</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="comment">/* 实例化后initialize方法只会调用一次</span></span><br><span class="line"><span class="comment">        - 参数arguments即udf接收的参数列表对应的objectinspector</span></span><br><span class="line"><span class="comment">        - 返回的ObjectInspector对象就是udf返回值的对应的objectinspector</span></span><br><span class="line"><span class="comment">      initialize方法中往往做的工作是检查一下arguments是否和你udf需要的参数个数以及类型是否匹配。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">     </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> ObjectInspector <span class="title">initialize</span><span class="params">(ObjectInspector[] arguments)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> UDFArgumentException</span>;</span><br><span class="line">     ...</span><br><span class="line">      <span class="comment">// 真正的udf逻辑在这里实现</span></span><br><span class="line">      <span class="comment">// - 参数arguments即udf函数输入数据，这个数组的长度和initialize的参数长度一样</span></span><br><span class="line">      <span class="comment">// </span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">evaluate</span><span class="params">(DeferredObject[] arguments)</span></span></span><br><span class="line"><span class="function">      <span class="keyword">throws</span> HiveException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>GenericUDF有很多的方法，但是只有上面两个抽象方法需要自己实现。<br>关于ObjectInspector，HIVE在传递数据时会包含数据本身以及对应的ObjectInspector，ObjectInspector中包含数据类型信息，通过oi去解析获得数据。</p>
<h3 id="2-1-2-实例"><a href="#2-1-2-实例" class="headerlink" title="2.1.2 实例"></a>2.1.2 实例</h3><p>假设这里要实现下面这种功能标准udf：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">cycle_range(col_name, num)</span><br><span class="line">它的接收一列，以及一了整数值为参数，然后将这列转换为一个index（index 属于[0,num)）到列值的映射，像下面这样:</span><br><span class="line">&gt; SELECT cycle_range(name, 3) FROM src_table;</span><br><span class="line">   INDEX NAME</span><br><span class="line">   &#123;1, &quot;eric&quot;&#125;</span><br><span class="line">   &#123;2, &quot;aaron&quot;&#125;</span><br><span class="line">   &#123;0, &quot;john&quot;&#125;</span><br><span class="line">   &#123;1, &quot;marry&quot;&#125;</span><br><span class="line">   &#123;2, &quot;hellen&quot;&#125;</span><br><span class="line">   &#123;0, &quot;jerry&quot;&#125;</span><br><span class="line">   &#123;1, &quot;ellen&quot;&#125;</span><br><span class="line">   ...</span><br></pre></td></tr></table></figure></p>
<p>这里定义一个叫cycle_range的标准udf去实现列值的转换，实现如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  这里使用注解描述udf信息，当使用beeline命令'describe function cycle_range'时，会输出value中的介绍信息，其中_FUNC_会被替换成真实的udf名称。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Description</span>(name = <span class="string">"cycle_range"</span>,</span><br><span class="line">    value = <span class="string">"_FUNC_(x, num) - return a map containes an index as key and x as value"</span>,</span><br><span class="line">    extended = <span class="string">"Example:\n"</span></span><br><span class="line">        + <span class="string">" &gt; SELECT _FUNC_(x, 3) FROM src;\n"</span></span><br><span class="line">        + <span class="string">"&#123;i,x&#125;, i in [0 - 3)\n"</span></span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericUDFRange</span> <span class="keyword">extends</span> <span class="title">GenericUDF</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第二个参数是一个整型常量，放在这里</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> LongWritable rangeNum = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// index 递增并对rangeNum取模的结果</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Long index = <span class="number">0L</span>;</span><br><span class="line">    <span class="comment">// udf 返回值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> Map&lt;Object,Object&gt; ret = <span class="keyword">new</span> HashMap&lt;Object,Object&gt;();</span><br><span class="line">    <span class="comment">// udf参数整型常量可以是BYTE/SHORT/INT/LONG 这个converter将它们都转换成long处理</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">transient</span> ObjectInspectorConverters.Converter rangeConverter;</span><br><span class="line">    <span class="comment">// 在inittialize里检查一下参数个数与类型</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ObjectInspector <span class="title">initialize</span><span class="params">(ObjectInspector[] arguments)</span> <span class="keyword">throws</span> UDFArgumentException </span>&#123;</span><br><span class="line">        <span class="comment">// 只接受两个参数</span></span><br><span class="line">        <span class="keyword">if</span>(arguments.length != <span class="number">2</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UDFArgumentException(</span><br><span class="line">                    <span class="string">"RANGE() requires 2 arguments, got "</span> + arguments.length</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 第二个参数必须是PRIMITIVE这一类的，这是hive sql内置的类型，可以对应到java的primitive type，此外还必须是BYTE/SHORT/INT/LONG之一</span></span><br><span class="line">        <span class="keyword">if</span>(arguments[<span class="number">1</span>].getCategory() != ObjectInspector.Category.PRIMITIVE)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UDFArgumentException(</span><br><span class="line">                    <span class="string">"RANGE() only take primitive Integer type, got "</span> + arguments[<span class="number">1</span>].getTypeName()</span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        PrimitiveObjectInspector poi = (PrimitiveObjectInspector)arguments[<span class="number">1</span>];</span><br><span class="line">        <span class="comment">// 获取到第二个参数的具体类型枚举</span></span><br><span class="line">        PrimitiveObjectInspector.PrimitiveCategory rangeNumType = poi.getPrimitiveCategory();</span><br><span class="line">        ObjectInspector outputInspector = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">switch</span> (rangeNumType)&#123;</span><br><span class="line">            <span class="keyword">case</span> BYTE:</span><br><span class="line">            <span class="keyword">case</span> SHORT:</span><br><span class="line">            <span class="keyword">case</span> INT:</span><br><span class="line">            <span class="keyword">case</span> LONG:</span><br><span class="line">                <span class="comment">// 以上4个case是合法类型，获得一个converter将这四类都转换成WritableLong处理</span></span><br><span class="line">                rangeConverter = ObjectInspectorConverters.getConverter(</span><br><span class="line">                        arguments[<span class="number">1</span>], PrimitiveObjectInspectorFactory.writableLongObjectInspector</span><br><span class="line">                );</span><br><span class="line">                <span class="comment">// udf的输出值的oi，输出的是一个map对应的ObjectInspector， key是long，value还是原来的列的oi</span></span><br><span class="line">                outputInspector = ObjectInspectorFactory.getStandardMapObjectInspector(</span><br><span class="line">                        PrimitiveObjectInspectorFactory.javaLongObjectInspector, arguments[<span class="number">0</span>]);</span><br><span class="line">                <span class="keyword">return</span> outputInspector;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UDFArgumentException(</span><br><span class="line">                        <span class="string">"RANGE only takes BYTE/SHORT/INT/LONG types as the second arguments type, got "</span> + arguments[<span class="number">1</span>].getTypeName()</span><br><span class="line">                );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 这里开始接收实际的一行一行的输入数据，然后返回处理后的值</span></span><br><span class="line">    <span class="comment">// deferredObjects应该包含两个值，第一个值是列的值，第二个值是那个整型常量range值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">evaluate</span><span class="params">(DeferredObject[] deferredObjects)</span> <span class="keyword">throws</span> HiveException </span>&#123;</span><br><span class="line">        <span class="comment">// 拿到range值</span></span><br><span class="line">        Object rangeObject = deferredObjects[<span class="number">1</span>].get();</span><br><span class="line">        <span class="keyword">if</span>(rangeNum == <span class="keyword">null</span>)&#123;</span><br><span class="line">            rangeNum = <span class="keyword">new</span> LongWritable();</span><br><span class="line">            <span class="comment">// 用coverter都转换成LongWritable，然后保存起来.</span></span><br><span class="line">            rangeObject = rangeConverter.convert(rangeObject);</span><br><span class="line">            rangeNum.set(Math.abs(((LongWritable)rangeObject).get()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 计算index 对range的模</span></span><br><span class="line">        index = (index + <span class="number">1</span>) %    rangeNum.get();</span><br><span class="line">        <span class="comment">// 由于ret是这个udf实例的成员，用来保存返回的map，而evaluate又会不停的调用，所以这里put前都会clear一下，保证始终只有当前处理后的返回值。</span></span><br><span class="line">        ret.clear();</span><br><span class="line">        <span class="comment">// 设置返回值，返回</span></span><br><span class="line">        ret.put(index, deferredObjects[<span class="number">0</span>].get());</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getDisplayString</span><span class="params">(String[] strings)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getStandardDisplayString(<span class="string">"range"</span>, strings,<span class="string">","</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>编写好后：</p>
<ol>
<li>打jar包，最好打fat jar，把依赖都打进去，假设我的jar包的路径:”/Users/eric/udf-1.0-SNAPSHOT.jar”</li>
<li>在beeline 终端将jar加入hive的classpath：<br><code>add jar /Users/eric/udf-1.0-SNAPSHOT.jar</code></li>
<li>创建udf<br> <code>create temporary function cycle_range as &#39;me.eric.udfs.GenericUDFRange&#39;</code></li>
</ol>
<p>成功后就可以使用了。</p>
<h2 id="2-2-自定义聚合函数UDAF"><a href="#2-2-自定义聚合函数UDAF" class="headerlink" title="2.2 自定义聚合函数UDAF"></a>2.2 自定义聚合函数UDAF</h2><p>###2.2.1 实现抽象类AbstractGenericUDAFResolver<br>实现自定义UDAF首先要继承并实现类<code>AbstractGenericUDAFResolver</code>,有下面两个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractGenericUDAFResolver</span></span></span><br><span class="line"><span class="class">    <span class="keyword">implements</span> <span class="title">GenericUDAFResolver2</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> GenericUDAFEvaluator <span class="title">getEvaluator</span><span class="params">(GenericUDAFParameterInfo info)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SemanticException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (info.isAllColumns()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> SemanticException(</span><br><span class="line">          <span class="string">"The specified syntax for UDAF invocation is invalid."</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> getEvaluator(info.getParameters());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">    由于上面的getEvaluator也是调用的这个方法实现，所以只需要重写着这个</span></span><br><span class="line"><span class="comment">    getEvaluator即可。 udaf函数的主要逻辑不是getEvaluator方法里里完成的。</span></span><br><span class="line"><span class="comment">    而是在其返回的GenericUDAFEvaluator中实现的，那么在getEvaluator方法中往往只需要根据参数info(info中保存了传递给udaf的实际参数信息)做一下udaf的参数类型检查即可，</span></span><br><span class="line"><span class="comment">    然后返回用户自定义的GenericUDAFEvaluator。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> GenericUDAFEvaluator <span class="title">getEvaluator</span><span class="params">(TypeInfo[] info)</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> SemanticException </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> SemanticException(</span><br><span class="line">          <span class="string">"This UDAF does not support the deprecated getEvaluator() method."</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面介绍中说到GenericUDAFEvaluator才是真正实现udaf业务逻辑的地方，下面是GenericUDAFEvaluator抽象类的的实现:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericUDAFEvaluator</span> <span class="keyword">implements</span> <span class="title">Closeable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="meta">@interface</span> AggregationType &#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">estimable</span><span class="params">()</span> <span class="keyword">default</span> <span class="keyword">false</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">enum</span> Mode &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * PARTIAL1: from original data to partial aggregation data: iterate() and</span></span><br><span class="line"><span class="comment">     * terminatePartial() will be called.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PARTIAL1,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * PARTIAL2: from partial aggregation data to partial aggregation data:</span></span><br><span class="line"><span class="comment">     * merge() and terminatePartial() will be called.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    PARTIAL2,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * FINAL: from partial aggregation to full aggregation: merge() and</span></span><br><span class="line"><span class="comment">     * terminate() will be called.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    FINAL,</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * COMPLETE: from original data directly to full aggregation: iterate() and</span></span><br><span class="line"><span class="comment">     * terminate() will be called.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    COMPLETE</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">Mode mode;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> ObjectInspector <span class="title">init</span><span class="params">(Mode m, ObjectInspector[] parameters)</span> <span class="keyword">throws</span> HiveException </span>&#123;</span><br><span class="line">    <span class="comment">// This function should be overriden in every sub class</span></span><br><span class="line">    <span class="comment">// And the sub class should call super.init(m, parameters) to get mode set.</span></span><br><span class="line">    mode = m;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> AggregationBuffer <span class="title">getNewAggregationBuffer</span><span class="params">()</span> <span class="keyword">throws</span> HiveException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(AggregationBuffer agg)</span> <span class="keyword">throws</span> HiveException</span>;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aggregate</span><span class="params">(AggregationBuffer agg, Object[] parameters)</span> <span class="keyword">throws</span> HiveException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mode == Mode.PARTIAL1 || mode == Mode.COMPLETE) &#123;</span><br><span class="line">      iterate(agg, parameters);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">assert</span> (parameters.length == <span class="number">1</span>);</span><br><span class="line">      merge(agg, parameters[<span class="number">0</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Object <span class="title">evaluate</span><span class="params">(AggregationBuffer agg)</span> <span class="keyword">throws</span> HiveException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mode == Mode.PARTIAL1 || mode == Mode.PARTIAL2) &#123;</span><br><span class="line">      <span class="keyword">return</span> terminatePartial(agg);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> terminate(agg);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">iterate</span><span class="params">(AggregationBuffer agg, Object[] parameters)</span> <span class="keyword">throws</span> HiveException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">terminatePartial</span><span class="params">(AggregationBuffer agg)</span> <span class="keyword">throws</span> HiveException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(AggregationBuffer agg, Object partial)</span> <span class="keyword">throws</span> HiveException</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Object <span class="title">terminate</span><span class="params">(AggregationBuffer agg)</span> <span class="keyword">throws</span> HiveException</span>;</span><br></pre></td></tr></table></figure></p>
<p>首先是上面枚举类型Mode的几个枚举值：PARTIAL1，PARTIAL2，FINAL，COMPLETE,  同时mode也是方法init的参数。这几个枚举值跟聚合涉及到的过程有关系， map-reduce中聚合往往涉及到shuffle的过程，这其中又可能涉及到map端的combine，然后map到reduce过程中数据的shuffle，然后在在reduce端merge。<br>下面这张图大概的描述了一下各个阶段的对应关系：</p>
<p><img src="/image/hive/hive-udaf.png" alt="hive-udaf"><br>这张图中没有包含COMPLETE，从上面代码中COMPLETE的注释可以看出来，COMPLETE表示直接从原始数据聚合到最终结果，也就是说不存在中间需要先在map端完成部分聚合结果，然后再到reduce端完成最终聚合一个过程，COMPLETE出现在一个完全map only的任务中，所以没有和其他三个阶段一起出现。</p>
<p>上图描述了三个阶段调用的方法,这也就是需要自己实现的方法：</p>
<ol>
<li>PARTIAL1<ul>
<li>iterate(AggregationBuffer agg, Object[] parameters)<br>AggregationBuffer是一个需要你实现的数据结构，用来临时保存聚合的数据，parameters是传递给udaf的实际参数，这个方法的功能可以描述成: 拿到一条条数据记录方法在parameters里，然后聚合到agg中，怎么聚合自己实现，比如agg就是一个数组，你把所有迭代的数据保存到数组中都可以。agg相当于返回结果，</li>
<li>terminatePartial(AggregationBuffer agg)<br> iterate迭代了map中的数据并保存到agg中，并传递给terminatePartial，接下来terminatePartial完成计算，terminatePartial返回Object类型结果显然还是要传递给下一个阶段PARTIAL2的，但是PARTIAL2怎么知道Object到底是什么？前面提到HIVE都是通过ObjectInspector来获取数据类型信息的，但是PARTIAL2的输入数据ObjectInspector怎么来的？显然每个阶段输出数据对应的ObjectInspector只有你自己知道，上面代码中还有一个init()方法是需要你实现了(init在每一个阶段都会调用一次 )，init的参数m表明了当前阶段(当前处于PARTIAL1)，你需要在init中根据当前阶段m，设置一个ObjectInspector表示当前的输出oi就行了，init返回一个ObjectInspcetor表示当前阶段的输出数据类信息（也就是下一阶段的输入数据信息）。</li>
</ul>
</li>
<li>PARTIAL2<br> PARTIAL2的输入是基于PARTIAL1的输出的，PARTIAL1输出即terminatePartial的返回值。<ul>
<li>merge(AggregationBuffer agg, Object partial)<br> agg和partial1中的一样，既是参数，也是返回值。partial就是partial1中terminatePartial的返回值，partial的具体数据信息需要你根据ObjectInspector获取了。merger就表示把partial值先放到agg里，待会计算。</li>
<li>terminatePartial<br>和partial1一样。</li>
</ul>
</li>
<li>FINAL<br> FINAL进入到reduce阶段，也就是要完成最终结果的计算，和PARTIAL2不同的是它调用terminate，没什么好说的，输出最终结果而已。</li>
</ol>
<p>关于init方法，方法原型:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ObjectInspector <span class="title">init</span><span class="params">(Mode m, ObjectInspector[] parameters)</span></span></span><br></pre></td></tr></table></figure></p>
<p>这个方法会在每个阶段都会调用一次，参数m表示当前调用的阶段，parameters表示当前阶段输入数据的oi。前面提到partial1的terminatePartial的输出就是partial2的输入数据，那么此时partial1的输出数据对应的oi，应该和partial2时调用init的参数parameters对应起来才能保存不出错。</p>
<p>###2.2.1 UDAF实例<br>这里实现的udaf的实例，他完成如下功能:<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; SELECT col_concat(id,  '&lt;' ,  '&gt;',  ',' ) FROM person;</span><br><span class="line">输出:</span><br><span class="line">&lt;1,2,3,4,5,6&gt;</span><br><span class="line">udaf实现将某一个使用特定符号连接起来，并使用另外的字符包围左右。</span><br><span class="line">第一个参数就是列名，然后open，close，seperator</span><br></pre></td></tr></table></figure></p>
<p>代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericUDAFColConcat</span> <span class="keyword">extends</span> <span class="title">AbstractGenericUDAFResolver</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">GenericUDAFColConcat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     在getEvaluator中做一些类型检查，</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> GenericUDAFEvaluator <span class="title">getEvaluator</span><span class="params">(TypeInfo[] parameters)</span> <span class="keyword">throws</span> SemanticException </span>&#123;</span><br><span class="line">         <span class="comment">// col_concat这个udaf需要接收4个参数</span></span><br><span class="line">        <span class="keyword">if</span>(parameters.length != <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UDFArgumentTypeException(parameters.length - <span class="number">1</span>,</span><br><span class="line">                    <span class="string">"COL_CONCAT requires 4 argument, got "</span> + parameters.length);</span><br><span class="line">        &#125;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">// 且只能用于连接一下PRIMITIVE类型的列</span></span><br><span class="line">        <span class="keyword">if</span>(parameters[<span class="number">0</span>].getCategory() != ObjectInspector.Category.PRIMITIVE)&#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UDFArgumentTypeException(<span class="number">0</span>,</span><br><span class="line">                    <span class="string">"COL_CONCAT can only be used to concat PRIMITIVE type column, got "</span> + parameters[<span class="number">0</span>].getTypeName());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 分隔符和包围符，只能时char或者STRING</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; parameters.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(parameters[i].getCategory() != ObjectInspector.Category.PRIMITIVE)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UDFArgumentTypeException(i,</span><br><span class="line">                        <span class="string">"COL_CONCAT only receive type CHAR/STRING as its 2nd to 4th argument's type, got "</span> + parameters[i].getTypeName());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            PrimitiveObjectInspector poi = (PrimitiveObjectInspector) TypeInfoUtils.getStandardJavaObjectInspectorFromTypeInfo(parameters[i]);</span><br><span class="line">            <span class="keyword">if</span>(poi.getPrimitiveCategory() != PrimitiveObjectInspector.PrimitiveCategory.CHAR &amp;&amp;</span><br><span class="line">                    poi.getPrimitiveCategory() != PrimitiveObjectInspector.PrimitiveCategory.STRING)&#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> UDFArgumentTypeException(i,</span><br><span class="line">                        <span class="string">"COL_CONCAT only receive type CHAR/STRING as its 2nd to 4th argument's type, got "</span> + parameters[i].getTypeName());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 返回自定义的XXXEvaluator</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> GenericUDAFCOLCONCATEvaluator();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">     <span class="comment">// 前一节也说过需要实现AbstractAggregationBuffer用来保存聚合的值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ColCollectAggregationBuffer</span> <span class="keyword">extends</span> <span class="title">GenericUDAFEvaluator</span>.<span class="title">AbstractAggregationBuffer</span></span>&#123;</span><br><span class="line">        <span class="comment">// 遍历的列值暂时都方放到列表中保存起来。</span></span><br><span class="line">        <span class="keyword">private</span> List&lt;String&gt; colValueList ;</span><br><span class="line">        <span class="keyword">private</span> String open;</span><br><span class="line">        <span class="keyword">private</span> String close;</span><br><span class="line">        <span class="keyword">private</span> String seperator;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isInit;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">ColCollectAggregationBuffer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            colValueList = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">            <span class="keyword">this</span>.isInit = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(String open, String close, String seperator)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.open = open;</span><br><span class="line">            <span class="keyword">this</span>.close = close;</span><br><span class="line">            <span class="keyword">this</span>.seperator = seperator;</span><br><span class="line">            <span class="keyword">this</span>.isInit = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInit</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> isInit;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">concat</span><span class="params">()</span></span>&#123;</span><br><span class="line">            String c = StringUtils.join(colValueList,seperator);</span><br><span class="line">            <span class="keyword">return</span> open + c + close;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">GenericUDAFCOLCONCATEvaluator</span> <span class="keyword">extends</span> <span class="title">GenericUDAFEvaluator</span></span>&#123;</span><br><span class="line">        <span class="comment">// transient避免序列化，因为这些成员其实都是在init中初始化了，没有序列化的意义</span></span><br><span class="line">        <span class="comment">// inputOIs用来保存PARTIAL1和COMPELE输入数据的oi，这个各个阶段都可能不一样</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> List&lt;ObjectInspector&gt; inputOIs = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> Mode m;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> String pString;</span><br><span class="line">        <span class="comment">// soi保存PARTIAL2和FINAL的输入数据的oi</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> StructObjectInspector soi;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> ListObjectInspector valueFieldOI;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> PrimitiveObjectInspector openFieldOI;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> PrimitiveObjectInspector closeFieldOI;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> PrimitiveObjectInspector seperatorFieldOI;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> StructField valueField;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> StructField openField;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> StructField closeField;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">transient</span> StructField seperatorField;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> ObjectInspector <span class="title">init</span><span class="params">(Mode m, ObjectInspector[] parameters)</span> <span class="keyword">throws</span> HiveException </span>&#123;</span><br><span class="line">            <span class="comment">// 父类的init必须调用</span></span><br><span class="line">            <span class="keyword">super</span>.init(m,parameters);</span><br><span class="line">            <span class="keyword">this</span>.m = m;</span><br><span class="line">            pString = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(ObjectInspector p : parameters)&#123;</span><br><span class="line">                pString += p.getTypeName();</span><br><span class="line">            &#125;</span><br><span class="line">           </span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(m == Mode.PARTIAL1 || m == Mode.COMPLETE)&#123;</span><br><span class="line">                <span class="comment">// 在PARTIAL1和COMPLETE阶段，输入数据都是原始表中数据，而不是中间聚合数据，这里初始化inputOIs</span></span><br><span class="line">                inputOIs.clear();</span><br><span class="line">                <span class="keyword">for</span>(ObjectInspector p : parameters)&#123;</span><br><span class="line">                    inputOIs.add((PrimitiveObjectInspector)p);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// FINAL和PARTIAL2的输入数据OI都是上一阶段的输出，而不是原始表数据，这里parameter[0]其实就是上一阶段的输出oi，具体情况看下面</span></span><br><span class="line">                soi = (StructObjectInspector)parameters[<span class="number">0</span>];</span><br><span class="line">                valueField = soi.getStructFieldRef(<span class="string">"values"</span>);</span><br><span class="line">                valueFieldOI = (ListObjectInspector)valueField.getFieldObjectInspector();</span><br><span class="line">                openField = soi.getStructFieldRef(<span class="string">"open"</span>);</span><br><span class="line">                openFieldOI = (PrimitiveObjectInspector) openField.getFieldObjectInspector();</span><br><span class="line">                closeField = soi.getStructFieldRef(<span class="string">"close"</span>);</span><br><span class="line">                closeFieldOI = (PrimitiveObjectInspector)closeField.getFieldObjectInspector();</span><br><span class="line">                seperatorField = soi.getStructFieldRef(<span class="string">"seperator"</span>);</span><br><span class="line">                seperatorFieldOI = (PrimitiveObjectInspector)seperatorField.getFieldObjectInspector();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="comment">// 这里开始返回各个阶段的输出OI</span></span><br><span class="line">            <span class="keyword">if</span>(m == Mode.PARTIAL1 || m == Mode.PARTIAL2)&#123;</span><br><span class="line">                <span class="comment">// 后面的terminatePartial实现中，PARTIAL1 PARTIAL2的输出数据都是一个列表，我把中间聚合和结果values， 以及open，close， seperator</span></span><br><span class="line">               <span class="comment">// 按序方到列表中，所以这个地方返回的oi是一个StructObjectInspector的实现类，它能够获取list中的值。</span></span><br><span class="line">                ArrayList&lt;ObjectInspector&gt; foi = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">                foi.add(ObjectInspectorFactory.getStandardListObjectInspector(PrimitiveObjectInspectorFactory.javaStringObjectInspector));</span><br><span class="line">                foi.add(</span><br><span class="line">                        PrimitiveObjectInspectorFactory.javaStringObjectInspector</span><br><span class="line">                );</span><br><span class="line">                foi.add(</span><br><span class="line">                        PrimitiveObjectInspectorFactory.javaStringObjectInspector</span><br><span class="line">                );</span><br><span class="line">                foi.add(</span><br><span class="line">                        PrimitiveObjectInspectorFactory.javaStringObjectInspector</span><br><span class="line">                );</span><br><span class="line"></span><br><span class="line">                ArrayList&lt;String&gt; fname = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">                fname.add(<span class="string">"values"</span>);</span><br><span class="line">                fname.add(<span class="string">"open"</span>);</span><br><span class="line">                fname.add(<span class="string">"close"</span>);</span><br><span class="line">                fname.add(<span class="string">"seperator"</span>);</span><br><span class="line">                <span class="keyword">return</span> ObjectInspectorFactory.getStandardStructObjectInspector(fname, foi);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// COMPLETE和FINAL都是返回最终聚合结果了，也就是String，所以这里返回javaStringObjectInspector即可</span></span><br><span class="line">                <span class="keyword">return</span> PrimitiveObjectInspectorFactory.javaStringObjectInspector;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> AggregationBuffer <span class="title">getNewAggregationBuffer</span><span class="params">()</span> <span class="keyword">throws</span> HiveException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> ColCollectAggregationBuffer();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">(AggregationBuffer aggregationBuffer)</span> <span class="keyword">throws</span> HiveException </span>&#123;</span><br><span class="line">            ((ColCollectAggregationBuffer)aggregationBuffer).colValueList.clear();</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// PARTIAL1和COMPLETE调用，iterate里就是把原始数据（参数objects[0]）中的值保存到aggregationBuffer的列表中</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">iterate</span><span class="params">(AggregationBuffer aggregationBuffer, Object[] objects)</span> <span class="keyword">throws</span> HiveException </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> objects.length == <span class="number">4</span>;</span><br><span class="line">            ColCollectAggregationBuffer ccAggregationBuffer = (ColCollectAggregationBuffer)aggregationBuffer;</span><br><span class="line">            ccAggregationBuffer.colValueList.add(</span><br><span class="line">                    PrimitiveObjectInspectorUtils.getString(objects[<span class="number">0</span>], (PrimitiveObjectInspector)inputOIs.get(<span class="number">0</span>)));</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(!ccAggregationBuffer.isInit())&#123;</span><br><span class="line">                ccAggregationBuffer.init(</span><br><span class="line">                        PrimitiveObjectInspectorUtils.getString(objects[<span class="number">1</span>], (PrimitiveObjectInspector)inputOIs.get(<span class="number">1</span>)),</span><br><span class="line">                        PrimitiveObjectInspectorUtils.getString(objects[<span class="number">2</span>],(PrimitiveObjectInspector)inputOIs.get(<span class="number">2</span>)),</span><br><span class="line">                        PrimitiveObjectInspectorUtils.getString(objects[<span class="number">3</span>],(PrimitiveObjectInspector)inputOIs.get(<span class="number">3</span>))</span><br><span class="line">                );</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// PARTIAL1和PARTIAL2调用，没做什么，但是返回的值的一个‘List&lt;Object&gt; partialRet’ 和init中返回的StructObjectInspector对应，</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">terminatePartial</span><span class="params">(AggregationBuffer aggregationBuffer)</span> <span class="keyword">throws</span> HiveException </span>&#123;</span><br><span class="line">            ColCollectAggregationBuffer ccAggregationBuffer = (ColCollectAggregationBuffer)aggregationBuffer;</span><br><span class="line">            List&lt;Object&gt; partialRet = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">            partialRet.add(ccAggregationBuffer.colValueList);</span><br><span class="line">            partialRet.add(ccAggregationBuffer.open);</span><br><span class="line">            partialRet.add(ccAggregationBuffer.close);</span><br><span class="line">            partialRet.add(ccAggregationBuffer.seperator);</span><br><span class="line">            <span class="keyword">return</span> partialRet;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">         <span class="comment">// PARTIAL2和FINAL调用，参数partial对应上面terminatePartial返回的列表，</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(AggregationBuffer aggregationBuffer, Object partial)</span> <span class="keyword">throws</span> HiveException </span>&#123;</span><br><span class="line">            ColCollectAggregationBuffer ccAggregationBuffer = (ColCollectAggregationBuffer)aggregationBuffer;</span><br><span class="line">            <span class="keyword">if</span>(partial != <span class="keyword">null</span>)&#123;</span><br><span class="line">                <span class="comment">// soi在init中初始化了，用它来获取partial中数据。</span></span><br><span class="line">                List&lt;Object&gt; partialList = soi.getStructFieldsDataAsList(partial);</span><br><span class="line">                <span class="comment">// terminalPartial中数据被保存在list中，这个地方拿出来只是简单了合并两个list，其他不变。</span></span><br><span class="line">                List&lt;String&gt; values = (List&lt;String&gt;)valueFieldOI.getList(partialList.get(<span class="number">0</span>));</span><br><span class="line">                ccAggregationBuffer.colValueList.addAll(values);</span><br><span class="line">                <span class="keyword">if</span>(!ccAggregationBuffer.isInit)&#123;</span><br><span class="line">                    ccAggregationBuffer.open = PrimitiveObjectInspectorUtils.getString(partialList.get(<span class="number">1</span>), openFieldOI);</span><br><span class="line">                    ccAggregationBuffer.close = PrimitiveObjectInspectorUtils.getString(partialList.get(<span class="number">2</span>), closeFieldOI);</span><br><span class="line">                    ccAggregationBuffer.seperator = PrimitiveObjectInspectorUtils.getString(partialList.get(<span class="number">3</span>), seperatorFieldOI);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">       <span class="comment">// FINAL和COMPLETE调用，此时aggregationBuffer中用list保存了原始表表中一列的所有值，这里完成连接操作，返回一个string类型的连接结果。</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Object <span class="title">terminate</span><span class="params">(AggregationBuffer aggregationBuffer)</span> <span class="keyword">throws</span> HiveException </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> ((ColCollectAggregationBuffer)aggregationBuffer).concat();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="2-3-自定义表生成函数"><a href="#2-3-自定义表生成函数" class="headerlink" title="2.3 自定义表生成函数"></a>2.3 自定义表生成函数</h2><p>待完成。。。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/22/apache-shiro使用-与spring-boot集成/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Li Weisheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/22/apache-shiro使用-与spring-boot集成/" itemprop="url">apache shiro使用 - 与spring boot集成</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-22T19:24:41+08:00">
                2017-08-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>最近项目中使用到了shiro作为用户身份验证以及访问权限控制的安全框架，本文主要简单介绍一下使用过程。</p>
<p>##2. shiro简介<br>shiro是apache上的一个java实现的开源安全框架，提供了以下基本功能：</p>
<ol>
<li>anthentication，身份认证，比如username/password的验证。</li>
<li>authorization，权限验证，即访问控制，比如restful api中判断某个用户是否拥有GET的权限。</li>
<li>session manager，会话管理，和web中session概念类似。</li>
<li>Cryptography，数据加密传输。<br>shiro的架构图如下：</li>
</ol>
<p><img src="/image/shiro/shiro架构图.png" alt="shiro架构图"></p>
<p><strong>说明</strong></p>
<ol>
<li><p>Subject， shiro Subject可以理解成访问当前程序（当前程序也就是需要使用安全框架保护的程序）的用户，用户可以是web上登录的用户，也可以某个正在试图访问当前程序的调度程序等等。shiro提供的功能可以通过Subject一组方法完成，比如（只列举了一部分）：</p>
<ul>
<li>boolean isPermitted(String permission)</li>
<li>boolean isPermitted(Permission permission)<br>属于shiro的authorization功能，string类型的权限最终也会转换成具体的Permission类，isPermitted用来判断用户（subject）是否具有perssion权限，也就是说当前subject拥有的权限是否是permission的超集。</li>
<li>public void login(AuthenticationToken token)</li>
<li><p>public void logout()<br> shiro的authentication功能。提供用户身份认证。<br> 登录，比如用户使用username/password登录时，可以这样调用：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//获取当前user的Subject</span><br><span class="line">Subject currentUser = SecurityUtils.getSubject();</span><br><span class="line">currentUser.login(new new UsernamePasswordToken(username, password)).</span><br></pre></td></tr></table></figure>
<ul>
<li>Session getSession();<br>获得会话，没有会创建新的。</li>
</ul>
</li>
</ul>
</li>
<li><p>SecurityManager<br> SecurityManager时shiro的核心，从上图可以看出SecurityManager包含了一些组件共同提供了shiro的所有功能，Subject类似更像一个shell，Subject的调用都会走向SecurityManager来完成核心的authentication/authorization/sessionmanager等功能。</p>
</li>
<li><p>Realm<br>上图中Pluggable Realms，shiro中唯一需要我们自己实现的部分，SecurityManager通过authenticato/authorizer替我们完成用户认证以及权限控制，但是验证用户身份时的用户身份信息，验证用户权限时用户的权限信息都需要我们自己定义好告诉shiro，这部分工作就是realm应该完成的，realm因此可以理解成数据源，比如你的用户信息存储在mysql里，那么你自定义的realm就需要从mysql里获得用户省份信息，以及权限信息。</p>
</li>
</ol>
<p>##3. 和spring boot结合<br>在和spring boot结合的过程中，我需要做的主要有以下几个部分：</p>
<ol>
<li>自定义realm，继承抽象类AuthorizingRealm实现它的几个抽象方法获取用户身份信息，以及用户权限信息。我的用户身份信息保存在mysql中。</li>
<li>自定义Permission，实现Permission接口。Permission对应用户的访问权限信息。</li>
<li>实现ShiroConfig类，由于spring boot不像springMVC中从“applicationContext.xml”加载所有bean信息，因此定义了ShiroConfig，并使用<code>@Configuration</code>，通过java标注的方式加载装配shiro各个组件<br><strong>注：</strong>（关于使用xml配置文件和springMVC结合可以参考<a href="http://shiro.apache.org/spring.html" target="_blank" rel="noopener">apache shiro：integrate with spring</a> 和 <a href="http://jinnianshilongnian.iteye.com/blog/2029717/" target="_blank" rel="noopener">shiro 与spring集成</a>）</li>
<li>实现Filter，在springMVC中，通过DispactherServlet来完成对不同url的处理(包括调用filter以及使用其他servlet处理等)， 和springboot结合中，想要shiro 的authorizition/anthentication组件发挥作用，需要定义filter来对不同的url做出处理。</li>
</ol>
<p>###3.1 自定义realm<br>自定义realm，继承<code>AuthorizingRealm</code>并实现它的抽象方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroMysqlRealm</span> <span class="keyword">extends</span> <span class="title">AuthorizingRealm</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Autowired</span></span><br><span class="line">  <span class="keyword">private</span> UserDAO userDAO;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ShiroMysqlRealm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   实现这个方法获取用户权限，这里不需要你检查权限，只需要获取用户权限返回就行了，当调用Subject#isPermitted(Permission permission)时，</span></span><br><span class="line"><span class="comment">   会调用这个方法获得用户拥有的权限，然后对用户拥有的每一个Permission</span></span><br><span class="line"><span class="comment">  都会调用Permission # public boolean implies(Permission permission)。</span></span><br><span class="line"><span class="comment">  implies的参数是permission是要检查的权限（或者叫用户本次操作需要拥有的权限），调用implies检查用户拥有的权限是否包含要检查的permission。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">protected</span> AuthorizationInfo <span class="title">doGetAuthorizationInfo</span><span class="params">(PrincipalCollection principalCollection)</span> </span>&#123;</span><br><span class="line">    String username = (String) principalCollection.getPrimaryPrincipal();</span><br><span class="line">   <span class="comment">// 通过userDAO获取到用户拥有的所有权限</span></span><br><span class="line">    List&lt;Permission&gt; permissions = userDAO.getUserPermissions(username);</span><br><span class="line">    SimpleAuthorizationInfo authorizationInfo = <span class="keyword">new</span> SimpleAuthorizationInfo();</span><br><span class="line">    authorizationInfo.addObjectPermissions(permissions);</span><br><span class="line">    <span class="keyword">return</span> authorizationInfo;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  实现这个方法，完成用户身份验证，当调用Subject#login时，最终会走向这个方法.</span></span><br><span class="line"><span class="comment"> 方法参数‘ authenticationToken’是当前用户使用的username/password，我们  需要验证username/password是否有效。</span></span><br><span class="line"><span class="comment"> 验证过程很简单，通过userDAO从mysql获取用户username/password, 然后和参数传过来的比较一下就行了。</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> AuthenticationInfo <span class="title">doGetAuthenticationInfo</span><span class="params">(AuthenticationToken authenticationToken)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 调用subject#login时，我们使用的是UsernamePasswordToken，这里校验一下，不是就反回null，返回null就意味着用户身份验证不通过。</span></span><br><span class="line">    <span class="keyword">if</span>(!(authenticationToken <span class="keyword">instanceof</span> UsernamePasswordToken))&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    UsernamePasswordToken login = (UsernamePasswordToken) authenticationToken;</span><br><span class="line">    <span class="comment">// 通过userDAO获取到存在mysql里的username/password</span></span><br><span class="line">    User user = userDAO.getUserByName(login.getUsername()</span><br><span class="line">)</span><br><span class="line">   <span class="comment">// 判断一下和数据库存的password是不是一样的，一样表示验证通过。</span></span><br><span class="line">    <span class="keyword">if</span> (user != <span class="keyword">null</span> &amp;&amp; StringUtils.equals(login.getPassword(), user.getPassword))) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> SimpleAuthenticationInfo(login.getUsername(), String.valueOf(login.getPassword()), getName());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">------------------------------------------------</span><br><span class="line">关于doGetAuthenticationInfo这个方法，它的参数时当前尝试登录用户传过来的登录信息，它返回的是我们存储的的该用户的真实的信息，最终是拿两者比较来确定是否登录成功。</span><br><span class="line">login时有这样一个调用链：</span><br><span class="line">Subject # login -&gt; ... -&gt; AuthenticatingRealm # getAuthenticationInfo -&gt; </span><br><span class="line">AuthenticatingRealm # doGetAuthenticationInfo -&gt; AuthenticatingRealm # assertCredentialsMatch</span><br><span class="line">我重写了doGetAuthenticationInfo， 直接在里面完成验证，也可以重写assertCredentialsMatch去完成验证。</span><br></pre></td></tr></table></figure></p>
<h3 id="3-2-自定义permission"><a href="#3-2-自定义permission" class="headerlink" title="3.2 自定义permission"></a>3.2 自定义permission</h3><p>permission即用户权限，上面自定义realm中<code>doGetAuthorizationInfo</code>通过userDAO从数据库中获取某个用户的所有权限，这里就需要我们自定义权限类，这里主要检查restful接口的一些操作权限如下：</p>
<ol>
<li>GET</li>
<li>POST</li>
<li>PUT</li>
<li>DELETE</li>
<li>ALL (拥有以上所有权限)<br>类如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//自定义的permission需要实现Permission接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RestPermission</span> <span class="keyword">implements</span> <span class="title">org</span>.<span class="title">apache</span>.<span class="title">shiro</span>.<span class="title">authz</span>.<span class="title">Permission</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RestType restType;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RestPermission</span><span class="params">(RestType restType)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.restType = restType;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function">pulic <span class="title">RestPermission</span><span class="params">(String restType)</span></span>&#123;</span><br><span class="line">      <span class="keyword">this</span>(RestType.fromString(restType));</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">     只要实现这一个方法，判断当前拥有的权限（也就是this）是否包含p。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">implies</span><span class="params">(org.apache.shiro.authz.Permission p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(p == <span class="keyword">null</span> || !(p <span class="keyword">instanceof</span> RestPermission))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        RestPermission rp = (RestPermission) p;</span><br><span class="line">        <span class="comment">//当前拥有all权限或者当前权限和检查的权限一样返回true，验证通过</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.restType == RestType.ALL || <span class="keyword">this</span>.restType == rp.restType)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">enum</span> RestType&#123;</span><br><span class="line">        GET(<span class="string">"GET"</span>),</span><br><span class="line">        POST(<span class="string">"POST"</span>),</span><br><span class="line">        PUT(<span class="string">"PUT"</span>),</span><br><span class="line">        DELETE(<span class="string">"DELETE"</span>),</span><br><span class="line">        ALL(<span class="string">"ALL"</span>),</span><br><span class="line">        UNKOWN(<span class="string">"UNKOWN"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> String type;</span><br><span class="line"></span><br><span class="line">        RestType(String type) &#123;</span><br><span class="line">            <span class="keyword">this</span>.type = type;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">static</span> RestType <span class="title">fromString</span><span class="params">(String type)</span></span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(StringUtils.isBlank(type))&#123;</span><br><span class="line">                <span class="keyword">return</span> UNKOWN;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            String t = type.trim().toUpperCase();</span><br><span class="line">            <span class="keyword">if</span>(t.equals(<span class="string">"GET"</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> GET;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t.equals(<span class="string">"POST"</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> POST;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t.equals(<span class="string">"PUT"</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> PUT;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t.equals(<span class="string">"DELETE"</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> DELETE;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(t.equals(<span class="string">"ALL"</span>))&#123;</span><br><span class="line">                <span class="keyword">return</span> ALL;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">return</span> UNKOWN;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3-3-定义ShiroConfig"><a href="#3-3-定义ShiroConfig" class="headerlink" title="3.3 定义ShiroConfig"></a>3.3 定义ShiroConfig</h3><p>spring boot中不使用从xml文件加载bean，因此实现ShiroConfig，并使用<code>@Configuration</code>注解来完成shiro中必要组件加载组装。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ShiroConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">ShiroConfig</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Realm <span class="title">shiroRealm</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">new</span> ShiroMysqlRealm();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span>(name = <span class="string">"lifecycleBeanPostProcessor"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> LifecycleBeanPostProcessor <span class="title">lifecycleBeanPostProcessor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> LifecycleBeanPostProcessor();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span>(name = <span class="string">"securityManager"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> DefaultWebSecurityManager <span class="title">securityManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DefaultWebSecurityManager sm = <span class="keyword">new</span> DefaultWebSecurityManager();</span><br><span class="line">    sm.setRealm(shiroRealm());</span><br><span class="line">    sm.setSessionManager(sessionManager());</span><br><span class="line">    <span class="keyword">return</span> sm;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> SessionManager <span class="title">sessionManager</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    DefaultWebSessionManager sm = <span class="keyword">new</span> DefaultWebSessionManager();</span><br><span class="line">    Cookie cookie = <span class="keyword">new</span> SimpleCookie(<span class="string">"XXXXXXX"</span>);</span><br><span class="line">    cookie.setHttpOnly(<span class="keyword">true</span>);</span><br><span class="line">    cookie.setMaxAge(<span class="number">60</span> * <span class="number">60</span>); <span class="comment">// expire in 1 hour</span></span><br><span class="line">    sm.setSessionIdCookie(cookie);</span><br><span class="line">    <span class="keyword">return</span> sm;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> MethodInvokingFactoryBean <span class="title">methodInvokingFactoryBean</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    MethodInvokingFactoryBean methodInvokingFactoryBean = <span class="keyword">new</span> MethodInvokingFactoryBean();</span><br><span class="line">    methodInvokingFactoryBean.setStaticMethod(<span class="string">"org.apache.shiro.SecurityUtils.setSecurityManager"</span>);</span><br><span class="line">    methodInvokingFactoryBean.setArguments(<span class="keyword">new</span> Object[]&#123;securityManager()&#125;);</span><br><span class="line">    <span class="keyword">return</span> methodInvokingFactoryBean;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Bean</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> AuthorizationAttributeSourceAdvisor <span class="title">authorizationAttributeSourceAdvisor</span><span class="params">(DefaultWebSecurityManager sm)</span> </span>&#123;</span><br><span class="line">    AuthorizationAttributeSourceAdvisor sa = <span class="keyword">new</span> AuthorizationAttributeSourceAdvisor();</span><br><span class="line">    sa.setSecurityManager(sm);</span><br><span class="line">    <span class="keyword">return</span> sa;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">/**</span></span><br><span class="line"><span class="comment">   通过FactoryBean方式创建过滤器，‘ shiroFilter’自身也是一个Filter，它的作用有点类似‘ServleDispacther’， 它里面注册了很多url到filter的映射，</span></span><br><span class="line"><span class="comment">url的访问会先走向‘ shiroFilter’，然后‘ shiroFilter’根据url使用模式匹配去匹配到filterChain， 然后逐个激活filterChain里的filter。</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="meta">@Bean</span>(name = <span class="string">"shiroFilter"</span>)</span><br><span class="line">  <span class="function"><span class="keyword">public</span> ShiroFilterFactoryBean <span class="title">shiroFilterFactoryBean</span><span class="params">(DefaultWebSecurityManager sm)</span> </span>&#123;</span><br><span class="line">    ShiroFilterFactoryBean shiroFilter = <span class="keyword">new</span> ShiroFilterFactoryBean();</span><br><span class="line">   <span class="comment">// 设置登录跳转页面</span></span><br><span class="line">    shiroFilter.setLoginUrl(<span class="string">"/login"</span>);</span><br><span class="line">   <span class="comment">//登录成功后跳转页面</span></span><br><span class="line">    shiroFilter.setSuccessUrl(<span class="string">"/index"</span>);</span><br><span class="line">   <span class="comment">// 权限检查不过的跳转页面</span></span><br><span class="line">    shiroFilter.setUnauthorizedUrl(<span class="string">"/forbidden"</span>);</span><br><span class="line">   <span class="comment">//这是一个url pattern到过滤器名称的映射，一个url有多个filter时，过滤器名称用','隔开。</span></span><br><span class="line">  <span class="comment">// 注意这里使用了LinkedHashMap，因为url添加的顺序很重要，当'shiroFilter'尝试根据当前url去匹配符合该url的模式时，只返回这个map里第一个匹配成功的url 模式</span></span><br><span class="line">    Map&lt;String, String&gt; filterChainDefinitionMapping = <span class="keyword">new</span> LinkedHashMap&lt;&gt;();</span><br><span class="line">   <span class="comment">//为url 模式 设置filter， anon是filter name</span></span><br><span class="line">    filterChainDefinitionMapping.put(<span class="string">"/login"</span>, <span class="string">"anon"</span>);</span><br><span class="line">    filterChainDefinitionMapping.put(<span class="string">"/"</span>, <span class="string">"authc"</span>);</span><br><span class="line">    filterChainDefinitionMapping.put(<span class="string">"/api/v1/**"</span>, <span class="string">"authz-rest"</span>);</span><br><span class="line">    shiroFilter.setFilterChainDefinitionMap(filterChainDefinitionMapping);</span><br><span class="line">    shiroFilter.setSecurityManager(sm);</span><br><span class="line"></span><br><span class="line">    Map&lt;String, Filter&gt; filters = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">   <span class="comment">/* 设置filter name到filter实例的映射。这里除了你通过现实的设置filtername </span></span><br><span class="line"><span class="comment">     到filter的映射以外， 当前spring  容器里面所有实现了‘javax.servlet.Filter’的bean也会被默认添加进来，它的name就是bean name。</span></span><br><span class="line"><span class="comment">    filters.put("anon", new AnonymousFilter());</span></span><br><span class="line"><span class="comment">    filters.put("authc", new FormAuthenticationFilter());</span></span><br><span class="line"><span class="comment">    filters.put("authz-rest", new RESTAuthzFilter());</span></span><br><span class="line"><span class="comment">    shiroFilter.setFilters(filters);</span></span><br><span class="line"><span class="comment">    return shiroFilter;</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中我只自定义了一个filter，即<code>RESTAuthzFilter</code>, 当访问的url符合”/api/v1/**”模式时就会调用这个filter。 前面我们已经定义了GET、POST、PUT等等的一些rest操作的权限，现在在这个filter里就需要检查一下当前登录用户拥有权限去尽心这个url的操作，实现如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RESTAuthzFilter</span> <span class="keyword">extends</span> <span class="title">FormAuthenticationFilter</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// servlet filter中最关键的是doFilter方法，这里实现isAccessAllowed最终会被foFilter调用。在这里检查访问权限。</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isAccessAllowed</span><span class="params">(ServletRequest request, ServletResponse response, Object mappedValue)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得当前用户subject</span></span><br><span class="line">    Subject subject = <span class="keyword">this</span>.getSubject(request, response);</span><br><span class="line">    <span class="comment">//检查一下是否登录并通过身份认证</span></span><br><span class="line">    <span class="keyword">if</span> (subject.isAuthenticated()) &#123;</span><br><span class="line">      String uri = WebUtils.toHttp(request).getRequestURI().toString();</span><br><span class="line">      <span class="comment">//这里getMethod拿到本次url请求的操作（PUT,GET等等），然后构造出permission表示本次操作需要的权限。</span></span><br><span class="line">      RestPermission permission = <span class="keyword">new</span> RestPermission(WebUtils.toHttp(request).getMethod());</span><br><span class="line">      <span class="comment">//检查用户是否具有权限，上面提到过这次调用会走到ShiroMysqlRealm#doGetAuthorizationInfo获取用户所拥有的权限，然后对返回的权限再调用RestPermission # implies检查。</span></span><br><span class="line">      <span class="keyword">return</span> subject.isPermitted(permission)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="附：本文参考"><a href="#附：本文参考" class="headerlink" title="附：本文参考"></a>附：本文参考</h2><ol>
<li><a href="http://jinnianshilongnian.iteye.com/blog/2018936/" target="_blank" rel="noopener">shiro简介</a></li>
<li><a href="http://shiro.apache.org/reference.html" target="_blank" rel="noopener">apache shiro</a></li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/15/Mybatis-foreach标签/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Li Weisheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/15/Mybatis-foreach标签/" itemprop="url">Mybatis foreach标签</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-15T14:13:02+08:00">
                2017-08-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-mapper接口定义如下："><a href="#1-mapper接口定义如下：" class="headerlink" title="1. mapper接口定义如下："></a>1. mapper接口定义如下：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public interface InstancePropertiesMapper &#123;</span><br><span class="line">    void addProperties(List&lt;InstanceProperty&gt; properties);</span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line">public class InstanceProperty &#123;</span><br><span class="line">    private String name;</span><br><span class="line">    private Long instanceId;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此处希望<code>addProperties</code>能一次性往表里插入多条记录，插入的信息以<code>List&lt;InstanceProperty&gt; properties</code>列表保存。<br>假设properties列表中保存的数据如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">&#123;&quot;eric&quot;, 0&#125;,</span><br><span class="line">&#123;&apos;john&apos;, 1&#125;,</span><br><span class="line">&#123;&quot;sam&quot;, 2&#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure></p>
<p>需要达到的效果和下面sql类似:<br><code>insert into properties(name, instance_id) values(&quot;eric&quot;, 0) ,(&quot;john&quot;,1),(&quot;sam&quot;,2);</code>这样的效果.<br>对应mapper.xml如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;insert id=&quot;addProperties&quot; parameterType=&quot;java.util.List&quot;&gt;</span><br><span class="line">        INSERT INTO tdt_sync_instance_properties (name,instance_id) VALUES</span><br><span class="line">        &lt;foreach collection=&quot;list&quot; item=&quot;prop&quot; separator=&quot;,&quot;&gt;</span><br><span class="line">            (#&#123;prop.name&#125;,#&#123;prop.instance_id&#125;)</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">        ;</span><br><span class="line">    &lt;/insert&gt;</span><br></pre></td></tr></table></figure></p>
<p>使用<code>&lt;foreach&gt;</code>标签遍历参数’properties’. 这里使用了一些属性：</p>
<ol>
<li>collection=”list”,  后面会解释，当你的参数是List时，这个地方值也必须是list</li>
<li>item=”prop”, item表示list中的每一个元素,这里list里放的是InstanceProperty，因此可以通过’#{prop.name}’ 访问属性。</li>
<li>separator=”,”, 设置foreach生成的多条记录之间的分割符。</li>
</ol>
<p><strong>foreach的其他属性</strong></p>
<ol>
<li>open，close，定义如何将foreach所有记录包围起来，比如如果如同下面这样写：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;foreach collection=&quot;list&quot; item=&quot;prop&quot; separator=&quot;,&quot; open=&quot;&#123;&quot; close=&quot;&#125;&quot;&gt;</span><br><span class="line">            (#&#123;prop.name&#125;,#&#123;prop.instance_id&#125;)</span><br><span class="line">        &lt;/foreach&gt;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>最终生成的就是下面这样：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">insert into properties(name, instance_id) values &#123;(&quot;eric&quot;, 0) ,(&quot;john&quot;,1),(&quot;sam&quot;,2)&#125;;</span><br><span class="line">当然这样没有任何意义，是一条错误的sql语句，这里仅仅是为了举个例子。</span><br></pre></td></tr></table></figure></p>
<ol>
<li>index<br>当foreach遍历的数list或=者数组时，index代表就是下标，foreach遍历map时index代表key，此时item表示value。</li>
</ol>
<p><strong>关于collection属性</strong><br>首先需要知道mybatis怎么处理参数的，传递给XXXMapper接口方法的所有参数会被放到一个map中（后面叫这个map为M），假设存在参数properties：</p>
<ol>
<li>传递List类型的参数，则会在M里有一条 {“list” : properties }，所以此时collection设置为“list”就等于拿出M中key=”list”的value，然后遍历它。</li>
<li>传递数组类型参数， 则会在M里有一条{“array”, properties}，所以此时需要设置collection=”array”.</li>
<li>传递Map类型的参数， 不会做任何转换，假设你的Map类型的参数中包含的是{“china” :”beijing”, “usa”:”w.d.c”}, 那么M中就有两条映射：{“china” :”beijing”, “usa”:”w.d.c”}  。</li>
<li>如果传入的是一个bean，那么的bean中的属性作为key，属性值作为value放到M中。</li>
<li>如果传入的是一个基本类型变量，那么M中就会存在一条key是变量名，value是变量值（由于jdk7之前反射无法拿到参数名，可以使用下面介绍的注解）。</li>
</ol>
<p>综上，collection能够指定的值就是M中最终存在的key，<foreach>标签从M中拿到key的value，然后遍历value，所以这个value必须是能够被遍历的对象。</foreach></p>
<p>以上都是假设你没有在Mapper的接口方法上使用mybatis提供的注解<code>org.apache.ibatis.annotations.Param</code>注解参数名时collection的默认值，如果你在参数上使用了这个注解，那么最终M中的key是注解名，value是参数值，如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonMapper</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">insertPerson1</span><span class="params">(@Param(<span class="string">"map"</span>)</span> Map&lt;String, Person&gt; persons)</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">使用注解时M中就存在一条<span class="string">"map"</span> -&gt; persons的映射，而不是上面介绍的把persons的key,value直接方到M中</span><br><span class="line"></span><br><span class="line">那么可以在PersonMapper.xml中：</span><br><span class="line">&lt;insert id=<span class="string">"insertPerson1"</span>&gt;</span><br><span class="line">        INSERT INTO mybatis.person VALUES</span><br><span class="line">        &lt;foreach collection=<span class="string">"map"</span> index=<span class="string">"key"</span> item=<span class="string">"person"</span> separator=<span class="string">","</span>&gt;</span><br><span class="line">            (#&#123;p.name&#125;, #&#123;p.age&#125;)</span><br><span class="line">        &lt;/foreach&gt;</span><br><span class="line">&lt;/insert&gt;</span><br><span class="line"></span><br><span class="line">这里collection=<span class="string">"map"</span>, 相当于拿到M.get(<span class="string">"map"</span>)的值，也就是persons， </span><br><span class="line">然后遍历persons， 遍历的结果是index是persons的key， item是对应的value</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/08/15/Java单例模式/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Li Weisheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/15/Java单例模式/" itemprop="url">Java单例模式</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-15T12:00:09+08:00">
                2017-08-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="1-实现单例模式"><a href="#1-实现单例模式" class="headerlink" title="1. 实现单例模式"></a>1. 实现单例模式</h2><ol>
<li>饿汉模式和懒汉模式<br>单例模式根据实例化时机分为饿汉模式和懒汉模式。<br>饿汉模式，是指不等到单例真正使用时在去创建，而是在类加载或者系统初始化就创建好。<br>懒汉模式中单例要等到第一次使用时才创建。</li>
<li><p>饿汉模式<br><strong>最简单的实现</strong>：</p>
 <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">private static Singleton instance = new Singleton();</span><br><span class="line">private Singleton()&#123;&#125;;</span><br><span class="line">public static Singleton getInstance()&#123;return instance;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面是一种线程安全的实现方式，因为instance是类静态成员，会在类加载并初始化时创建，因此可以保证即便是不同线程也会获得同一份实例（这句话在有些情况下并不正确，比如通过序列化，反射的方式还是能够创建多个实例出来）。</p>
</li>
<li><p>懒汉模式</p>
<p>相对于1中在加载的时候就创建，另一种则是在首次使用时创建，比如下面这种方式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">	priavte static Singleton instance = null;</span><br><span class="line">	private Singleton()&#123;&#125;;</span><br><span class="line">	public static Singleton getInstance()&#123;</span><br><span class="line">		if(null == instance)&#123;</span><br><span class="line">			instance = new Singleton();</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   上面的这种形式，在首次调用getInstance时才会创建单例，但是它有一个问题就是，在多线程的情况下有可能会创建出多个实例化对象出来：比如线程1和线程2同时判断null ＝＝ instance为true，结果进入下一步两个线程就创建两个instance出来。当然这种方式通过加锁或则使用synchronize关键字的方式就可以避免了。这里不展示对整个getInstance方法加锁的实现，而是展示另一种方式：</p>
<p>   <strong>3.1 两次判断</strong>，代码如下：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">	priavte static volatile Singleton instance = null;</span><br><span class="line">	private Singleton()&#123;&#125;;</span><br><span class="line">	public static Singleton getInstance()&#123;</span><br><span class="line">		if(null == instance)&#123;</span><br><span class="line">		 synchronize(Singleton.class)&#123;</span><br><span class="line">		 	if(null == instance)&#123;</span><br><span class="line">		 		instance = new Singleton();</span><br><span class="line">		 	&#125;</span><br><span class="line">		 &#125;</span><br><span class="line">		&#125;</span><br><span class="line">		return instance;</span><br><span class="line">	&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>   比起对整个getInstance方法加锁，两次判断的方式可以避免一些不必要的加锁开销。</p>
<p>   同时volatile关键字十分必要，多核环境下，多线程分布在多个核上，每个核心拥有各自的cache，读取数据总会尝试从cache读取。那就意味着<code>instance = new Singleton();</code>可能不会立即被运行在其他核心上的线程所知，导致即便instance更新后，其他线程cache中instance依然是null。volatile关键字保存每次更新都会更新到内存，同时保存其他核心上该缓存项失效，需要从内存读取。</p>
<p>   <strong>3.2 内部类实现延迟加载</strong><br>上面两次判断的方法依然是通过加锁的方式来保证多线程情况下的创建单一实例，回顾1的实现中，保证只有一个实例是通过jvm只初始化一次static类成员这一机制实现的，但是1中在Singleton类加载的时候就会实例化静态成员instance，这可不是我们想要的首次使用创建这一目的。为了达到这一目的，我们可以借助内部类的方式实现，下面是代码实现：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">class Singleton&#123;</span><br><span class="line">	private Singleton()&#123;&#125;;</span><br><span class="line">	</span><br><span class="line">	private static class SingletonHolder&#123;</span><br><span class="line">		priavte static Singleton instance = new Singleton(); </span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	public static Singleton getInstance()&#123;return SingletonHolder.instance;&#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>   jvm加载Singleton时并不会加载其SingletonHolder，因此instance就不会被早早的创建，直到调用getInstance方法时才回加载SingletonHolder，而instance是其静态成员，jvm保证了它只此一份。</p>
<p><strong>附：关于类的加载时机</strong><br>「深入理解java虚拟机」一书中有介绍过类什么时候被初始化：</p>
<ol>
<li>创建类的实例时</li>
<li>使用Class.forName时</li>
<li>访问类的静态成员</li>
<li>调用类的静态方法</li>
<li>子类初始化时，父类也会初始化</li>
</ol>
<h2 id="2-实现单例模式的问题"><a href="#2-实现单例模式的问题" class="headerlink" title="2.实现单例模式的问题"></a>2.实现单例模式的问题</h2><p>在java中创建一个对象，我们可以通过：new，clone，序列化，反射。上面单例模式的实现我们通过将构造函数私有化使得不能通过new来创建对象，但是其他的手段依然可以，下面举例说明：</p>
<ol>
<li><p>反射<br>通过反射我们可以访问类的私有构造函授，测试代码如下（单例代码见上面1）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">public class TestSingleton &#123;</span><br><span class="line"> public static void main(String args[])&#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         Constructor cons = Singleton.class.getDeclaredConstructor();</span><br><span class="line">         cons.setAccessible(true);</span><br><span class="line">         Singleton instance1 = Singleton.getInstance();</span><br><span class="line">         Singleton instance2 = (Singleton)cons.newInstance();</span><br><span class="line"></span><br><span class="line">         System.out.println(&quot;instance1 == instance2 ?&quot;+(instance1 == instance2));</span><br><span class="line">     &#125; catch (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>   打印的结果如下：<br>  <code>instance1 == instance2 ? false</code><br>   instance1和instance2是不同对象，因此这就破坏了单例模式，网上提供解决反射带来的问题也十分简单，只需要修改构造函数，使得它第二次以及更多次的调用抛出异常，修改构造函数如下：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">private static boolean flag = false;</span><br><span class="line">public Singleton()&#123;</span><br><span class="line">		if(false == flag)&#123;</span><br><span class="line">			flag = true;</span><br><span class="line">		&#125;else&#123;</span><br><span class="line">			 throw new Exception(...);</span><br><span class="line">		｝</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>   不过java的反射有点没节操，你还是可以修改flag值，我的天。<br>   在《effective java》里提供一种解决之道，可以无视反射，那就是通过枚举来实现。像下面这样：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public enum Singleton3 &#123;</span><br><span class="line"> INSTANCE;</span><br><span class="line"></span><br><span class="line"> public void applaud()&#123;</span><br><span class="line">     System.out.println(&quot;haha, go home,reflection!&quot;);</span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>   没有构造函数了。。。(跟jvm初始化枚举变量的方式有关系，当你再试图通过反射获取构造函数会抛出异常)，所以再尝试通过反射获得构造函数，就会抛异常。</p>
<ol>
<li><p>序列化的影响<br>不考虑枚举实现单例模式，如果Singleton实现了Serializable接口，那么如果我们将Singleton序列到一个对象中去，在反序列化出来，就会导致不同的实例，请看下面代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">public class TestSingleton2 &#123;</span><br><span class="line"></span><br><span class="line"> public static void main(String []args)&#123;</span><br><span class="line">     try &#123;</span><br><span class="line">         Singleton instance = Singleton.getInstance();</span><br><span class="line"></span><br><span class="line">         //将instance序列化到文件singleton中.</span><br><span class="line">         FileOutputStream fos = new FileOutputStream(&quot;singleton&quot;);</span><br><span class="line">         ObjectOutputStream oos = new ObjectOutputStream(fos);</span><br><span class="line"></span><br><span class="line">         oos.writeObject(instance);</span><br><span class="line"></span><br><span class="line">         //从文件singleton中读出对象</span><br><span class="line">         FileInputStream fis = new FileInputStream(&quot;singleton&quot;);</span><br><span class="line">         ObjectInputStream ois = new ObjectInputStream(fis);</span><br><span class="line"></span><br><span class="line">         Singleton instance1 = (Singleton)ois.readObject();</span><br><span class="line"></span><br><span class="line">         System.out.println(&quot;instance == instance1 ? &quot; + (instance == instance1));</span><br><span class="line"></span><br><span class="line">     &#125; catch (Exception e) &#123;</span><br><span class="line">         e.printStackTrace();</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line"> &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>结果显示instance和instance1为两个实例。</p>
<p>  序列化前后产生不同对象，解决方法也很简单，jvm在反序列化时，如果该类实现的下面方法：<br>  <code>private Object readResolve() throw IOException</code><br>  那么就会调用这个方法返回对象，以替换流中对象。因此可以在这个方法里返回Singleton的instance成员，如下：</p>
   <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private  Object readResolve() throws ObjectStreamException&#123;</span><br><span class="line">    return instance;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/07/22/JUC之ExecutorCompletionService/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Li Weisheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/22/JUC之ExecutorCompletionService/" itemprop="url">JUC之ExecutorCompletionService</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-22T13:17:20+08:00">
                2017-07-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="1-接口CompletionService"><a href="#1-接口CompletionService" class="headerlink" title="1. 接口CompletionService"></a>1. 接口CompletionService</h1><p>接口CompletionService设计目标在于将生产者和消费者解耦，使生产者和消费者异步执行。<br>这里所说生产者负责提交任务（task）运行产生结果，消费者异步获得运行结果。<br>该接口定义的一组方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// submit提交可执行任务，返回Future用于异步获取结果</span><br><span class="line">1. Future&lt;V&gt; submit(Callable&lt;V&gt; task);</span><br><span class="line">2. Future&lt;V&gt; submit(Runnable task, V result);</span><br><span class="line"></span><br><span class="line">//take返回一个完成的任务的结果，没有会一直阻塞。</span><br><span class="line">3. Future&lt;V&gt; take() throws InterruptedException;</span><br><span class="line">// poll返回一个完成的任务的结果，没有返回null</span><br><span class="line">4. Future&lt;V&gt; poll();</span><br><span class="line">// 返回一个完成的任务的结果，没有完成的任务会阻塞timeout时间再返回</span><br><span class="line">5. Future&lt;V&gt; poll(long timeout, TimeUnit unit) throws InterruptedException;</span><br></pre></td></tr></table></figure></p>
<h1 id="2-实现类ExecutorCompletionService"><a href="#2-实现类ExecutorCompletionService" class="headerlink" title="2. 实现类ExecutorCompletionService"></a>2. 实现类ExecutorCompletionService</h1><p>ExecutorCompletionService实现接口CompletionService，下面是ExecutorCompletionService的用法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">public class CompletionServiceTest &#123;</span><br><span class="line">    static class RandomSleep implements Callable&lt;Integer&gt;&#123;</span><br><span class="line">        private static Random random = new Random(System.currentTimeMillis());</span><br><span class="line">        // 实现Callable， 随机sleep n秒，然后返回n。</span><br><span class="line">        @Override</span><br><span class="line">        public Integer call() throws Exception &#123;</span><br><span class="line">            int sleepTime = random.nextInt(20);</span><br><span class="line">            System.out.println(&quot;sleep &quot; + sleepTime + &quot;s&quot;);</span><br><span class="line">            Thread.sleep(sleepTime * 1000);</span><br><span class="line">            return sleepTime;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args)&#123;</span><br><span class="line">        // 创建线程池，ExecutorCompletionService本身需要接受传入的线程池来运行任务。</span><br><span class="line">        ExecutorService cachedThreadPoll = Executors.newCachedThreadPool();</span><br><span class="line">        ((ThreadPoolExecutor)cachedThreadPoll).setCorePoolSize(5);</span><br><span class="line">        </span><br><span class="line">         // 基于线程池cachedThreadPoll创建ExecutorCompletionService实例</span><br><span class="line">        CompletionService completionService = new ExecutorCompletionService(cachedThreadPoll);</span><br><span class="line">         //提交5个任务运行</span><br><span class="line">        for(int i = 0; i &lt; 5; ++i)&#123;</span><br><span class="line">            completionService.submit(new RandomSleep());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        cachedThreadPoll.shutdown();</span><br><span class="line">        for(int i = 0; i &lt; 5; ++i)&#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                 // 上面1提到take会返回一个运行成功的任务, 否则会阻塞</span><br><span class="line">                System.out.println(&quot;get result: &quot; + completionService.take().get());</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; catch (ExecutionException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">-------------------------------</span><br><span class="line">输出：</span><br><span class="line">sleep 6s</span><br><span class="line">sleep 8s</span><br><span class="line">sleep 9s</span><br><span class="line">sleep 19s</span><br><span class="line">sleep 10s</span><br><span class="line">get result: 6</span><br><span class="line">get result: 8</span><br><span class="line">get result: 9</span><br><span class="line">get result: 10</span><br><span class="line">get result: 19</span><br><span class="line">从上面的输出可以看出take按任务运行结束先后顺序返回。</span><br></pre></td></tr></table></figure></p>
<h2 id="2-1-基本原理"><a href="#2-1-基本原理" class="headerlink" title="2.1 基本原理"></a>2.1 基本原理</h2><p>ExecutorCompletionService有三个成员:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// executor用来执行任务</span><br><span class="line">private final Executor executor;</span><br><span class="line">// 如果executor实现了抽象类AbstractExecutorService，aes就是executor，否则为null</span><br><span class="line">private final AbstractExecutorService aes;</span><br><span class="line">// 任务完成后返回的结果（Future）放入阻塞对列，take，poll即从这个对列取任务运行 结果</span><br><span class="line">private final BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue;</span><br></pre></td></tr></table></figure></p>
<p>每一个通过ExecutorCompletionService#submit提交的任务（实现Callable或者Runnable）会被ExecutorCompletionService#newTaskFor包装成QueueingFuture。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">QueueingFuture是ExecutorCompletionService内部类，继承关系如下(&lt;&lt;I&gt;&gt;表示接口):</span><br><span class="line"></span><br><span class="line">   Future&lt;&lt;I&gt;&gt;           Runnable&lt;&lt;I&gt;&gt;</span><br><span class="line">          ^                    ^</span><br><span class="line">          |                    |</span><br><span class="line">          ----------------------</span><br><span class="line">                    |</span><br><span class="line">             RunnableFuture&lt;&lt;I&gt;&gt;</span><br><span class="line">                     ^</span><br><span class="line">                     |</span><br><span class="line">                 FutureTask</span><br><span class="line">                     ^</span><br><span class="line">                     |</span><br><span class="line">                QueueingFuture</span><br><span class="line">                  </span><br><span class="line"></span><br><span class="line">QueueingFuture继承类FutureTask，FutureTask构造函数包装了一个Callable或则Runnable任务实例，</span><br><span class="line">FutureTask还有一个空的protected方法done()，会在其包装的任务运行成功、任务取消或则任务异常的情况下被调用。</span><br><span class="line"></span><br><span class="line">ExecutorConpletionService内部类QueueingFuture继承FutureTask并重写done方法，done方法里将被包装的task放入阻塞队列completionQueue，因此调用ExecutorCompletionService#take或则poll总是会获得运行完成的任务。</span><br></pre></td></tr></table></figure></p>
<p><strong>注：</strong> ExecutorConpletionService#take总是获得完成的任务，但是这个任务可能是正常完成的，也可能是被取消或则抛出了异常。因此还需要对take返回的Future作出判断再进一步处理。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/25/scala学习-特质/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Li Weisheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/25/scala学习-特质/" itemprop="url">scala学习 - 特质</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-25T19:32:15+08:00">
                2017-06-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>本文来自《Programming in Scala》一书</strong></p>
<h1 id="Scala学习之特质（trait）"><a href="#Scala学习之特质（trait）" class="headerlink" title="Scala学习之特质（trait）"></a>Scala学习之特质（trait）</h1><h2 id="1-特质的定义"><a href="#1-特质的定义" class="headerlink" title="1 特质的定义"></a>1 特质的定义</h2><p>特质的定义和类相似，只是使用<code>trait</code>关键字代替<code>class</code>，如下:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TraitA</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printA</span></span>():<span class="type">Uint</span> = &#123;</span><br><span class="line">    println(<span class="string">"trait TraitA"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>定义了trait之后可以使用extends或者with把它混入类中，extends类似java的extends关键字，一个类不可以多次extends；with可以像implements一样定义多个。</p>
</li>
<li><p>trait不能像class一样给主构造器提供参数</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ClassA</span>(<span class="params">name:<span class="type">String</span></span>)</span>&#123;...&#125;   <span class="comment">//这是合法的，可以提供主构造器参数</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TraitA</span>(<span class="params">name:<span class="type">String</span></span>)</span>&#123;...&#125;   <span class="comment">//非法的</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>trait不想java的interface，trait可以实现方法，有点类似<code>abstract class</code>。</p>
</li>
</ol>
<h2 id="2-可堆叠改变"><a href="#2-可堆叠改变" class="headerlink" title="2 可堆叠改变"></a>2 可堆叠改变</h2><p>一个类混合了多个特质，这些特质的方法可以堆叠在一起共同决定类的方法所表现出来的行为。</p>
<p>想要使用trait的可堆叠功能，trait的方法里必须使用到super,像下面这样:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> buf = <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">Int</span>]()</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">put</span></span>(i : <span class="type">Int</span>) = &#123;</span><br><span class="line">    println(<span class="string">"In IntQueue"</span>)</span><br><span class="line">    buf.append(i)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>():<span class="type">Int</span>=&#123;</span><br><span class="line">    println(<span class="string">"In IntQueue"</span>)</span><br><span class="line">    buf.remove(<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">-----------------------------------------------------------</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TraitC</span> <span class="keyword">extends</span> <span class="title">IntQueue</span></span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">put</span></span>(i: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">"In TraitC..."</span>)</span><br><span class="line">    <span class="keyword">super</span>.put(i)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>(): <span class="type">Int</span> = <span class="keyword">super</span>.get()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>traitC 继承IntQueue，并在<code>put</code>方法中调用<code>super.put</code>，这并不代表就是调用IntQueue#put方法，<code>super.put</code>方法是动态的决定的，根据混入特质TraitC的类中TraitC所处位置有关，比如下面的代码：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> buf = <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">Int</span>]()</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">put</span></span>(i : <span class="type">Int</span>) = &#123;</span><br><span class="line">    println(<span class="string">"In IntQueue"</span>)</span><br><span class="line">    buf.append(i)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>():<span class="type">Int</span>=&#123;</span><br><span class="line">    println(<span class="string">"In IntQueue"</span>)</span><br><span class="line">    buf.remove(<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TraitA</span> <span class="keyword">extends</span> <span class="title">IntQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">put</span></span>(i: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">"In TraitA..."</span>)</span><br><span class="line">    <span class="keyword">super</span>.put(i)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>(): <span class="type">Int</span> = &#123;</span><br><span class="line">    println(<span class="string">"In TraitA..."</span>)</span><br><span class="line">    <span class="keyword">super</span>.get</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TraitB</span> <span class="keyword">extends</span>  <span class="title">IntQueue</span></span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">put</span></span>(i: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">"In TraitB..."</span>)</span><br><span class="line">    <span class="keyword">super</span>.put(i)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>(): <span class="type">Int</span> = &#123;</span><br><span class="line">    println(<span class="string">"In TraitB..."</span>)</span><br><span class="line">    <span class="keyword">super</span>.get()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestTrait</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ExtendIntQueue</span> <span class="keyword">extends</span> <span class="title">IntQueue</span> <span class="keyword">with</span> <span class="title">TraitA</span> <span class="keyword">with</span> <span class="title">TraitB</span></span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">put</span></span>(i: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      println(<span class="string">"In ExtendIntQueue..."</span>)</span><br><span class="line">      <span class="keyword">super</span>.put(i)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">get</span></span>(): <span class="type">Int</span> = &#123;</span><br><span class="line">      println(<span class="string">"In ExtendIntQueue..."</span>)</span><br><span class="line">      <span class="keyword">super</span>.get()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args : <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> =&#123;</span><br><span class="line">    <span class="keyword">val</span> etq = <span class="keyword">new</span> <span class="type">ExtendIntQueue</span></span><br><span class="line">    etq.put(<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">继承体系：</span><br><span class="line">----&gt;  <span class="type">InitQueue</span></span><br><span class="line">|         ^</span><br><span class="line">|         |</span><br><span class="line">|      ----------</span><br><span class="line">|      |         |</span><br><span class="line">|    <span class="type">TraitA</span>    <span class="type">TraitB</span></span><br><span class="line">|      ^        ^</span><br><span class="line">|      |        |</span><br><span class="line">|      ----------</span><br><span class="line">|            |</span><br><span class="line">|------ <span class="type">ExtendIntQueue</span> </span><br><span class="line"></span><br><span class="line">上面代码最终输出：</span><br><span class="line"><span class="type">In</span> <span class="type">ExtendIntQueue</span>...</span><br><span class="line"><span class="type">In</span> <span class="type">TraitB</span>...</span><br><span class="line"><span class="type">In</span> <span class="type">TraitA</span>...</span><br><span class="line"><span class="type">In</span> <span class="type">IntQueue</span></span><br></pre></td></tr></table></figure>
<p>从上面代码的输出可以看出调用 </p>
<p><code>ExtendIntQueue#put -&gt; TraitB#put -&gt; TraitA#put -&gt; IntQueue#put</code></p>
<p>TraitB的<code>super.put</code> 被动态绑定成了TraitA, TraitA的<code>super.put</code>调用了IntQueue#put. 上面代码的继承结构比较复杂，scala是怎么动态决定super的绑定？有一条基本的原则首先：同一个类混入的特质里，右边的先于左边的，比如<code>class ExtendIntQueue extends IntQueue with TraitA with TraitB</code>，最右TraitB 先调用，它的super被绑定成TraitA。 上面这个过程被称为线性化，类ExtendIntQueue所有的超类被线性化，线性化后的继承体系就像<code>ExtendIntQueue -&gt;TraitB -&gt; TraitA -&gt; IntQueue</code>，因此put的调用变成了<code>ExtendIntQueue#put -&gt;TraitB#put -&gt; TraitA#put -&gt; IntQueue#put</code></p>
<p>scala是怎么做线性化的？下面是一个更加复杂的例子：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntQueue</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> buf = <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[<span class="type">Int</span>]()</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">put</span></span>(i : <span class="type">Int</span>) = &#123;</span><br><span class="line">    println(<span class="string">"In IntQueue"</span>)</span><br><span class="line">    buf.append(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TraitA</span> <span class="keyword">extends</span> <span class="title">IntQueue</span> <span class="keyword">with</span> <span class="title">TraitD</span></span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">put</span></span>(i: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">"In TraitA..."</span>)</span><br><span class="line">    <span class="keyword">super</span>.put(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TraitB</span> <span class="keyword">extends</span>  <span class="title">IntQueue</span> <span class="keyword">with</span> <span class="title">TraitD</span></span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">put</span></span>(i: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">"In TraitB..."</span>)</span><br><span class="line">    <span class="keyword">super</span>.put(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TraitC</span> <span class="keyword">extends</span> <span class="title">IntQueue</span></span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">put</span></span>(i: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">"In TraitC..."</span>)</span><br><span class="line">    <span class="keyword">super</span>.put(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------</span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">TraitD</span> <span class="keyword">extends</span> <span class="title">IntQueue</span></span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">put</span></span>(i: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    println(<span class="string">"In TraitD..."</span>)</span><br><span class="line">    <span class="keyword">super</span>.put(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">TestTrait</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">class</span> <span class="title">ExtendIntQueue</span> <span class="keyword">extends</span> <span class="title">IntQueue</span> <span class="keyword">with</span> <span class="title">TraitC</span> <span class="keyword">with</span> <span class="title">TraitA</span> <span class="keyword">with</span> <span class="title">TraitB</span></span>&#123;</span><br><span class="line">    <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">put</span></span>(i: <span class="type">Int</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">      println(<span class="string">"In ExtendIntQueue..."</span>)</span><br><span class="line">      <span class="keyword">super</span>.put(i)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args : <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> =&#123;</span><br><span class="line">    <span class="keyword">val</span> etq = <span class="keyword">new</span> <span class="type">ExtendIntQueue</span></span><br><span class="line">    etq.put(<span class="number">0</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">----------------------------------------------------------</span><br><span class="line">继承体系如下:</span><br><span class="line"></span><br><span class="line">               |--&gt;  <span class="type">IntQueue</span>  &lt;--------------------|    </span><br><span class="line">               |        ^ &lt;---- <span class="type">TraitD</span> &lt;----|       |</span><br><span class="line">               |        |          ^        |       |</span><br><span class="line">			   |		|          |        |       | </span><br><span class="line">               |        |------	<span class="type">TraitA</span>    <span class="type">TraitB</span> ---|</span><br><span class="line">			   |		|	      ^	    ^</span><br><span class="line">			   |        |          |        |</span><br><span class="line">               |       <span class="type">TraitC</span>      ----------</span><br><span class="line">               |          ^            ^</span><br><span class="line">               |          |            |</span><br><span class="line">               |---------------- <span class="type">ExtendIntQueue</span></span><br><span class="line"></span><br><span class="line">上面代码打印输出是：</span><br><span class="line"><span class="type">In</span> <span class="type">ExtendIntQueue</span>...</span><br><span class="line"><span class="type">In</span> <span class="type">TraitB</span>...</span><br><span class="line"><span class="type">In</span> <span class="type">TraitA</span>...</span><br><span class="line"><span class="type">In</span> <span class="type">TraitD</span>...</span><br><span class="line"><span class="type">In</span> <span class="type">TraitC</span>...</span><br><span class="line"><span class="type">In</span> <span class="type">IntQueue</span></span><br></pre></td></tr></table></figure>
<p>顺序化按照符合这些原则（我自己理解的）：</p>
<ol>
<li>拓扑排序，被依赖不会早于依赖它的，比如上买呢ExtendIntQueue一定是最早的，它不依赖任何类，ExtendIntQueue之后，TraitA，TraitB，TraitC将不被依赖。</li>
<li>从右到左，ExtendIntQueue之后，TraitA，TraitB，TraitC将不被依赖。但是从右到左一次是TraitB, TraitA, TraitC.</li>
<li>深度搜索，比如从右到左先解析TraitB之后，此时TraitB的父类型从右到左是TraitD,IntQueue.  此时会尝试TraitD，但是TraitD还被TraitA依赖， IntQueue也被依赖所以不行把TraitD加入到顺序里</li>
</ol>
<p>用S来表示加入的顺序,D表示无下游依赖的类或特质，此时D初始值为（ExtendIntQueue）,S为（），照以上规则：</p>
<ol>
<li>首先加入ExtendIntQueue，它没有被依赖，此时TraitA，TraitB，TraitC不在被依赖。S为(ExtendIntQueue)</li>
<li>需要从TraitA，TraitB, TraitC中选择，选最右TraitB, S为（ExtendIntQueue, TraitB), D为（TraitA,TraitC）. 判断TraitB的父类，如果有不再被依赖的比如TraitX，则加入S（这是一个递归往上的过程，如果TraitX上有TraitY, 还会判断是否要加入TraitY）</li>
<li>从D中选TraitA加入S，此时TraitA最右，S为（ExtendIntQueue, TraitB, TraitA), D为(TraitC, TraitD)。 像2中TraitB一样，需要判断TraitA的父类是否有不被依赖的类，TraitD不在被依赖，加入S， S为（ExtendIntQueue, TraitB, TraitA，TraitD)。</li>
<li>从D中选TraitC，S为（ExtendIntQueue, TraitB, TraitA，TraitD,TraitC),  此时IntQueue不在被依赖,加入D, D为(IntQueue).</li>
<li>从D中选IntQueue, 最终S为 （ExtendIntQueue, TraitB, TraitA，TraitD,TraitC, IntQueue)</li>
</ol>
<p>总上顺序化后的继承体系类似:</p>
<p><code>ExtendIntQueue -&gt; TraitB -&gt;TraitA -&gt; TraitD -&gt; TraitC -&gt; IntQueue</code></p>
<p>也就有了上面代码中的输出。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/06/24/scala学习-隐式转换和隐式参数/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Li Weisheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/06/24/scala学习-隐式转换和隐式参数/" itemprop="url">scala学习 - 隐式转换和隐式参数</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-06-24T19:30:00+08:00">
                2017-06-24
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>  <strong>本文来自《Programming in Scala》一书</strong></p>
<h1 id="scala学习之隐式转换和隐式参数"><a href="#scala学习之隐式转换和隐式参数" class="headerlink" title="scala学习之隐式转换和隐式参数"></a>scala学习之隐式转换和隐式参数</h1><h2 id="1-隐式类型转换"><a href="#1-隐式类型转换" class="headerlink" title="1  隐式类型转换"></a>1  隐式类型转换</h2><p>scala编译器在对语言做类型检查时，发现参与运行的表达式类型A不符合类型语义要求，在抛出错误之前，会在当前作用域中查找是否存在A 到B类型的转换，是的转换之后通过类型检查，这种转换就是隐式类型转换：用户无需在代码中明确的调用函数将A转换成B，编译器帮你做了这件事。</p>
<p>比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> list1 = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line"><span class="keyword">val</span> i = <span class="number">3</span></span><br><span class="line">list1 ::: i</span><br></pre></td></tr></table></figure>
<p>上面代码无法通过scala编译器的类型检查，抛出如下错误:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">scala&gt; <span class="keyword">val</span> list1 = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">list1: <span class="type">List</span>[<span class="type">Int</span>] = <span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">scala&gt; <span class="keyword">val</span> i = <span class="number">3</span></span><br><span class="line">i: <span class="type">Int</span> = <span class="number">3</span></span><br><span class="line"></span><br><span class="line">scala&gt; list1 ::: i</span><br><span class="line">&lt;console&gt;:<span class="number">28</span>: error: value ::: is not a member of <span class="type">Int</span></span><br><span class="line">       list1 ::: i</span><br><span class="line">             ^</span><br></pre></td></tr></table></figure>
<p>原因在于<code>list1:::i</code>被转换成<code>list1.:::(i)</code>的方法调用，这个方法要求参数必须是集合类型，而i是Int型。一种解决办法是像这样<code>list1:::List(i)</code>在代码中显式的将 i 转换成List。另外一种方式就是像下面这样:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">IntWrapper</span></span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">intToList</span></span>(i : <span class="type">Int</span>): <span class="type">List</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">    <span class="type">List</span>(i)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args : <span class="type">Array</span>[<span class="type">String</span>]) :<span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> l1 = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">val</span> l2 = l1 ::: <span class="number">3</span>;</span><br><span class="line">    print(l2)</span><br><span class="line">    <span class="comment">//输出List(1, 2, 3)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定义隐式转换方法<code>intToList</code>（必须使用implicit关键字），接收Int类型参数，转换成List[Int]。 上面代码编译器再碰到<code>l1:::3</code>时，发现类型不匹配，会在当前作用域寻找一种隐式转换使得 3 转换成<code>l1.:::()</code>调用能够接收的类型。</p>
<p>还有一种会编译器会尝试将源类型隐式转换成目标类型的地方就是：在源类型上调用方法，可是该方法却不存在于源类型的class定义中,比如：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntWrapper</span>(<span class="params">i : <span class="type">Int</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">private</span>[<span class="type">IntWrapper</span>] <span class="keyword">var</span> l = <span class="type">List</span>[<span class="type">Int</span>](i)</span><br><span class="line">  </span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">printSelf</span></span>(): <span class="type">Unit</span> =&#123;</span><br><span class="line">    println(<span class="string">"In IntWraper: "</span> + l)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">IntWrapper</span></span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">intToIntWraper</span></span>(i : <span class="type">Int</span>):<span class="type">IntWrapper</span> = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">IntWrapper</span>(i)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args : <span class="type">Array</span>[<span class="type">String</span>]) :<span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> i = <span class="number">11</span>;</span><br><span class="line">    i.printSelf()</span><br><span class="line">    <span class="comment">//输出 In IntWraper: List(11)</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>main方法里定义了Int类型 i ，Int类型不存在方法printSelf，此时编译器会尝试寻找Int上的类型转换，使的转换后的目标的类型有方法printSelf，因此会使用<code>implicit def intToIntWraper</code>作为转换函数。</p>
<p>上面这两种情形实际上可以归为一类，就是都需要将源类型转换成目标类型才能够通过类型检查。</p>
<h2 id="2-隐式参数"><a href="#2-隐式参数" class="headerlink" title="2 隐式参数"></a>2 隐式参数</h2><p>scala编译器另一个会替你完成隐式操作的地方就是参数列表,比如定义了下面这样一个方法:</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntWrapper</span> (<span class="params">i : <span class="type">Int</span></span>)</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">private</span>[<span class="type">IntWrapper</span>] <span class="keyword">var</span> l = <span class="type">List</span>(i)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">map</span></span>(<span class="keyword">implicit</span> m : <span class="type">Int</span> =&gt; <span class="type">List</span>[<span class="type">Int</span>]):<span class="type">List</span>[<span class="type">List</span>[<span class="type">Int</span>]] = &#123;</span><br><span class="line">    l.map(m)</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">IntWrapper</span></span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> f =(i : <span class="type">Int</span>) =&gt; <span class="type">List</span>(i + <span class="number">1</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args : <span class="type">Array</span>[<span class="type">String</span>]) :<span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> intWraper = <span class="keyword">new</span> <span class="type">IntWrapper</span>(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">//map使用隐式参数，编译器在当前可见作用域中查找到 f 作为map的参数</span></span><br><span class="line">    print(intWraper.map)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>方法map的参数列表使用了<code>implicit</code>关键字，表示你在使用map时，可以不提供参数，让编译器去替你完成在方法调用的作用域中去查找满足参数类型的隐式转换。</p>
<p>上面实例代码中表，使用隐式参数时，不仅要求map的形式参数列表使用implicit，提供的隐式实际参数 f 也需要使用implicit。</p>
<h2 id="3-何时发生隐式操作"><a href="#3-何时发生隐式操作" class="headerlink" title="3 何时发生隐式操作"></a>3 何时发生隐式操作</h2><p>其实1，2已经说明了scala何时会尝试使用隐式操作：</p>
<ol>
<li><p>需要转换成目标类型</p>
<p>比如函数 f 的类型A =&gt; B，使用类型为C（假设C不是A的子类）的变量c调用 <code>f(c)</code>, 编译器就会需要尝试寻找将 C =&gt; A的隐式类型转换。</p>
</li>
<li><p>在原类型上调用不存在的方法</p>
<p>比如class A存在方法<code>def fA()…</code>，在class B的实例b上调用<code>b.fA()</code>,假设class B没有成员方法fA，此时会尝试 B =&gt; A的隐式转换.</p>
</li>
<li><p>隐式参数</p>
</li>
</ol>
<h2 id="4-隐式操作的一些规则或者约束"><a href="#4-隐式操作的一些规则或者约束" class="headerlink" title="4 隐式操作的一些规则或者约束"></a>4 隐式操作的一些规则或者约束</h2><h3 id="4-1-作用域规则"><a href="#4-1-作用域规则" class="headerlink" title="4.1 作用域规则"></a>4.1 作用域规则</h3><p>隐式转换必须以单一标识符的形式出现在需要转换的地方所处的作用域中，或者与转换的源类型或目标类型关联在一起。分别解释一下：</p>
<ol>
<li><p>单一标识符是指不能以xxx.f这种形式才能使A转换成B类型</p>
<p>假设有隐式转换<code>f</code>使得A转换成B，编译器在插入代码时必须是<code>f(A)</code>,而不需要在f前面插入包或者类的前缀，比如下面这种就是不行的：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.eric.learn.`<span class="keyword">implicit</span>`.convertutils</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ConvertUtils</span></span>&#123;</span><br><span class="line">  <span class="comment">//Int 到 List的隐式转换</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">intToList</span></span>(i : <span class="type">Int</span>): <span class="type">List</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">    <span class="type">List</span>(i)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-------------------------------------------------------------------</span><br><span class="line"><span class="keyword">package</span> me.eric.learn.`<span class="keyword">implicit</span>`</span><br><span class="line"><span class="comment">//引入ConvertUtils</span></span><br><span class="line"><span class="keyword">import</span> convertutils.<span class="type">ConvertUtils</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IntWrapper</span></span>&#123;&#125;</span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">IntWrapper</span></span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args : <span class="type">Array</span>[<span class="type">String</span>]) :<span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> l1 = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="comment">//此处需要将 3 隐式转换成List，编译器无法直接应用 l1:::intToList(3)，当在代码中显式调用时也得这样: l1:::ConvertUtils.intToList(3)。不符合单一标识符的原则</span></span><br><span class="line">    <span class="keyword">val</span> l2 = l1 ::: <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面代码要想可以应用隐式转换，可以使用“import convertutils.ConvertUtils.intToList“引入</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>与转换的源类型关联</p>
<p>和后面介绍的与转换的目标类型关联一样，这是单一标志符原则的例外。原类型关联是指：假设需要A - &gt; B类型转换，那么转换操作可以以<code>implicit def ...</code>这种形式定义在<code>object A</code>里，如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.eric.learn.`<span class="keyword">implicit</span>`</span><br><span class="line"></span><br><span class="line"><span class="comment">//StringWrapper是源类型，包装一下String</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">StringWrapper</span>(<span class="params">s : <span class="type">String</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> s1 = s</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StringWrapper</span></span>&#123;</span><br><span class="line">  <span class="comment">//隐式操作和源类型关联，StringWrapper -&gt; String转换</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">stringWrapperToString</span></span>(sw : <span class="type">StringWrapper</span>):<span class="type">String</span> = &#123;</span><br><span class="line">    sw.s1</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line"> <span class="comment">//隐式操作， String -&gt; StringWrapper的转换</span></span><br><span class="line"> <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">stringToStringWrapper</span></span>(s : <span class="type">String</span>):<span class="type">StringWrapper</span>=&#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">StringWrapper</span>(s)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">---------------------------------------------------------------------------</span><br><span class="line"></span><br><span class="line"><span class="keyword">package</span> me.eric.learn.`<span class="keyword">implicit</span>`.convertutils</span><br><span class="line"><span class="comment">//这种引入方式不符合单一标识符原则</span></span><br><span class="line"><span class="keyword">import</span> me.eric.learn.`<span class="keyword">implicit</span>`.<span class="type">StringWrapper</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">StringWrapperUtils</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">split</span></span>(sw : <span class="type">StringWrapper</span>):<span class="type">String</span>[]=&#123;</span><br><span class="line">    <span class="comment">//StringWrapper关联的stringWrapperToString,sw可以隐式转换成String，调用split方法</span></span><br><span class="line">    sw.split(<span class="string">" "</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>与目标类型关联</p>
<p>即A -&gt; B的转换可以定义在object B中，以2中代码为例: StringWrapperUtils#split接收参数类型为StringWrapper, 此时传一个String类型是非法的，显然无法在Object String里增加String -&gt; StringWrapper的转换，但是可以在StringWrapper里增加，如同例子中 <code>implicit def stringToStringWrapper...</code>那样。</p>
</li>
</ol>
<h3 id="4-2-无歧义规则"><a href="#4-2-无歧义规则" class="headerlink" title="4.2 无歧义规则"></a>4.2 无歧义规则</h3><p>无歧义规则是指不可以有两个隐式转换 convert1 和convert2 使得转换应用在A上都可以完成类型检查。比如下面的代码就通不过编译;</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">IntWrapper</span></span>&#123;</span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">intToList</span></span>(i : <span class="type">Int</span>): <span class="type">List</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">    <span class="type">List</span>(i)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">intToList1</span></span>(i : <span class="type">Int</span>): <span class="type">List</span>[<span class="type">Int</span>] = &#123;</span><br><span class="line">    <span class="type">List</span>(i + <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// implicit val f =(i : Int) =&gt; List(i + 2)           </span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="function"><span class="keyword">def</span> <span class="title">intToIntWraper</span></span>(i : <span class="type">Int</span>):<span class="type">IntWrapper</span> = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">IntWrapper</span>(i)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args : <span class="type">Array</span>[<span class="type">String</span>]) :<span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> l1 = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">val</span> l2 = l1 ::: <span class="number">3</span></span><br><span class="line">    print(l2)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>忽略上面代码注释部分，有两个Int到List的转换：intToList和intToList1,存在歧义。</p>
<p>但是奇怪的是，去掉上面代码的注释，却又能通过编译，且运行结果显示使用了<code>implicit val f =(i : Int) =&gt; List(i + 2)</code>这个隐式转换。不知道为什么。</p>
<h3 id="4-3-单一调用规则"><a href="#4-3-单一调用规则" class="headerlink" title="4.3 单一调用规则"></a>4.3 单一调用规则</h3><p>如果需要对类型A转换，只会进行一次转换，比如方法<code>f(c : C)</code>接收C类型，此时存在 <code>A -&gt; B</code>的转换fAB,<code>B -&gt; C</code>的转换fBC，<code>f(a)</code>的调用不会成功，不会编译器不会应用<code>f(fBC(fAB(a)))</code> 把a转换成C类型</p>
<h3 id="4-4-显式操作优先"><a href="#4-4-显式操作优先" class="headerlink" title="4.4 显式操作优先"></a>4.4 显式操作优先</h3><p>其实很简单，能不进行隐式转换就能通过类型检查的话，就不使用隐式转换。比如方法<code>def f(a : A)</code>，变量b(类型为B，继承A)，调用<code>f(b)</code>，即便此时有B -&gt; A的转换也不会应用。</p>
<h2 id="5-隐式参数"><a href="#5-隐式参数" class="headerlink" title="5. 隐式参数"></a>5. 隐式参数</h2><p>4中的规则同样适用于隐式参数，隐式参数适用方式如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.eric.learn.`<span class="keyword">implicit</span>`</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImplicitParam</span> </span>&#123;</span><br><span class="line">  <span class="comment">// implicit 声明隐式参数</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">echo</span></span>(i : <span class="type">Int</span>)(<span class="keyword">implicit</span> s:<span class="type">String</span>, l:<span class="type">Long</span>) =&#123;</span><br><span class="line">    println((i,s,l))</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ImplicitParam</span></span>&#123;</span><br><span class="line">  <span class="comment">// 作为隐式值应用于ImplicitParam#echo方法</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> s = <span class="string">"hello"</span></span><br><span class="line">  <span class="keyword">implicit</span> <span class="keyword">val</span> l = <span class="number">100</span>L</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> =&#123;</span><br><span class="line">    <span class="keyword">val</span> ip = <span class="keyword">new</span> <span class="type">ImplicitParam</span>()</span><br><span class="line">    <span class="comment">//只需要指定参数 i的值，编译器将应用 s,l作为隐式参数的实参,相当于调用ip.echo(i)(s,l)</span></span><br><span class="line">    ip.echo(<span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>对于柯里化函数，隐式参数只能出现最后一组参数列表上,只能是形如<code>def f(...)(...)(implicit ...)</code>这样.</p>
</li>
<li><p>隐式值不仅可以用于补足隐式参数，这个隐式值后续还能作为一种可行的隐式转换作用于方法体中的隐式类型转换，比如下面：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> me.eric.learn.`<span class="keyword">implicit</span>`</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImplicitParam</span> </span>&#123;</span><br><span class="line">  <span class="comment">//需要 Int =&gt; List[Int]类型的隐式参数</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">echo</span></span>(<span class="keyword">implicit</span>  intToList : <span class="type">Int</span> =&gt; <span class="type">List</span>[<span class="type">Int</span>]) = &#123;</span><br><span class="line">    <span class="keyword">val</span> list = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">val</span> i = <span class="number">3</span></span><br><span class="line">    <span class="comment">//此处需要隐式转换，将i转换成合适的目标类型，此处 intToList将作为一种可行的隐式转换作用于i上</span></span><br><span class="line">    println(i ::: list)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">ImplicitParam</span></span>&#123;</span><br><span class="line">  <span class="comment">//定义 Int =&gt; List[Int]的隐式值</span></span><br><span class="line">  <span class="keyword">implicit</span>  <span class="keyword">val</span> f = (i : <span class="type">Int</span>) =&gt; <span class="type">List</span>(i)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args:<span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> =&#123;</span><br><span class="line">    <span class="keyword">val</span> ip = <span class="keyword">new</span> <span class="type">ImplicitParam</span>()</span><br><span class="line">    <span class="comment">// f 作为隐式值被应用</span></span><br><span class="line">    ip.echo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>​</p>
</li>
</ol>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/10/Spark-job提交过程/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Li Weisheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/10/Spark-job提交过程/" itemprop="url">Spark job提交过程源码解析</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-10T19:38:34+08:00">
                2017-05-10
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>本文基于spark2.11</em></p>
<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><h2 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h2><ol>
<li>RDD<br>关于RDD已经有很多文章了，可以参考一下<a href="http://www.infoq.com/cn/articles/spark-core-rdd/" target="_blank" rel="noopener">理解Spark的核心RDD</a></li>
<li>依赖<br>依赖分为窄依赖和宽依赖，下图描述了两种依赖(图片出自<a href="http://blog.csdn.net/houmou/article/details/52531205" target="_blank" rel="noopener">spark窄依赖和宽依赖</a>)<br><img src="/image/spark/spark-dep.jpeg" alt="spark-dep.jpeg"><br>从途中可以看出，窄依赖中，每一个上游RDD中的分区只会被一个下游分区依赖。而宽依赖上游RDD中的分区则可能被多个下游分区依赖。宽依赖往往意味者shuffle操作</li>
<li>shuffle<br>窄依赖中，由于只存在n - 1(n&gt;=1)的依赖关系，分区上的数据可以像流水线一样一道道应用计算，大多时候不需要移动数据。宽依赖，又叫shuffle dependency，由于分区包含下游多个分区的数据，需要将数据移动到对应分区，这个过程称为shuffle</li>
<li><p>Stage<br>RDD DAG静态的描述了数据转换与依赖关系，action触发job提交时RDD DAG会被首先被划分以stage，stage划分的边界是宽依赖，也就是被划分到一个stage之内的rdd只存在窄依赖，stage之间是宽依赖。<br>有两种stage：ShuffleMapStage，ResultStage。一个job中只有一个ResultStage，是job运行的最后阶段，收集结果。</p>
</li>
<li><p>Task<br>task定义了计算任务，一个分区一个task，task根据划分好的stage生成。<br>有两种类型的task：ShuffleMapTask和ResultTask，和stage对应。</p>
</li>
</ol>
<p>spark基于RDD上有两种操作transformation和action（见<a href="http://spark.apache.org/docs/latest/programming-guide.html#transformations" target="_blank" rel="noopener">spark programming-guide</a>），transformation(map、reduceByKey这种)使得RDD转换成新的RDD，action（foreach，top这种）则产生会触发一个新的job并提交，并产生以及收集job运行的结果。</p>
<p>下面的代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">def main(args:Array[String])&#123;</span><br><span class="line">    val sparkConf = new SparkConf().setAppName(&quot;Log Query&quot;)</span><br><span class="line">    val sc = new SparkContext(sparkConf)</span><br><span class="line">    val lines = sc.textFile(&quot;README.md&quot;,3)</span><br><span class="line">    val words = lines.flatMap(line =&gt; line.split(&quot; &quot;))</span><br><span class="line">    val wordOne = words.map(word =&gt; (word,1))</span><br><span class="line">    val wordCount = wordOne.reduceByKey(_ + _,3)</span><br><span class="line">    wordCount.foreach(println)</span><br><span class="line">    val resultAsArry = wordCount.collect()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>有两个action：foreach和collect，因此会提交两个job，但是这两个job有共享了几个RDD。一个job提交会做一下几件事：</p>
<ol>
<li>DAGScheduler划分Stage<br>有两种Stage：ShuffleMapStage和ResultStage，前者划分以ShuffleDependency为边界，创建时会根据RDD往前回溯到源头，然后从源头往下创建stage。后者job最后一阶段，在所有上游ShuffleMapStage包含的任务（ShuffleMapTask）完成后收集结果</li>
<li>DAGScheduler提交Stage<br>虽说最先提交ResultStage，但是提交时会追溯上游是否有未完成的Stage，直到找到所有不依赖任何Stage或者其依赖的Stage全部完成的Stage，然后提交。意味着对各stage可能并行提交。</li>
<li>DAGScheduler根据Stage创建任务<br>这一步其实是包含在提交Stage当中的。Stage是一种静态的概念，最终运行在集群中的是task，对应ShuffleMapStage和ResultStage存在两种task：ShuffleMapTask和ResultTask。一个ShuffleMapStage包含若干窄依赖RDD组成，一个RDD又由若干partition组成，task运行在每一个partition之上，也就是说会根据ShuffleMapStage创建出多个task。 </li>
<li>提交任务<br>根据ShuffleMapStage创建多个ShuffleMapTask之后，调用TaskScheduler开始调度任务。</li>
<li>TaskScheduler调度任务<br>TaskScheduler根据任务的preferedLocation寻找合适的executor，然后将任务信息包装好发送LaunchTask到executor，让executor执行任务。</li>
<li>Executor执行任务<br>executor运行在worker之上，接受到taskScheduler的LaunchTask消息后，启动任务的执行。</li>
<li>任务状态汇报<br>任务运行信息会汇报到TaskScheduler，TaskScheduler则会汇报给DAGScheduler，DAGScheduler根据任务状态作出处理（stage中所有任务完成如提交子stage，读取上游数据失败重新提交stage等）</li>
</ol>
<h1 id="2-划分Stage"><a href="#2-划分Stage" class="headerlink" title="2. 划分Stage"></a>2. 划分Stage</h1><p>RDD上的action操作触发job的提交，提交之前会完成stage的划分，一个stage可能包含一连串的RDD之间的转换，stage的边界就是两个RDD之间的shuffle依赖,以上面代码为例,<code>wordOne.reduceByKey</code>使得wordCount和wordOne之间产生shuffle依赖，下图便是上述代码产生的RDD DAG stage的划分之后的样子</p>
<p><code>wordCount.foreach(println)</code>这类action操作触发job的提交，经过一系列调用进入到DAGScheduler的如下方法中：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">def submitJob[T, U](</span><br><span class="line">      rdd: RDD[T],</span><br><span class="line">      func: (TaskContext, Iterator[T]) =&gt; U,</span><br><span class="line">      partitions: Seq[Int],</span><br><span class="line">      callSite: CallSite,</span><br><span class="line">      resultHandler: (Int, U) =&gt; Unit,</span><br><span class="line">      properties: Properties): JobWaiter[U] = &#123;</span><br><span class="line">    // Check to make sure we are not launching a task on a partition that does not exist.</span><br><span class="line">    val maxPartitions = rdd.partitions.length</span><br><span class="line">    partitions.find(p =&gt; p &gt;= maxPartitions || p &lt; 0).foreach &#123; p =&gt;</span><br><span class="line">      throw new IllegalArgumentException(</span><br><span class="line">        &quot;Attempting to access a non-existent partition: &quot; + p + &quot;. &quot; +</span><br><span class="line">          &quot;Total number of partitions: &quot; + maxPartitions)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 每个action触发一个job，每个job一个唯一的id</span><br><span class="line">    val jobId = nextJobId.getAndIncrement()</span><br><span class="line">    if (partitions.size == 0) &#123;</span><br><span class="line">      // Return immediately if the job is running 0 tasks</span><br><span class="line">      return new JobWaiter[U](this, jobId, 0, resultHandler)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    assert(partitions.size &gt; 0)</span><br><span class="line">    val func2 = func.asInstanceOf[(TaskContext, Iterator[_]) =&gt; _]</span><br><span class="line">    val waiter = new JobWaiter(this, jobId, partitions.size, resultHandler)</span><br><span class="line">    // 向事件循环中发送一个JobSubmitted的消息</span><br><span class="line">    // 消息包含了rdd，jobid，partitions等信息</span><br><span class="line">    eventProcessLoop.post(JobSubmitted(</span><br><span class="line">      jobId, rdd, func2, partitions.toArray, callSite, waiter,</span><br><span class="line">      SerializationUtils.clone(properties)))</span><br><span class="line">    waiter</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>参数解释</strong></p>
<ol>
<li>上面方法中参数rdd即代码中<code>val wordCount</code>对应的rdd</li>
<li>参数func，由println包装成的，下文会提到，这个func只会作用于ResultStage。</li>
<li>partiitions，rdd包含的分区</li>
<li>resulthandler，返回结果时回调</li>
</ol>
<p>上面代码中并未提交job，而是发送JobSubmited消息给eventProcessLoop，由其异步的提交job。下面是eventProcessLoop的类DAGSchedulerEventProcessLoop处理接收到的消息的代码逻辑：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">private def doOnReceive(event: DAGSchedulerEvent): Unit = event match &#123;</span><br><span class="line">    case JobSubmitted(jobId, rdd, func, partitions, callSite, listener, properties) =&gt;</span><br><span class="line">      dagScheduler.handleJobSubmitted(jobId, rdd, func, partitions, callSite, listener, properties)</span><br><span class="line">   // 此处省略了其它情况</span><br><span class="line">    case ...</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>接受到JobShumitted消息后，调用dagScheduler.handlerJobSummited提交job。下面是handleJobSubmitted的核心代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private[scheduler] def handleJobSubmitted(jobId: Int,</span><br><span class="line">      finalRDD: RDD[_],</span><br><span class="line">      func: (TaskContext, Iterator[_]) =&gt; _,</span><br><span class="line">      partitions: Array[Int],</span><br><span class="line">      callSite: CallSite,</span><br><span class="line">      listener: JobListener,</span><br><span class="line">      properties: Properties) &#123;</span><br><span class="line">    var finalStage: ResultStage = null</span><br><span class="line">    try &#123;</span><br><span class="line">      // New stage creation may throw an exception if, for example, jobs are run on a</span><br><span class="line">      // HadoopRDD whose underlying HDFS files have been deleted.</span><br><span class="line">      finalStage = createResultStage(finalRDD, func, partitions, jobId, callSite)</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">        ...</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    val job = new ActiveJob(jobId, finalStage, callSite, listener, properties)</span><br><span class="line">   ...</span><br><span class="line">    logInfo(&quot;Parents of final stage: &quot; + finalStage.parents)</span><br><span class="line">    logInfo(&quot;Missing parents: &quot; + getMissingParentStages(finalStage))</span><br><span class="line"></span><br><span class="line">    val jobSubmissionTime = clock.getTimeMillis()</span><br><span class="line">    jobIdToActiveJob(jobId) = job</span><br><span class="line">    activeJobs += job</span><br><span class="line">    finalStage.setActiveJob(job)</span><br><span class="line">    val stageIds = jobIdToStageIds(jobId).toArray</span><br><span class="line">    val stageInfos = stageIds.flatMap(id =&gt; stageIdToStage.get(id).map(_.latestInfo))</span><br><span class="line">    listenerBus.post(</span><br><span class="line">      SparkListenerJobStart(job.jobId, jobSubmissionTime, stageInfos, properties))</span><br><span class="line">    submitStage(finalStage)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>上述代码最后调用submitStage提交stage。在此之前需要创建stage，上面方法中有两个地方可能会创建stage。</p>
<ol>
<li>createResultStage</li>
<li>getMissingParentStages</li>
</ol>
<p>前面提到Stage分为两种：ResultStage和ShuffleMapStage，对于一个job而言，ResultStage是其最后阶段，收集job运行的结果,一个job对应的RDD DAG划分中，只存在一个ResultStage和多个ShuffleMapStage。</p>
<p>上面1中createResultStage会创建ResultStage，但是ResultStage，创建过程中会判断当前stage是否存在依赖上游stage，如果存在就会一直往上游追溯，从上至下创建。每一个stage有一个id，创建出来的stage根据id缓存，避免重复创建。</p>
<p>上面2中getMissingParentStages，则会在当前stage有上游依赖时递归的创建所有的上游依赖。</p>
<p>下图描述了1,2两个方法的调用图，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">creatResultStage               getMissingParentStages</span><br><span class="line">           |                          |</span><br><span class="line">           |__________________________|</span><br><span class="line">           v</span><br><span class="line">getOrCreateParentStages &lt;---------------------|</span><br><span class="line">          |                                   |</span><br><span class="line">          v                                   |</span><br><span class="line">getOrCreateShuffleMapStage                    |</span><br><span class="line">         |  当前以及所有存在的上游stage都要创建     |                                    |</span><br><span class="line">         v                                    |</span><br><span class="line">createShuffleMapStage-------------------------| 尝试创建上游stage，然后创建自己</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>createResultStage</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">private def createResultStage(</span><br><span class="line">     rdd: RDD[_],</span><br><span class="line">     func: (TaskContext, Iterator[_]) =&gt; _,</span><br><span class="line">     partitions: Array[Int],</span><br><span class="line">     jobId: Int,</span><br><span class="line">     callSite: CallSite): ResultStage = &#123;</span><br><span class="line">   val parents = getOrCreateParentStages(rdd, jobId)</span><br><span class="line">   val id = nextStageId.getAndIncrement()</span><br><span class="line">   val stage = new ResultStage(id, rdd, func, partitions, parents, jobId, callSite)</span><br><span class="line">   stageIdToStage(id) = stage</span><br><span class="line">   updateJobIdStageIdMaps(jobId, stage)</span><br><span class="line">   stage</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>上述代码中，先是调用getOrCreateParentStages,递归的创建所有上游的stage</li>
<li>stageId是ResultStage的id，这里是递增的，但是下面说道ShuffleMapStage的id则是shuffleid</li>
</ul>
</li>
<li><p>getOrCreateParentStages<br>方法代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private def getOrCreateParentStages(rdd: RDD[_], firstJobId: Int): List[Stage] = &#123;</span><br><span class="line">    getShuffleDependencies(rdd).map &#123; shuffleDep =&gt;</span><br><span class="line">      getOrCreateShuffleMapStage(shuffleDep, firstJobId)</span><br><span class="line">    &#125;.toList</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>getShuffleDependencies(rdd)，一直追溯rdd的依赖直到依赖类型为ShuffleDenpendency，这个方法实现了广度遍历的过程。而且它只返回rdd的直属父shuffle依赖，祖先shuffle依赖不返回，下面有个例子说明：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  E &lt;------ A &lt;------ B &lt;------- C</span><br><span class="line">                                  |</span><br><span class="line">                       D &lt;--------|</span><br><span class="line">假设上面都是shuffle依赖，getShuffleDependedency(C)只返回B，D</span><br></pre></td></tr></table></figure></p>
<p>回到方法本身，对C的每一个shuffle依赖B，D，调用<code>getOrCreateShuffleMapStage</code>创建stage。</p>
<ol>
<li><p>getOrCreateShuffleMapStage<br>假设先对B创建stage，代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">private def getOrCreateShuffleMapStage(</span><br><span class="line">      shuffleDep: ShuffleDependency[_, _, _],</span><br><span class="line">      firstJobId: Int): ShuffleMapStage = &#123;</span><br><span class="line">    shuffleIdToMapStage.get(shuffleDep.shuffleId) match &#123;</span><br><span class="line">      case Some(stage) =&gt;</span><br><span class="line">        stage</span><br><span class="line"></span><br><span class="line">      case None =&gt;</span><br><span class="line">        // Create stages for all missing ancestor shuffle dependencies.</span><br><span class="line">        getMissingAncestorShuffleDependencies(shuffleDep.rdd).foreach &#123; dep =&gt;</span><br><span class="line">          // Even though getMissingAncestorShuffleDependencies only returns shuffle dependencies</span><br><span class="line">          // that were not already in shuffleIdToMapStage, it&apos;s possible that by the time we</span><br><span class="line">          // get to a particular dependency in the foreach loop, it&apos;s been added to</span><br><span class="line">          // shuffleIdToMapStage by the stage creation process for an earlier dependency. See</span><br><span class="line">          // SPARK-13902 for more information.</span><br><span class="line">          if (!shuffleIdToMapStage.contains(dep.shuffleId)) &#123;</span><br><span class="line">            createShuffleMapStage(dep, firstJobId)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // Finally, create a stage for the given shuffle dependency.</span><br><span class="line">        createShuffleMapStage(shuffleDep, firstJobId)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>参数shuffleDep，即C到B的依赖,shuffleDep.rdd即为B</li>
<li>getMissingAncestorShuffleDependencies(B)，此时会返回B所有的祖先shuffle 依赖，也就是 B对A的依赖，和A对E的依赖</li>
<li>下面4中代码中，每个ShuffleMapStage创建后都会映射到shuffle id上，假设新建的ShuffleMapStage作用于B，那么他映射的shuffleid就是B&lt;-C之间的shuffle的id。因此方法里可以根据shuffleId到shuffleIdToMapStage检索，避免重复创建，</li>
<li>对于不存在的ShuffleMapStage， 调用createShuffleMapStage创建stage。</li>
</ul>
</li>
<li><p>createShuffleMapStage<br>对于B而言，先创建A，代码如下：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">createShuffleMapStage</span></span>(shuffleDep: <span class="type">ShuffleDependency</span>[_, _, _], jobId: <span class="type">Int</span>): <span class="type">ShuffleMapStage</span> = &#123;</span><br><span class="line"> <span class="keyword">val</span> rdd = shuffleDep.rdd</span><br><span class="line"> <span class="keyword">val</span> numTasks = rdd.partitions.length</span><br><span class="line"> <span class="keyword">val</span> parents = getOrCreateParentStages(rdd, jobId)</span><br><span class="line"> <span class="keyword">val</span> id = nextStageId.getAndIncrement()</span><br><span class="line"> <span class="keyword">val</span> stage = <span class="keyword">new</span> <span class="type">ShuffleMapStage</span>(id, rdd, numTasks, parents, jobId, rdd.creationSite, shuffleDep)</span><br><span class="line"></span><br><span class="line"> stageIdToStage(id) = stage</span><br><span class="line"> shuffleIdToMapStage(shuffleDep.shuffleId) = stage</span><br><span class="line"> updateJobIdStageIdMaps(jobId, stage)</span><br><span class="line"></span><br><span class="line"> <span class="keyword">if</span> (mapOutputTracker.containsShuffle(shuffleDep.shuffleId)) &#123;</span><br><span class="line">   <span class="comment">// A previously run stage generated partitions for this shuffle, so for each output</span></span><br><span class="line">   <span class="comment">// that's still available, copy information about that output location to the new stage</span></span><br><span class="line">   <span class="comment">// (so we don't unnecessarily re-compute that data).</span></span><br><span class="line">   <span class="keyword">val</span> serLocs = mapOutputTracker.getSerializedMapOutputStatuses(shuffleDep.shuffleId)</span><br><span class="line">   <span class="keyword">val</span> locs = <span class="type">MapOutputTracker</span>.deserializeMapStatuses(serLocs)</span><br><span class="line">   (<span class="number">0</span> until locs.length).foreach &#123; i =&gt;</span><br><span class="line">     <span class="keyword">if</span> (locs(i) ne <span class="literal">null</span>) &#123;</span><br><span class="line">       <span class="comment">// locs(i) will be null if missing</span></span><br><span class="line">       stage.addOutputLoc(i, locs(i))</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">   <span class="comment">// Kind of ugly: need to register RDDs with the cache and map output tracker here</span></span><br><span class="line">   <span class="comment">// since we can't do it in the RDD constructor because # of partitions is unknown</span></span><br><span class="line">   logInfo(<span class="string">"Registering RDD "</span> + rdd.id + <span class="string">" ("</span> + rdd.getCreationSite + <span class="string">")"</span>)</span><br><span class="line">   mapOutputTracker.registerShuffle(shuffleDep.shuffleId, rdd.partitions.length)</span><br><span class="line"> &#125;</span><br><span class="line"> stage</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>此时shuffleDep即B-&gt;A的依赖，shuffleDep.rdd就是A</li>
<li>上述代码又getOrCreateParentStages(A)创建A的上游，A上游是E，E没有上游节点，此处E所所处ShuffleMapStage被创建，stageid即A-&gt;E的shuffleId，stage作用于E</li>
<li>所有的上游stages创建完成了，创建当前shuffleDep产生的ShuffleMapStage。建立shuffleId到ShuffleMapStage的映射</li>
<li>shuffleId在建立RDD DAG图之后就是一直不变的，而stageId每提交一次job都会变动，同一个job可能因为某个环节失败了重新提交，但是失败的job中的某个ShuffleMapStage的输出数据可是完好的可重复利用。if分支使用mapoutTracker检查特定shuffle阶段的数据是不是完好的，然后可以重复利用，避免再此计算。</li>
<li>创建stage之后就返回上一层。</li>
</ul>
</li>
</ol>
<p>下图描述了最终创建出来的stage的依赖图：</p>
<h1 id="3-提交stage"><a href="#3-提交stage" class="headerlink" title="3 提交stage"></a>3 提交stage</h1><p>第2节最前面，handleJobSubmitted，创建完所有stage之后调用submitStage(finalStage)提交stage,代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> def <span class="title">submitStage</span><span class="params">(stage: Stage)</span> </span>&#123;</span><br><span class="line">   val jobId = activeJobForStage(stage)</span><br><span class="line">   <span class="keyword">if</span> (jobId.isDefined) &#123;</span><br><span class="line">     logDebug(<span class="string">"submitStage("</span> + stage + <span class="string">")"</span>)</span><br><span class="line">     <span class="keyword">if</span> (!waitingStages(stage) &amp;&amp; !runningStages(stage) &amp;&amp; !failedStages(stage)) &#123;</span><br><span class="line">       val missing = getMissingParentStages(stage).sortBy(_.id)</span><br><span class="line">       logDebug(<span class="string">"missing: "</span> + missing)</span><br><span class="line">       <span class="keyword">if</span> (missing.isEmpty) &#123;</span><br><span class="line">         logInfo(<span class="string">"Submitting "</span> + stage + <span class="string">" ("</span> + stage.rdd + <span class="string">"), which has no missing parents"</span>)</span><br><span class="line">         submitMissingTasks(stage, jobId.get)</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="keyword">for</span> (parent &lt;- missing) &#123;</span><br><span class="line">           submitStage(parent)</span><br><span class="line">         &#125;</span><br><span class="line">         waitingStages += stage</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     abortStage(stage, <span class="string">"No active job for stage "</span> + stage.id, None)</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>waitingStages、runningStage、failedStages分别记录那些还有未完成的上游stage的stage、正在executor上运行的stage和失败的stages</li>
<li>getMissingParentStages获得没有提交或者没有完成的上游stage，stage不存在就创建</li>
<li>submitMissingTasks在没有未完成的上游stage的情况下，提交当前stage</li>
<li>有上游stage未完成，将当前stage加入到waitingStages队列中</li>
</ol>
<p>上面submitStages代码中将根据stage创建任务提交的是submitMissingTasks，其代码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> def <span class="title">submitMissingTasks</span><span class="params">(stage: Stage, jobId: Int)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// stage可能被多次提交，stage作用的rdd可能在之前几次提交运行中有写</span></span><br><span class="line">  partition已经有了计算计算，先找出没有结果的partition</span><br><span class="line">  val partitionsToCompute: Seq[Int] = stage.findMissingPartitions()</span><br><span class="line">  ...</span><br><span class="line">  <span class="comment">// 一个分区一个task，找出一组task运行的位置</span></span><br><span class="line">  val taskIdToLocations: Map[Int, Seq[TaskLocation]] = <span class="keyword">try</span> &#123;</span><br><span class="line">    stage match &#123;</span><br><span class="line">      <span class="keyword">case</span> s: ShuffleMapStage =&gt;</span><br><span class="line">        partitionsToCompute.map &#123; id =&gt; (id, getPreferredLocs(stage.rdd, id))&#125;.toMap</span><br><span class="line">      <span class="keyword">case</span> s: ResultStage =&gt;</span><br><span class="line">        partitionsToCompute.map &#123; id =&gt;</span><br><span class="line">          val p = s.partitions(id)</span><br><span class="line">          (id, getPreferredLocs(stage.rdd, p))</span><br><span class="line">        &#125;.toMap</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">   <span class="comment">// stage只有一个stageId，但是stage的每次提交都会有新的attempId</span></span><br><span class="line">  stage.makeNewStageAttempt(partitionsToCompute.size, taskIdToLocations.values.toSeq)</span><br><span class="line">  listenerBus.post(SparkListenerStageSubmitted(stage.latestInfo, properties))</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据stage序列化任务信息，ShuffleMapStage对应ShuffleMapTask，主要信息有task运行作用的rdd，和依赖</span></span><br><span class="line">  <span class="comment">// ResultStage对应ResultTask，主要信息有rdd和func（这个func就是前面wordCount代码中foreach 这个action的参数转换来的，只有ResultStage有）</span></span><br><span class="line">  var taskBinary: Broadcast[Array[Byte]] = <span class="keyword">null</span></span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line"> </span><br><span class="line">    val taskBinaryBytes: Array[Byte] = stage match &#123;</span><br><span class="line">      <span class="keyword">case</span> stage: ShuffleMapStage =&gt;</span><br><span class="line">        JavaUtils.bufferToArray(</span><br><span class="line">          closureSerializer.serialize((stage.rdd, stage.shuffleDep): AnyRef))</span><br><span class="line">      <span class="keyword">case</span> stage: ResultStage =&gt;</span><br><span class="line">        JavaUtils.bufferToArray(closureSerializer.serialize((stage.rdd, stage.func): AnyRef))</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 将task信息作为广播变量传输，executor执行task时需要根据广播变量获取task信息，task很多时，使用广播变量传输能有效减少driver上的压力</span></span><br><span class="line">    taskBinary = sc.broadcast(taskBinaryBytes)</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"> <span class="comment">// 创建task，一个分区一个task</span></span><br><span class="line">  val tasks: Seq[Task[_]] = <span class="keyword">try</span> &#123;</span><br><span class="line">    val serializedTaskMetrics = closureSerializer.serialize(stage.latestInfo.taskMetrics).array()</span><br><span class="line">    stage match &#123;</span><br><span class="line">      <span class="keyword">case</span> stage: ShuffleMapStage =&gt;</span><br><span class="line">        stage.pendingPartitions.clear()</span><br><span class="line">        partitionsToCompute.map &#123; id =&gt;</span><br><span class="line">          val locs = taskIdToLocations(id)</span><br><span class="line">          val part = stage.rdd.partitions(id)</span><br><span class="line">          stage.pendingPartitions += id</span><br><span class="line">          <span class="keyword">new</span> ShuffleMapTask(stage.id, stage.latestInfo.attemptId,</span><br><span class="line">            taskBinary, part, locs, properties, serializedTaskMetrics, Option(jobId),</span><br><span class="line">            Option(sc.applicationId), sc.applicationAttemptId)</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> stage: ResultStage =&gt;</span><br><span class="line">        partitionsToCompute.map &#123; id =&gt;</span><br><span class="line">          val p: Int = stage.partitions(id)</span><br><span class="line">          val part = stage.rdd.partitions(p)</span><br><span class="line">          val locs = taskIdToLocations(id)</span><br><span class="line">          <span class="keyword">new</span> ResultTask(stage.id, stage.latestInfo.attemptId,</span><br><span class="line">            taskBinary, part, locs, id, properties, serializedTaskMetrics,</span><br><span class="line">            Option(jobId), Option(sc.applicationId), sc.applicationAttemptId)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">case</span> <span class="title">NonFatal</span><span class="params">(e)</span> </span>=&gt;</span><br><span class="line">      abortStage(stage, s<span class="string">"Task creation failed: $e\n$&#123;Utils.exceptionString(e)&#125;"</span>, Some(e))</span><br><span class="line">      runningStages -= stage</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">if</span> (tasks.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    logInfo(s<span class="string">"Submitting $&#123;tasks.size&#125; missing tasks from $stage ($&#123;stage.rdd&#125;) (first 15 "</span> +</span><br><span class="line">      s<span class="string">"tasks are for partitions $&#123;tasks.take(15).map(_.partitionId)&#125;)"</span>)</span><br><span class="line">    <span class="comment">// 使用TaskScheduler提交tasks</span></span><br><span class="line">    taskScheduler.submitTasks(<span class="keyword">new</span> TaskSet(</span><br><span class="line">      tasks.toArray, stage.id, stage.latestInfo.attemptId, jobId, properties))</span><br><span class="line">    stage.latestInfo.submissionTime = Some(clock.getTimeMillis())</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// Because we posted SparkListenerStageSubmitted earlier, we should mark</span></span><br><span class="line">    <span class="comment">// the stage as completed here in case there are no tasks to run</span></span><br><span class="line">    markStageAsFinished(stage, None)</span><br><span class="line"></span><br><span class="line">    val debugString = stage match &#123;</span><br><span class="line">      <span class="keyword">case</span> stage: ShuffleMapStage =&gt;</span><br><span class="line">        s<span class="string">"Stage $&#123;stage&#125; is actually done; "</span> +</span><br><span class="line">          s<span class="string">"(available: $&#123;stage.isAvailable&#125;,"</span> +</span><br><span class="line">          s<span class="string">"available outputs: $&#123;stage.numAvailableOutputs&#125;,"</span> +</span><br><span class="line">          s<span class="string">"partitions: $&#123;stage.numPartitions&#125;)"</span></span><br><span class="line">      <span class="keyword">case</span> stage : ResultStage =&gt;</span><br><span class="line">        s<span class="string">"Stage $&#123;stage&#125; is actually done; (partitions: $&#123;stage.numPartitions&#125;)"</span></span><br><span class="line">    &#125;</span><br><span class="line">    logDebug(debugString)</span><br><span class="line">    submitWaitingChildStages(stage)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面在代码注释中简单介绍了Stage转换成Task，然后使用TaskScheduler提交的过程。</p>
<p>关于TaskScheduler对任务的管理和提交见另一篇文章<a href="">Spark 任务调度-TaskScheduler</a>。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/05/09/Spark-Streaming-3-Receiver和ReceiverTacker/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Li Weisheng">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/09/Spark-Streaming-3-Receiver和ReceiverTacker/" itemprop="url">Spark Streaming(3) - Receiver和ReceiverTacker</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-09T23:15:07+08:00">
                2017-05-09
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><em>本文基于spark 2.11</em></p>
<h1 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h1><p>在Spark Streaming(1)中介绍spark streaming工作流程中时，大致介绍了streaming job在运行时从stream中读取数据的流程：</p>
<ol>
<li>Receiver运行在executor上接收数据，将数据转交给ReceiverSupervisor，然后ReceiverSupervisor利用blockmanager存储好数据，并将数据块信息汇报给ReceiverTracker。</li>
<li>ReceiverTracker运行在Driver上，接收数据块信息保存，后续在JobGenerator生成新jobs时分配数据作为新jobs的数据源。</li>
</ol>
<p>本文将详细介绍上述流程。</p>
<h1 id="2-ReceiverTracker"><a href="#2-ReceiverTracker" class="headerlink" title="2 ReceiverTracker"></a>2 ReceiverTracker</h1><p>ReceiverTracker有以下核心成员：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private val receiverInputStreams = ssc.graph.getReceiverInputStreams()</span><br><span class="line">private val receiverInputStreamIds = receiverInputStreams.map &#123; _.id &#125;</span><br><span class="line">private val receivedBlockTracker = ...</span><br></pre></td></tr></table></figure></p>
<ol>
<li>receiverInputStreams,DStreamGraph保存的所有DStream Graph所有的实现了ReceiverInputDStream类DStream，意味着这些DStream持有receiver，能够发送在executor启动执行接收流数据的任务。</li>
<li>每一个receiver都有一个id，receiver汇报自己的数据时一并汇报自己的id，DStream DAG源头的ReceiverInputDStream使用receiverTracker获取属于数据时就根据自己的id知道应该取哪些数据。</li>
<li>receivedBlockTracker，后面会讲。</li>
</ol>
<h2 id="2-1-ReceiverTracker的启动"><a href="#2-1-ReceiverTracker的启动" class="headerlink" title="2.1 ReceiverTracker的启动"></a>2.1 ReceiverTracker的启动</h2><p>先在Driver端启动ReceiverTracker，是在JobScheduler启动时完成，有如下调用序列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">StreamingContext#start</span><br><span class="line">   -&gt;JobScheduler#start</span><br><span class="line">      -&gt;ReceiverTracker#start</span><br></pre></td></tr></table></figure></p>
<p>下面则是ReceiverTracker的方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">def start(): Unit = synchronized &#123;</span><br><span class="line">    if (isTrackerStarted) &#123;</span><br><span class="line">      throw new SparkException(&quot;ReceiverTracker already started&quot;)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (!receiverInputStreams.isEmpty) &#123;</span><br><span class="line">      endpoint = ssc.env.rpcEnv.setupEndpoint(</span><br><span class="line">        &quot;ReceiverTracker&quot;, new ReceiverTrackerEndpoint(ssc.env.rpcEnv))</span><br><span class="line">      if (!skipReceiverLaunch) launchReceivers()</span><br><span class="line">      logInfo(&quot;ReceiverTracker started&quot;)</span><br><span class="line">      trackerState = Started</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到start代码中在rpcEnv上注册了一个Rpc服务（关于spark 的Rcp原理可以参考<a href="http://www.jianshu.com/p/7da49e332e70" target="_blank" rel="noopener">spark网络通信-RPC的实现</a>）</p>
<p>可以看看它注册的receiverTrackerEndpoint的receive和receiveAdnreply方法看看它就收什么消息，提供什么服务：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">override def receive: PartialFunction[Any, Unit] = &#123;</span><br><span class="line">      // Local messages</span><br><span class="line">      case StartAllReceivers(receivers) =&gt;</span><br><span class="line">          ...</span><br><span class="line">          //这个消息是自己发给自己的，在executor上启动receiver</span><br><span class="line">          startReceiver(receiver, executors)</span><br><span class="line">        &#125;</span><br><span class="line">      case RestartReceiver(receiver) =&gt;</span><br><span class="line">        ...</span><br><span class="line">        startReceiver(receiver, scheduledLocations)</span><br><span class="line">      case c: CleanupOldBlocks =&gt;</span><br><span class="line">        // 处理过了batch数据可以清除了</span><br><span class="line">        ...</span><br><span class="line">      case ReportError(streamId, message, error) =&gt;</span><br><span class="line">        reportError(streamId, message, error)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    override def receiveAndReply(context: RpcCallContext): PartialFunction[Any, Unit] = &#123;</span><br><span class="line">      // Remote messages</span><br><span class="line">      case RegisterReceiver(streamId, typ, host, executorId, receiverEndpoint) =&gt;</span><br><span class="line">         ...</span><br><span class="line">        // receiver在executor上启动之后会将自己注册到ReceiverTracker上，好让它感知到</span><br><span class="line">      case DeregisterReceiver(streamId, message, error) =&gt;</span><br><span class="line">        deregisterReceiver(streamId, message, error)</span><br><span class="line">        context.reply(true)</span><br><span class="line"></span><br><span class="line">      // Local messages</span><br><span class="line">     case AddBlock(receivedBlockInfo) =&gt;</span><br><span class="line">      // 接收receiver上报的数据信息</span><br><span class="line">     ...</span><br><span class="line">      case AllReceiverIds =&gt;</span><br><span class="line">        context.reply(receiverTrackingInfos.filter(_._2.state != ReceiverState.INACTIVE).keys.toSeq)</span><br><span class="line">      case GetAllReceiverInfo =&gt;</span><br><span class="line">        context.reply(receiverTrackingInfos.toMap)</span><br><span class="line">      case StopAllReceivers =&gt;</span><br><span class="line">        assert(isTrackerStopping || isTrackerStopped)</span><br><span class="line">        stopReceivers()</span><br><span class="line">        context.reply(true)</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>从上面可以它提供的服务包括注册启动receivers，注册和销毁数据等。</p>
<p>在回到start方法中调用<code>launchReceivers()</code>启动receiver。</p>
<h2 id="2-2-ReceiverTracker-处理receiver汇报的数据"><a href="#2-2-ReceiverTracker-处理receiver汇报的数据" class="headerlink" title="2.2 ReceiverTracker 处理receiver汇报的数据"></a>2.2 ReceiverTracker 处理receiver汇报的数据</h2><p>ReceiverTracker的rpc服务接收到AddBlock()消息表示接收到receiver汇报的数据信息。</p>
<p>先看看AddBlock消息的结构：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// AddBlock消息包含了ReceiverdBlockInfo,这里存储了receiver上报的数据具体信息</span><br><span class="line">private[streaming] case class AddBlock(receivedBlockInfo: ReceivedBlockInfo)</span><br><span class="line"></span><br><span class="line">// 上报了streamId，numRecords表示本次batch中记录数,</span><br><span class="line">// blockStoreResult  有两个实现类：</span><br><span class="line">//.       1. BlockManagerBasedStoreResult，receiver端使用blockmanager管理batch数据</span><br><span class="line">//        2. WriteAheadLogBasedStoreResult, receiver端使用了WAL保存了batch数据</span><br><span class="line">//.     关于这两种方式会在Receiver端时解释</span><br><span class="line">private[streaming] case class ReceivedBlockInfo(</span><br><span class="line">    streamId: Int,</span><br><span class="line">    numRecords: Option[Long],</span><br><span class="line">    metadataOption: Option[Any],</span><br><span class="line">    blockStoreResult: ReceivedBlockStoreResult</span><br><span class="line">  ) &#123;...&#125;</span><br></pre></td></tr></table></figure></p>
<p>再回到到rpc服务接收到AddBlock的处理，进入如下调用序列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">case AddBlock =&gt;. 接收到AddBlock消息</span><br><span class="line">    -&gt; ReceiverTracker#addBlock</span><br><span class="line">     -&gt; ReceivedBlockTracker#addBlock 使用receivedBlockTracker来管理上报的数据</span><br></pre></td></tr></table></figure></p>
<p><strong>ReceiveBlockTracker</strong><br>接收到的消息最终时通过ReceivedBlockTracker来管理的，下面两个成员涉及到ReceivedBlockTracker管理上报的数据信息：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">private type ReceivedBlockQueue = mutable.Queue[ReceivedBlockInfo]</span><br><span class="line"></span><br><span class="line">  private val streamIdToUnallocatedBlockQueues = new mutable.HashMap[Int, ReceivedBlockQueue]</span><br><span class="line">  private val timeToAllocatedBlocks = new mutable.HashMap[Time, AllocatedBlocks]</span><br></pre></td></tr></table></figure></p>
<ol>
<li>ReceivedBlockQueue，定义这个类型，后边的所有数据信息是保存在队列里的</li>
<li>streamIdToUnallocatedBlockQueues，首先上报的数据是安streamId区分开来的，这个队列保存上报上来的，但是还还没有分配给某个job的的数据。</li>
<li>timeToAllocatedBlocks，JobGenerator生成job时请求receiverTracker分配数据给job，receiverTracker调用ReceiveBlockTracker分配数据，数据时间（job生成时间），streamId索引到，job对应的RDD DAG就能根据时间和streamId从这里去数据。</li>
</ol>
<p>到这里ReceiveBlockTracker的addBlock的工作就清楚了将上报的数据保存到streamIdToUnallocatedBlockQueues就行了。</p>
<h2 id="2-3-ReceiverTracker-为job分配数据"><a href="#2-3-ReceiverTracker-为job分配数据" class="headerlink" title="2.3 ReceiverTracker 为job分配数据"></a>2.3 ReceiverTracker 为job分配数据</h2><p><a href="http://www.jianshu.com/p/8a28a711400a" target="_blank" rel="noopener">Spark Streaming(2)</a>中第3节介绍JobGenerator生成job是方法generateJobs调用了<code>receiverTracker.allocateBlocksToBatch</code>为job分配输入数据，分配数据的工作同样委派给ReceiveBlockTracker，下面是其allocateBlocksToBatch方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">def allocateBlocksToBatch(batchTime: Time): Unit = synchronized &#123;</span><br><span class="line">    if (lastAllocatedBatchTime == null || batchTime &gt; lastAllocatedBatchTime) &#123;</span><br><span class="line">     // 将streamIdToUnallocatedBlockQueues中的数据全部取出来按照streamId区分</span><br><span class="line">      val streamIdToBlocks = streamIds.map &#123; streamId =&gt;</span><br><span class="line">          (streamId, getReceivedBlockQueue(streamId).dequeueAll(x =&gt; true))</span><br><span class="line">      &#125;.toMap</span><br><span class="line">      val allocatedBlocks = AllocatedBlocks(streamIdToBlocks)</span><br><span class="line">      if (writeToLog(BatchAllocationEvent(batchTime, allocatedBlocks))) &#123;</span><br><span class="line">      // 保存到timeToAllocatedBlocks，job里处于输入源的DStream根据自己的时间的streamId取数据转换成BlockRDD。</span><br><span class="line">        timeToAllocatedBlocks.put(batchTime, allocatedBlocks)</span><br><span class="line">        lastAllocatedBatchTime = batchTime</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        logInfo(s&quot;Possibly processed batch $batchTime needs to be processed again in WAL recovery&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">   </span><br><span class="line">      logInfo(s&quot;Possibly processed batch $batchTime needs to be processed again in WAL recovery&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<h1 id="3-Receiver和ReceiverSupervisor"><a href="#3-Receiver和ReceiverSupervisor" class="headerlink" title="3. Receiver和ReceiverSupervisor"></a>3. Receiver和ReceiverSupervisor</h1><p>2.1中提到ReceiverTracker的start方法调用launchReceivers启动receiver, 在receiver启动之前的调用是这样的：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReceiverTracker#start</span><br><span class="line">   -&gt;ReceiverTracker#launchReceivers</span><br><span class="line">         -&gt; ReceiverTrackerEndpoint#send(StartAllReceivers(receivers))</span><br><span class="line">                                               | 给rpc服务发送StartAllReceivers消息</span><br><span class="line">                                               v</span><br><span class="line">    rpc服务收到消息    ReceiverTrackerEndpoint#receive </span><br><span class="line">                      -&gt;ReceiverTracker#startReceiver  在executor上启动receiver</span><br></pre></td></tr></table></figure></p>
<p><strong>receiver的获取</strong><br>spark streaming(1) 的2.2节提到ReceiverInputDStream需要返回一个receiver。<br><strong>启动receiver</strong></p>
<ol>
<li>launchReceivers 从ReceiverTracker#receiverInputStreams成员中最终获取到所有receivers，</li>
<li>给自己持有的rpc发送StartAllReceivers消息</li>
<li>接收到消息的rpc服务调用ReceiverTracker#startReceiver</li>
</ol>
<p>核心在startReceiver，下面代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line">private def startReceiver(</span><br><span class="line">       receiver: Receiver[_],</span><br><span class="line">       scheduledLocations: Seq[TaskLocation]): Unit = &#123;</span><br><span class="line">     def shouldStartReceiver: Boolean = &#123;</span><br><span class="line">       // It&apos;s okay to start when trackerState is Initialized or Started</span><br><span class="line">       !(isTrackerStopping || isTrackerStopped)</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     val receiverId = receiver.streamId</span><br><span class="line">     if (!shouldStartReceiver) &#123;</span><br><span class="line">       onReceiverJobFinish(receiverId)</span><br><span class="line">       return</span><br><span class="line">     &#125;</span><br><span class="line"></span><br><span class="line">     val checkpointDirOption = Option(ssc.checkpointDir)</span><br><span class="line">     val serializableHadoopConf =</span><br><span class="line">       new SerializableConfiguration(ssc.sparkContext.hadoopConfiguration)</span><br><span class="line"></span><br><span class="line">     // 这个函数会在receiver相关信息发送到executor上执行</span><br><span class="line">     val startReceiverFunc: Iterator[Receiver[_]] =&gt; Unit =</span><br><span class="line">       (iterator: Iterator[Receiver[_]]) =&gt; &#123;</span><br><span class="line">         if (!iterator.hasNext) &#123;</span><br><span class="line">           throw new SparkException(</span><br><span class="line">             &quot;Could not start receiver as object not found.&quot;)</span><br><span class="line">         &#125;</span><br><span class="line">         if (TaskContext.get().attemptNumber() == 0) &#123;</span><br><span class="line">           val receiver = iterator.next()</span><br><span class="line">           assert(iterator.hasNext == false)</span><br><span class="line">           // 启动receiverSupervisor</span><br><span class="line">           val supervisor = new ReceiverSupervisorImpl(</span><br><span class="line">             receiver, SparkEnv.get, serializableHadoopConf.value, checkpointDirOption)</span><br><span class="line">           supervisor.start()</span><br><span class="line">           supervisor.awaitTermination()</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">           // It&apos;s restarted by TaskScheduler, but we want to reschedule it again. So exit it.</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">     // 创建了RDD，RDD的数据就是receivers组成的，结合上面的函数startReceiverFunc运行在RDD的数据上，也就是接收receiver作为参数运行</span><br><span class="line">    </span><br><span class="line">     val receiverRDD: RDD[Receiver[_]] =</span><br><span class="line">       if (scheduledLocations.isEmpty) &#123;</span><br><span class="line">         ssc.sc.makeRDD(Seq(receiver), 1)</span><br><span class="line">       &#125; else &#123;</span><br><span class="line">         val preferredLocations = scheduledLocations.map(_.toString).distinct</span><br><span class="line">         ssc.sc.makeRDD(Seq(receiver -&gt; preferredLocations))</span><br><span class="line">       &#125;</span><br><span class="line">     receiverRDD.setName(s&quot;Receiver $receiverId&quot;)</span><br><span class="line">     ssc.sparkContext.setJobDescription(s&quot;Streaming job running receiver $receiverId&quot;)</span><br><span class="line">     ssc.sparkContext.setCallSite(Option(ssc.getStartSite()).getOrElse(Utils.getCallSite()))</span><br><span class="line"></span><br><span class="line">    // RDD生成job提交运行</span><br><span class="line">     val future = ssc.sparkContext.submitJob[Receiver[_], Unit, Unit](</span><br><span class="line">       receiverRDD, startReceiverFunc, Seq(0), (_, _) =&gt; Unit, ())</span><br><span class="line">     // We will keep restarting the receiver job until ReceiverTracker is stopped</span><br><span class="line">     future.onComplete &#123;</span><br><span class="line">       case Success(_) =&gt;</span><br><span class="line">         if (!shouldStartReceiver) &#123;</span><br><span class="line">           onReceiverJobFinish(receiverId)</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">           logInfo(s&quot;Restarting Receiver $receiverId&quot;)</span><br><span class="line">           self.send(RestartReceiver(receiver))</span><br><span class="line">         &#125;</span><br><span class="line">       case Failure(e) =&gt;</span><br><span class="line">         if (!shouldStartReceiver) &#123;</span><br><span class="line">           onReceiverJobFinish(receiverId)</span><br><span class="line">         &#125; else &#123;</span><br><span class="line">           logError(&quot;Receiver has been stopped. Try to restart it.&quot;, e)</span><br><span class="line">           logInfo(s&quot;Restarting Receiver $receiverId&quot;)</span><br><span class="line">           self.send(RestartReceiver(receiver))</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;(ThreadUtils.sameThread)</span><br><span class="line">     logInfo(s&quot;Receiver $&#123;receiver.streamId&#125; started&quot;)</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>根据spark job提交一文介绍，最终startReceiverFunc函数会被包装成ResultTask运行在executor上，而ResultTask会调用startReceiverFunc完成receiverSupervisor的创建。</p>
<h3 id="3-1-Receiver"><a href="#3-1-Receiver" class="headerlink" title="3.1 Receiver"></a>3.1 Receiver</h3><p>上 面代码Receiver的启动序列是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ReceiverSupervisor#start</span><br><span class="line">   -&gt; ReceiverSupervisor#startReceiver</span><br><span class="line">      -&gt; Receiver#onStart</span><br></pre></td></tr></table></figure></p>
<p>Receiver主要有如下成员和方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">@transient private var _supervisor: ReceiverSupervisor = null</span><br><span class="line">def storeXXX()</span><br><span class="line">def onStart()</span><br><span class="line">def streamId: Int = id</span><br></pre></td></tr></table></figure></p>
<ol>
<li>_supervisor,  Receiver需要将自己接受到的数据转给ReceiverSupervisor</li>
<li>storeXXX,是一系列的方法， 存储数据，内部就是调用ReceiverSupervisor的方法从而将数据转给他存储并汇报给ReceiverTracker。</li>
<li>onStart，receiver启动是调用，一般在这里从流中读数据</li>
<li>streamId， 每一个输入流唯一的id标识</li>
</ol>
<p>以SocketReceiver为例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line">private[streaming]</span><br><span class="line">class SocketReceiver[T: ClassTag](</span><br><span class="line">    host: String,</span><br><span class="line">    port: Int,</span><br><span class="line">    bytesToObjects: InputStream =&gt; Iterator[T],</span><br><span class="line">    storageLevel: StorageLevel</span><br><span class="line">  ) extends Receiver[T](storageLevel) with Logging &#123;</span><br><span class="line"></span><br><span class="line">  private var socket: Socket = _</span><br><span class="line"></span><br><span class="line">  def onStart() &#123;</span><br><span class="line"></span><br><span class="line">    logInfo(s&quot;Connecting to $host:$port&quot;)</span><br><span class="line">    try &#123;</span><br><span class="line">      socket = new Socket(host, port)</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">      case e: ConnectException =&gt;</span><br><span class="line">        restart(s&quot;Error connecting to $host:$port&quot;, e)</span><br><span class="line">        return</span><br><span class="line">    &#125;</span><br><span class="line">    logInfo(s&quot;Connected to $host:$port&quot;)</span><br><span class="line"></span><br><span class="line">    // Start the thread that receives data over a connection</span><br><span class="line">    new Thread(&quot;Socket Receiver&quot;) &#123;</span><br><span class="line">      setDaemon(true)</span><br><span class="line">      override def run() &#123; receive() &#125;</span><br><span class="line">    &#125;.start()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  def onStop() &#123;</span><br><span class="line">    // in case restart thread close it twice</span><br><span class="line">    synchronized &#123;</span><br><span class="line">      if (socket != null) &#123;</span><br><span class="line">        socket.close()</span><br><span class="line">        socket = null</span><br><span class="line">        logInfo(s&quot;Closed socket to $host:$port&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  /** Create a socket connection and receive data until receiver is stopped */</span><br><span class="line">  def receive() &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">      val iterator = bytesToObjects(socket.getInputStream())</span><br><span class="line">      while(!isStopped &amp;&amp; iterator.hasNext) &#123;</span><br><span class="line">        store(iterator.next())</span><br><span class="line">      &#125;</span><br><span class="line">      if (!isStopped()) &#123;</span><br><span class="line">        restart(&quot;Socket data stream had no more data&quot;)</span><br><span class="line">      &#125; else &#123;</span><br><span class="line">        logInfo(&quot;Stopped receiving&quot;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; catch &#123;</span><br><span class="line">      case NonFatal(e) =&gt;</span><br><span class="line">        logWarning(&quot;Error receiving data&quot;, e)</span><br><span class="line">        restart(&quot;Error receiving data&quot;, e)</span><br><span class="line">    &#125; finally &#123;</span><br><span class="line">      onStop()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ol>
<li>onStart方法启动了后台线程调用receive()接收数据</li>
<li>receive方法调用store方法存入一条数据记录。<br>下面是store方法：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">def store(dataItem: T) &#123;</span><br><span class="line">  // 数据交给了ReceiverSupervisor</span><br><span class="line">   supervisor.pushSingle(dataItem)</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="3-2-ReceiverSupervisor"><a href="#3-2-ReceiverSupervisor" class="headerlink" title="3.2 ReceiverSupervisor"></a>3.2 ReceiverSupervisor</h3><p>ReceiverSupervisor只有一个实现类ReceiverSupervisorImpl，它运行在executor上，启动时会一同启动Receiver。并将接收到的数据存储起来，然后将数据信息汇报到ReceiverTracker，下面是其主要的方法和属性：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">private val receivedBlockHandler: ReceivedBlockHandler</span><br><span class="line">private val trackerEndpoint </span><br><span class="line">private val endpoint </span><br><span class="line">private val registeredBlockGenerators = new ConcurrentLinkedQueue[BlockGenerator]()</span><br><span class="line">private val  defaultBlockGeneratorListener</span><br></pre></td></tr></table></figure></p>
<ol>
<li><p>receivedBlockHandler<br>主要有两种实现：</p>
<ul>
<li>WriteAheadLogBasedBlockHandler， 对于receiver转过来的数据，使用WAL的方式保存，当出错重启时可以从中恢复，确保可靠性。</li>
<li>BlockManagerBasedBlockHandler，使用blockmanager来管理数据。</li>
</ul>
<p>WAL的方式的好处是数据写在hdfs中，当driver application意外退出是，数据也不会丢失，使用blockmanager的话如果driver application失败了，或者executor所在node没了，都有可能导致数据丢失。<br>通过<code>spark.streaming.receiver.writeAheadLog.enable</code>设置使用WAL的方式，使用WAL方式时，数据同时也会使用blockmanager管理。</p>
</li>
<li><p>trackerEndpoint，是由ReceiverTracker 的rpc服务的引用，用来和ReceiverTracker通信（Spark Rpc原理参考<a href="http://www.jianshu.com/p/7da49e332e70" target="_blank" rel="noopener">spark rpc原理</a>）</p>
</li>
<li>endpoint，ReceiverSupervisor自身提供的一些rpc服务，接收的消息主要有：<ul>
<li>StopReceiver， 停止Receiver，ReceiverSupervisor</li>
<li>对receivedBlockHandler保存下来的数据做一些清除工作</li>
</ul>
</li>
<li><p>registeredBlockGenerators<br>有时候receiver每次只上报一条数据，显然为一条数据创建一个block id取管理是低效的，registeredBlockGenerators就是用来汇集那些一条条上报的数据，达到一定大小后交给ReceiverSupervisor去保存成一个block</p>
</li>
<li><p>defaultBlockGeneratorListener，这个listener下面讲BlockGenerator会讲到，BlockGenerator讲汇集好的block再转交给ReceiverSupervisor时就是用这个listener会调完成的。</p>
</li>
</ol>
<h4 id="3-2-1-BlockGenerator"><a href="#3-2-1-BlockGenerator" class="headerlink" title="3.2.1 BlockGenerator"></a>3.2.1 BlockGenerator</h4><p>上面4中，ReceiverSupervisor启动时会默认注册一个defaultBlockGenerator，其类就是BlockGenerator。<br>这个类有如下一些成员：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">private[streaming] class BlockGenerator(</span><br><span class="line">      listener: BlockGeneratorListener,</span><br><span class="line">      receiverId: Int,</span><br><span class="line">      conf: SparkConf,</span><br><span class="line">      clock: Clock = new SystemClock()</span><br><span class="line">    ) extends RateLimiter(conf) with Logging &#123;</span><br><span class="line">...</span><br><span class="line">private val blockIntervalTimer =</span><br><span class="line">    new RecurringTimer(clock, blockIntervalMs, updateCurrentBuffer, &quot;BlockGenerator&quot;)</span><br><span class="line"> </span><br><span class="line">  private val blocksForPushing = new ArrayBlockingQueue[Block](blockQueueSize)</span><br><span class="line">  private val blockPushingThread = new Thread() &#123; override def run() &#123; keepPushingBlocks() &#125; &#125;</span><br><span class="line">  @volatile private var currentBuffer = new ArrayBuffer[Any]</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<ol>
<li>listener, 创建时由ReceiverSupervisor传递的，也就是上面5中的defaultBlockGeneratorListener </li>
<li>blockIntervalTimer,前面说blockGenerator用来将一条条转过来的数据汇集成一个个block，这个定时器每隔一段时间(blockIntervalMs)汇集一次数据</li>
<li>blocksForPushing，数据被汇集成block后，先暂存在这里，等待转交给ReceiverSupervisor保存并汇报</li>
<li>blockPushingThread，线程不停的讲blocksForPushing中的block转交给ReceiverSupervisor</li>
<li>currentBuffer,receiver发过来的一条条数据先暂时存在这里，等待blockIntervalTimer汇集一起成block。</li>
</ol>
<p>下图描述了数据从receiver到ReceiverTracker的流程</p>
<p><img src="/image/spark-streaming/spark-streaming-procedure.png" alt="数据流转过程"></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><a class="page-number" href="/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/page/4/">4</a><a class="extend next" rel="next" href="/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Li Weisheng</p>
              <p class="site-description motion-element" itemprop="description">不积跬步，无以至千里</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">33</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">16</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Li Weisheng</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Mist</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
